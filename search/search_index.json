{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"E-Agle TRT Wiki","title":"E-Agle TRT Wiki"},{"location":"#e-agle-trt-wiki","text":"","title":"E-Agle TRT Wiki"},{"location":"common/about/writing-docs/","text":"Writing Documentation Testing the documentation locally You can test locally the exported documentation using the custom docker image generated by the wiki project. Open a terminal in the root folder of your project Make sure the docs/ folder is present Fetch the documentation image: docker pull eagletrt/wiki:latest Run the autoreloading documentation: docker run --rm \\ -p 8000 :8000 \\ -v $( pwd ) /docs:/wiki/docs/<project-name>:z \\ eagletrt/wiki Tip Live reloading works when testing with docker. Ordering pages You can change the order and titles of your pages by configuring a .pages file anywhere in your documentation file tree. For more information on the file format take a look at the official documentation . title: Example nav: - subdirectory - page1.md - page2.md Diagrams You can draw diagrams with mermaid . ```diagram stateDiagram-v2 [*] --> Still Still --> [*] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] ``` stateDiagram-v2 [*] --> Still Still --> [*] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] Notes and warnings !!! note This this a note. Note This this a note. !!! warning This this a warning. Warning This this a warning. Supported types are: note abstract , summary , tldr info , todo tip , hint , important success , check , done question , help , faq warning , caution , attention failure , fail , missing danger , error bug example quote , cite Mathematical expressions $x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$ \\(x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\\) Embedding PDFs < object data = \"../sample.pdf\" type = \"application/pdf\" style = \"width: 100%; height: 600px\" > < embed src = \"../sample.pdf\" type = \"application/pdf\" /> </ object >","title":"Writing Documentation"},{"location":"common/about/writing-docs/#writing-documentation","text":"","title":"Writing Documentation"},{"location":"common/about/writing-docs/#testing-the-documentation-locally","text":"You can test locally the exported documentation using the custom docker image generated by the wiki project. Open a terminal in the root folder of your project Make sure the docs/ folder is present Fetch the documentation image: docker pull eagletrt/wiki:latest Run the autoreloading documentation: docker run --rm \\ -p 8000 :8000 \\ -v $( pwd ) /docs:/wiki/docs/<project-name>:z \\ eagletrt/wiki Tip Live reloading works when testing with docker.","title":"Testing the documentation locally"},{"location":"common/about/writing-docs/#ordering-pages","text":"You can change the order and titles of your pages by configuring a .pages file anywhere in your documentation file tree. For more information on the file format take a look at the official documentation . title: Example nav: - subdirectory - page1.md - page2.md","title":"Ordering pages"},{"location":"common/about/writing-docs/#diagrams","text":"You can draw diagrams with mermaid . ```diagram stateDiagram-v2 [*] --> Still Still --> [*] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] ``` stateDiagram-v2 [*] --> Still Still --> [*] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*]","title":"Diagrams"},{"location":"common/about/writing-docs/#notes-and-warnings","text":"!!! note This this a note. Note This this a note. !!! warning This this a warning. Warning This this a warning. Supported types are: note abstract , summary , tldr info , todo tip , hint , important success , check , done question , help , faq warning , caution , attention failure , fail , missing danger , error bug example quote , cite","title":"Notes and warnings"},{"location":"common/about/writing-docs/#mathematical-expressions","text":"$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$ \\(x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\\)","title":"Mathematical expressions"},{"location":"common/about/writing-docs/#embedding-pdfs","text":"< object data = \"../sample.pdf\" type = \"application/pdf\" style = \"width: 100%; height: 600px\" > < embed src = \"../sample.pdf\" type = \"application/pdf\" /> </ object >","title":"Embedding PDFs"},{"location":"common/shared/can-config/","text":"Configuring of the CAN-bus on ST MCUs On CubeMX Activate the Peripheral In CubeMX, expand the \"Connectivity\" tab on the left pane and click on the CAN interface you wish to activate. A configuration pane will appear on the right; tick the \"Activated\" checkbox. Set the Bit Timing Parameters The sampling of the signal is dictated by a number of parameters that set time constraints for the reading and transmitting instants. The duration of a bit (nominal bit time) is split into four segments: a synchronization segment (SYNC_SEG) to sync all nodes on the network, the first Bit Segment (BS1) to define the location of the sampling point, the second Bit Segment to define the transmit point (BS2), and a resynchronization Jump Width (SJW) that indicates how much segments can be lengthened or shortened to compensate for timing errors or delays. The length of these segments is defined in terms of number of Time Quanta ( \\(t_q\\) ). For a visual representation of the subdivision and the mapping of the values to the registers refer to the image below. To define the duration of a time quanta and the length of the various segments, you need to input your parameters into the \"Configuration\" panel that appeared in CubeMx from the previous step (below the \"Activate\" checkbox\"). If your parameters are still to be defined, use an online calculator such as bittiming.can-wiki.info and fill the form; note that selecting the platform is only needed if you're interested in the register mapping, but in any case this website provides a choice for \"ST Microelectronics bxCAN\" which is our case. Input the clock frequency after checking your Clock Tree in CubeMX for how the relevant bus is configured (in the example below, the bxCAN peripheral is connected to the APB1 bus which is at 54 MHz) and of course that the frequency is high enough to operate at the target link speed. Next, input the desired sample point (the default 87.5% is fine), the SJW duration (the default 1 is fine as well), and the desired bitrate in kbit/s . The calculator will generate a table with valid combinations: copy over the values into CubeMX for the Prescaler, BS1, and BS2 (SYNC_SEG is always of length 1 \\(t_q\\) ) and check that the resulting baud rate is correct. The last operation left to perform in CubeMX is to activate all CAN interrupts in the NVIC array: in the same panel as above, switch to the \"NVIC\" tab and tick all checkboxes. In Your Code Most of the information that follows is available in the source documentation of the stm32fXxx_hal_can.c driver file, so check there should you need any additional detail. However, much of the process outlined there is handled automatically by CubeMX, so this document should simplify your setup by only describing what has effectively to be done, while also using a less schematic and cryptic approach. Create the Callback Functions To register callbacks you need to create the relative functions with the proper names (in the form of HAL_CAN_xxxCallback(...) ). Callback signature Action upon which it is invoked void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *) A message has been received into FIFO 0 and is ready to be read. void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *) A message has been received into FIFO 1 and is ready to be read. void HAL_CAN_RxFifo0FullCallback(CAN_HandleTypeDef *) FIFO 0 has reached its full capacity. The next RX will cause an overrun error. void HAL_CAN_RxFifo1FullCallback(CAN_HandleTypeDef *) FIFO 1 has reached its full capacity. The next RX will cause an overrun error. void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *) Mailbox 0 is now clear (a pending TX has ended). void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *) Mailbox 1 is now clear (a pending TX has ended). void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *) Mailbox 2 is now clear (a pending TX has ended). void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *) An error in the peripheral has occurred. Make sure to properly log the raised error code. Example For your convenience, here is a prepared Error Callback that verbosely logs any error bit that is high in the error code. CAN_error_handler(...) is a custom sample function that prints the message over UART and lights up a red LED. void HAL_CAN_ErrorCallback ( CAN_HandleTypeDef * hcan ) { uint32_t e = hcan -> ErrorCode ; if ( e & HAL_CAN_ERROR_EWG ) CAN_error_handler ( \"Protocol Error Warning\" ); if ( e & HAL_CAN_ERROR_EPV ) CAN_error_handler ( \"Error Passive\" ); if ( e & HAL_CAN_ERROR_BOF ) CAN_error_handler ( \"Bus-off Error\" ); if ( e & HAL_CAN_ERROR_STF ) CAN_error_handler ( \"Stuff Error\" ); if ( e & HAL_CAN_ERROR_FOR ) CAN_error_handler ( \"Form Error\" ); if ( e & HAL_CAN_ERROR_ACK ) CAN_error_handler ( \"ACK Error\" ); if ( e & HAL_CAN_ERROR_BR ) CAN_error_handler ( \"Bit Recessive Error\" ); if ( e & HAL_CAN_ERROR_BD ) CAN_error_handler ( \"Bit Dominant Error\" ); if ( e & HAL_CAN_ERROR_CRC ) CAN_error_handler ( \"CRC Error\" ); if ( e & HAL_CAN_ERROR_RX_FOV0 ) CAN_error_handler ( \"FIFO0 Overrun\" ); if ( e & HAL_CAN_ERROR_RX_FOV1 ) CAN_error_handler ( \"FIFO1 Overrun\" ); if ( e & HAL_CAN_ERROR_TX_ALST0 ) CAN_error_handler ( \"Mailbox 0 TX failure (arbitration lost)\" ); if ( e & HAL_CAN_ERROR_TX_TERR0 ) CAN_error_handler ( \"Mailbox 0 TX failure (tx error)\" ); if ( e & HAL_CAN_ERROR_TX_ALST1 ) CAN_error_handler ( \"Mailbox 1 TX failure (arbitration lost)\" ); if ( e & HAL_CAN_ERROR_TX_TERR1 ) CAN_error_handler ( \"Mailbox 1 TX failure (tx error)\" ); if ( e & HAL_CAN_ERROR_TX_ALST2 ) CAN_error_handler ( \"Mailbox 2 TX failure (arbitration lost)\" ); if ( e & HAL_CAN_ERROR_TX_TERR2 ) CAN_error_handler ( \"Mailbox 2 TX failure (tx error)\" ); if ( e & HAL_CAN_ERROR_TIMEOUT ) CAN_error_handler ( \"Timeout Error\" ); if ( e & HAL_CAN_ERROR_NOT_INITIALIZED ) CAN_error_handler ( \"Peripheral not initialized\" ); if ( e & HAL_CAN_ERROR_NOT_READY ) CAN_error_handler ( \"Peripheral not ready\" ); if ( e & HAL_CAN_ERROR_NOT_STARTED ) CAN_error_handler ( \"Peripheral not strated\" ); if ( e & HAL_CAN_ERROR_PARAM ) CAN_error_handler ( \"Parameter Error\" ); } Activate the IRQ Handlers (\"Notifications\") At this point, in order for the code to actually invoke your callbacks, you need to activate the relative so-called Notifications with HAL_CAN_ActivateNotification(CAN_HandleTypeDef *, uint32_t) . Possible values for the IRQ number are, as defined in the driver file: /* Transmit Interrupt */ #define CAN_IT_TX_MAILBOX_EMPTY ((uint32_t)CAN_IER_TMEIE) /*!< Transmit mailbox empty interrupt */ /* Receive Interrupts */ #define CAN_IT_RX_FIFO0_MSG_PENDING ((uint32_t)CAN_IER_FMPIE0) /*!< FIFO 0 message pending interrupt */ #define CAN_IT_RX_FIFO0_FULL ((uint32_t)CAN_IER_FFIE0) /*!< FIFO 0 full interrupt */ #define CAN_IT_RX_FIFO0_OVERRUN ((uint32_t)CAN_IER_FOVIE0) /*!< FIFO 0 overrun interrupt */ #define CAN_IT_RX_FIFO1_MSG_PENDING ((uint32_t)CAN_IER_FMPIE1) /*!< FIFO 1 message pending interrupt */ #define CAN_IT_RX_FIFO1_FULL ((uint32_t)CAN_IER_FFIE1) /*!< FIFO 1 full interrupt */ #define CAN_IT_RX_FIFO1_OVERRUN ((uint32_t)CAN_IER_FOVIE1) /*!< FIFO 1 overrun interrupt */ /* Operating Mode Interrupts */ #define CAN_IT_WAKEUP ((uint32_t)CAN_IER_WKUIE) /*!< Wake-up interrupt */ #define CAN_IT_SLEEP_ACK ((uint32_t)CAN_IER_SLKIE) /*!< Sleep acknowledge interrupt */ /* Error Interrupts */ #define CAN_IT_ERROR_WARNING ((uint32_t)CAN_IER_EWGIE) /*!< Error warning interrupt */ #define CAN_IT_ERROR_PASSIVE ((uint32_t)CAN_IER_EPVIE) /*!< Error passive interrupt */ #define CAN_IT_BUSOFF ((uint32_t)CAN_IER_BOFIE) /*!< Bus-off interrupt */ #define CAN_IT_LAST_ERROR_CODE ((uint32_t)CAN_IER_LECIE) /*!< Last error code interrupt */ #define CAN_IT_ERROR ((uint32_t)CAN_IER_ERRIE) /*!< Error Interrupt */ Note that IRQ numbers can be OR-ed together and be activated many at once. For instance: HAL_CAN_ActivateNotification ( hcan , CAN_IT_ERROR_WARNING | CAN_IT_ERROR_PASSIVE | CAN_IT_BUSOFF | CAN_IT_LAST_ERROR_CODE | CAN_IT_ERROR ); Activate and Configure the Hardware Filters When a new message is received, CAN nodes can use hardware filters to decide if the message must be copied into SRAM and trigger an IRQ, or if it has to be discarded. The advantage of hardware filters is that unwanted messages don't waste any CPU cycles thus saving potentially a lot of resources, especially on heavy traffic networks with many nodes. STMs are equipped with a number of filter banks, each of which is composed by two 32-bit registers. Each bank can operate in ID Mask Mode or in ID List Mode : in the former, one register acts as the mask and the second as the ID, while in the latter mode, both registers represent IDs of the list. Filter banks can also be configured to operate in 16-bit mode, therefore doubling their capacity (four 16-bit registers instead of two 32-bit registers, which are split in two). In ID Mask mode this yields two pairs of Mask+ID, while in ID List mode, of course, it yields 4 ID registers. For a better understanding of the layout of a filter bank in relation to hardware registers, refer to the image below. ID Mask Mode In this mode the filtering is based on a mask register which tells which bits of the ID register need to be compared with the incoming message ID. For instance, with a mask of 11110000000 and an ID of 01110000000 , only messages whose ID begins with 0111 ( 0x3 ) will be accepted. Some more examples follow. Example Mask: 0b11111111111 ( 0x03FF ) ID: 0b11111111111 ( 0x03FF ) Accepted: only ID == 0x03FF Mask: 0b11111111110 ( 0x03FE ) ID: 0b11111111110 ( 0x03FE ) Accepted: { 0x03FE , 0x03FF } (as bit 0 of the filter is disabled) Mask: 0b11111111000 ( 0x03F8 ) ID: 0b00000000000 ( 0x0000 ) Accepted: ID from 0x000 to 0x007 (as bits 0, 1, 2 of the filter are disabled) ID List Mode In ID List Mode, incoming messages' IDs are simply compared for equality with every element of the list. Code To configure a filter, you need to allocate and populate a CAN_FilterTypeDef struct and pass it by reference to HAL_CAN_ConfigFilter(...) . Its fields are the following: FilterMode : either CAN_FILTERMODE_IDMASK or CAN_FILTERMODE_IDLIST , for the respective modes FilterIdHigh : MSBs of the ID register (or first one of the two 16-bit registers) FilterIdLow : LSBs of the ID register (or second one of the two 16-bit registers) FilterMaskIdHigh : MSBs of the Mask register (or first one of the two 16-bit registers) FilterMaskIdLow : LSBs of the Mask register (or second one of the two 16-bit registers) FilterFIFOAssignment : the queue in which to store messages (a value of CAN_filter_FIFO , e.g. CAN_FILTER_FIFO0 ) FilterBank : index of the filter bank to be initialized FilterScale : CAN_FILTERSCALE_16BIT or CAN_FILTERSCALE_32BIT , for the respective register scale FilterActivation : ENABLE or DISABLE Example A filter that accepts everything would look like this: CAN_FilterTypeDef f ; f . FilterMode = CAN_FILTERMODE_IDMASK ; f . FilterIdLow = 0x0 ; // Meaningless, mask is all 0s f . FilterIdHigh = 0x0 ; // Meaningless, mask is all 0s f . FilterMaskIdHigh = 0x0 ; f . FilterMaskIdLow = 0x0 ; f . FilterFIFOAssignment = CAN_FILTER_FIFO0 ; f . FilterBank = 0 ; f . FilterScale = CAN_FILTERSCALE_32BIT ; f . FilterActivation = ENABLE ; HAL_CAN_ConfigFilter ( hcan , & f ); Final Operations The last step is to actually start the peripheral by calling HAL_CAN_Start(...) . To use it, send messages with HAL_CAN_AddTxMessage(...) after checking for free mailboxes with HAL_CAN_GetTxMailboxesFreeLevel(...) and read received messages with HAL_CAN_GetRxMessage(...) . Should anything not work properly, refer to the next document, CAN-bus Troubleshooting .","title":"CAN-bus Configuration"},{"location":"common/shared/can-config/#configuring-of-the-can-bus-on-st-mcus","text":"","title":"Configuring of the CAN-bus on ST MCUs"},{"location":"common/shared/can-config/#on-cubemx","text":"","title":"On CubeMX"},{"location":"common/shared/can-config/#activate-the-peripheral","text":"In CubeMX, expand the \"Connectivity\" tab on the left pane and click on the CAN interface you wish to activate. A configuration pane will appear on the right; tick the \"Activated\" checkbox.","title":"Activate the Peripheral"},{"location":"common/shared/can-config/#set-the-bit-timing-parameters","text":"The sampling of the signal is dictated by a number of parameters that set time constraints for the reading and transmitting instants. The duration of a bit (nominal bit time) is split into four segments: a synchronization segment (SYNC_SEG) to sync all nodes on the network, the first Bit Segment (BS1) to define the location of the sampling point, the second Bit Segment to define the transmit point (BS2), and a resynchronization Jump Width (SJW) that indicates how much segments can be lengthened or shortened to compensate for timing errors or delays. The length of these segments is defined in terms of number of Time Quanta ( \\(t_q\\) ). For a visual representation of the subdivision and the mapping of the values to the registers refer to the image below. To define the duration of a time quanta and the length of the various segments, you need to input your parameters into the \"Configuration\" panel that appeared in CubeMx from the previous step (below the \"Activate\" checkbox\"). If your parameters are still to be defined, use an online calculator such as bittiming.can-wiki.info and fill the form; note that selecting the platform is only needed if you're interested in the register mapping, but in any case this website provides a choice for \"ST Microelectronics bxCAN\" which is our case. Input the clock frequency after checking your Clock Tree in CubeMX for how the relevant bus is configured (in the example below, the bxCAN peripheral is connected to the APB1 bus which is at 54 MHz) and of course that the frequency is high enough to operate at the target link speed. Next, input the desired sample point (the default 87.5% is fine), the SJW duration (the default 1 is fine as well), and the desired bitrate in kbit/s . The calculator will generate a table with valid combinations: copy over the values into CubeMX for the Prescaler, BS1, and BS2 (SYNC_SEG is always of length 1 \\(t_q\\) ) and check that the resulting baud rate is correct. The last operation left to perform in CubeMX is to activate all CAN interrupts in the NVIC array: in the same panel as above, switch to the \"NVIC\" tab and tick all checkboxes.","title":"Set the Bit Timing Parameters"},{"location":"common/shared/can-config/#in-your-code","text":"Most of the information that follows is available in the source documentation of the stm32fXxx_hal_can.c driver file, so check there should you need any additional detail. However, much of the process outlined there is handled automatically by CubeMX, so this document should simplify your setup by only describing what has effectively to be done, while also using a less schematic and cryptic approach.","title":"In Your Code"},{"location":"common/shared/can-config/#create-the-callback-functions","text":"To register callbacks you need to create the relative functions with the proper names (in the form of HAL_CAN_xxxCallback(...) ). Callback signature Action upon which it is invoked void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *) A message has been received into FIFO 0 and is ready to be read. void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *) A message has been received into FIFO 1 and is ready to be read. void HAL_CAN_RxFifo0FullCallback(CAN_HandleTypeDef *) FIFO 0 has reached its full capacity. The next RX will cause an overrun error. void HAL_CAN_RxFifo1FullCallback(CAN_HandleTypeDef *) FIFO 1 has reached its full capacity. The next RX will cause an overrun error. void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *) Mailbox 0 is now clear (a pending TX has ended). void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *) Mailbox 1 is now clear (a pending TX has ended). void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *) Mailbox 2 is now clear (a pending TX has ended). void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *) An error in the peripheral has occurred. Make sure to properly log the raised error code. Example For your convenience, here is a prepared Error Callback that verbosely logs any error bit that is high in the error code. CAN_error_handler(...) is a custom sample function that prints the message over UART and lights up a red LED. void HAL_CAN_ErrorCallback ( CAN_HandleTypeDef * hcan ) { uint32_t e = hcan -> ErrorCode ; if ( e & HAL_CAN_ERROR_EWG ) CAN_error_handler ( \"Protocol Error Warning\" ); if ( e & HAL_CAN_ERROR_EPV ) CAN_error_handler ( \"Error Passive\" ); if ( e & HAL_CAN_ERROR_BOF ) CAN_error_handler ( \"Bus-off Error\" ); if ( e & HAL_CAN_ERROR_STF ) CAN_error_handler ( \"Stuff Error\" ); if ( e & HAL_CAN_ERROR_FOR ) CAN_error_handler ( \"Form Error\" ); if ( e & HAL_CAN_ERROR_ACK ) CAN_error_handler ( \"ACK Error\" ); if ( e & HAL_CAN_ERROR_BR ) CAN_error_handler ( \"Bit Recessive Error\" ); if ( e & HAL_CAN_ERROR_BD ) CAN_error_handler ( \"Bit Dominant Error\" ); if ( e & HAL_CAN_ERROR_CRC ) CAN_error_handler ( \"CRC Error\" ); if ( e & HAL_CAN_ERROR_RX_FOV0 ) CAN_error_handler ( \"FIFO0 Overrun\" ); if ( e & HAL_CAN_ERROR_RX_FOV1 ) CAN_error_handler ( \"FIFO1 Overrun\" ); if ( e & HAL_CAN_ERROR_TX_ALST0 ) CAN_error_handler ( \"Mailbox 0 TX failure (arbitration lost)\" ); if ( e & HAL_CAN_ERROR_TX_TERR0 ) CAN_error_handler ( \"Mailbox 0 TX failure (tx error)\" ); if ( e & HAL_CAN_ERROR_TX_ALST1 ) CAN_error_handler ( \"Mailbox 1 TX failure (arbitration lost)\" ); if ( e & HAL_CAN_ERROR_TX_TERR1 ) CAN_error_handler ( \"Mailbox 1 TX failure (tx error)\" ); if ( e & HAL_CAN_ERROR_TX_ALST2 ) CAN_error_handler ( \"Mailbox 2 TX failure (arbitration lost)\" ); if ( e & HAL_CAN_ERROR_TX_TERR2 ) CAN_error_handler ( \"Mailbox 2 TX failure (tx error)\" ); if ( e & HAL_CAN_ERROR_TIMEOUT ) CAN_error_handler ( \"Timeout Error\" ); if ( e & HAL_CAN_ERROR_NOT_INITIALIZED ) CAN_error_handler ( \"Peripheral not initialized\" ); if ( e & HAL_CAN_ERROR_NOT_READY ) CAN_error_handler ( \"Peripheral not ready\" ); if ( e & HAL_CAN_ERROR_NOT_STARTED ) CAN_error_handler ( \"Peripheral not strated\" ); if ( e & HAL_CAN_ERROR_PARAM ) CAN_error_handler ( \"Parameter Error\" ); }","title":"Create the Callback Functions"},{"location":"common/shared/can-config/#activate-the-irq-handlers-notifications","text":"At this point, in order for the code to actually invoke your callbacks, you need to activate the relative so-called Notifications with HAL_CAN_ActivateNotification(CAN_HandleTypeDef *, uint32_t) . Possible values for the IRQ number are, as defined in the driver file: /* Transmit Interrupt */ #define CAN_IT_TX_MAILBOX_EMPTY ((uint32_t)CAN_IER_TMEIE) /*!< Transmit mailbox empty interrupt */ /* Receive Interrupts */ #define CAN_IT_RX_FIFO0_MSG_PENDING ((uint32_t)CAN_IER_FMPIE0) /*!< FIFO 0 message pending interrupt */ #define CAN_IT_RX_FIFO0_FULL ((uint32_t)CAN_IER_FFIE0) /*!< FIFO 0 full interrupt */ #define CAN_IT_RX_FIFO0_OVERRUN ((uint32_t)CAN_IER_FOVIE0) /*!< FIFO 0 overrun interrupt */ #define CAN_IT_RX_FIFO1_MSG_PENDING ((uint32_t)CAN_IER_FMPIE1) /*!< FIFO 1 message pending interrupt */ #define CAN_IT_RX_FIFO1_FULL ((uint32_t)CAN_IER_FFIE1) /*!< FIFO 1 full interrupt */ #define CAN_IT_RX_FIFO1_OVERRUN ((uint32_t)CAN_IER_FOVIE1) /*!< FIFO 1 overrun interrupt */ /* Operating Mode Interrupts */ #define CAN_IT_WAKEUP ((uint32_t)CAN_IER_WKUIE) /*!< Wake-up interrupt */ #define CAN_IT_SLEEP_ACK ((uint32_t)CAN_IER_SLKIE) /*!< Sleep acknowledge interrupt */ /* Error Interrupts */ #define CAN_IT_ERROR_WARNING ((uint32_t)CAN_IER_EWGIE) /*!< Error warning interrupt */ #define CAN_IT_ERROR_PASSIVE ((uint32_t)CAN_IER_EPVIE) /*!< Error passive interrupt */ #define CAN_IT_BUSOFF ((uint32_t)CAN_IER_BOFIE) /*!< Bus-off interrupt */ #define CAN_IT_LAST_ERROR_CODE ((uint32_t)CAN_IER_LECIE) /*!< Last error code interrupt */ #define CAN_IT_ERROR ((uint32_t)CAN_IER_ERRIE) /*!< Error Interrupt */ Note that IRQ numbers can be OR-ed together and be activated many at once. For instance: HAL_CAN_ActivateNotification ( hcan , CAN_IT_ERROR_WARNING | CAN_IT_ERROR_PASSIVE | CAN_IT_BUSOFF | CAN_IT_LAST_ERROR_CODE | CAN_IT_ERROR );","title":"Activate the IRQ Handlers (\"Notifications\")"},{"location":"common/shared/can-config/#activate-and-configure-the-hardware-filters","text":"When a new message is received, CAN nodes can use hardware filters to decide if the message must be copied into SRAM and trigger an IRQ, or if it has to be discarded. The advantage of hardware filters is that unwanted messages don't waste any CPU cycles thus saving potentially a lot of resources, especially on heavy traffic networks with many nodes. STMs are equipped with a number of filter banks, each of which is composed by two 32-bit registers. Each bank can operate in ID Mask Mode or in ID List Mode : in the former, one register acts as the mask and the second as the ID, while in the latter mode, both registers represent IDs of the list. Filter banks can also be configured to operate in 16-bit mode, therefore doubling their capacity (four 16-bit registers instead of two 32-bit registers, which are split in two). In ID Mask mode this yields two pairs of Mask+ID, while in ID List mode, of course, it yields 4 ID registers. For a better understanding of the layout of a filter bank in relation to hardware registers, refer to the image below.","title":"Activate and Configure the Hardware Filters"},{"location":"common/shared/can-config/#id-mask-mode","text":"In this mode the filtering is based on a mask register which tells which bits of the ID register need to be compared with the incoming message ID. For instance, with a mask of 11110000000 and an ID of 01110000000 , only messages whose ID begins with 0111 ( 0x3 ) will be accepted. Some more examples follow. Example Mask: 0b11111111111 ( 0x03FF ) ID: 0b11111111111 ( 0x03FF ) Accepted: only ID == 0x03FF Mask: 0b11111111110 ( 0x03FE ) ID: 0b11111111110 ( 0x03FE ) Accepted: { 0x03FE , 0x03FF } (as bit 0 of the filter is disabled) Mask: 0b11111111000 ( 0x03F8 ) ID: 0b00000000000 ( 0x0000 ) Accepted: ID from 0x000 to 0x007 (as bits 0, 1, 2 of the filter are disabled)","title":"ID Mask Mode"},{"location":"common/shared/can-config/#id-list-mode","text":"In ID List Mode, incoming messages' IDs are simply compared for equality with every element of the list.","title":"ID List Mode"},{"location":"common/shared/can-config/#code","text":"To configure a filter, you need to allocate and populate a CAN_FilterTypeDef struct and pass it by reference to HAL_CAN_ConfigFilter(...) . Its fields are the following: FilterMode : either CAN_FILTERMODE_IDMASK or CAN_FILTERMODE_IDLIST , for the respective modes FilterIdHigh : MSBs of the ID register (or first one of the two 16-bit registers) FilterIdLow : LSBs of the ID register (or second one of the two 16-bit registers) FilterMaskIdHigh : MSBs of the Mask register (or first one of the two 16-bit registers) FilterMaskIdLow : LSBs of the Mask register (or second one of the two 16-bit registers) FilterFIFOAssignment : the queue in which to store messages (a value of CAN_filter_FIFO , e.g. CAN_FILTER_FIFO0 ) FilterBank : index of the filter bank to be initialized FilterScale : CAN_FILTERSCALE_16BIT or CAN_FILTERSCALE_32BIT , for the respective register scale FilterActivation : ENABLE or DISABLE Example A filter that accepts everything would look like this: CAN_FilterTypeDef f ; f . FilterMode = CAN_FILTERMODE_IDMASK ; f . FilterIdLow = 0x0 ; // Meaningless, mask is all 0s f . FilterIdHigh = 0x0 ; // Meaningless, mask is all 0s f . FilterMaskIdHigh = 0x0 ; f . FilterMaskIdLow = 0x0 ; f . FilterFIFOAssignment = CAN_FILTER_FIFO0 ; f . FilterBank = 0 ; f . FilterScale = CAN_FILTERSCALE_32BIT ; f . FilterActivation = ENABLE ; HAL_CAN_ConfigFilter ( hcan , & f );","title":"Code"},{"location":"common/shared/can-config/#final-operations","text":"The last step is to actually start the peripheral by calling HAL_CAN_Start(...) . To use it, send messages with HAL_CAN_AddTxMessage(...) after checking for free mailboxes with HAL_CAN_GetTxMailboxesFreeLevel(...) and read received messages with HAL_CAN_GetRxMessage(...) . Should anything not work properly, refer to the next document, CAN-bus Troubleshooting .","title":"Final Operations"},{"location":"common/shared/can-debugging/","text":"CAN-bus Troubleshooting Step 1: Check Your Configuration Check that your CubeMX configuration and your code precisely match what is detailed in CAN-bus Configuration . Warning Be sure to activate all error interrupts and log them properly, otherwise you'll have no way of knowing what is failing and how to fix it. Step 2: Follow This Flowchart Find your problem in the flowchart below and more details in the next chapter. Step 3: Find More Details From The Flowchart Look for the paragraph regarding your problem and read through. CAN Transceiver not communicating with the MCU While the CAN bus operates on two differential lines, the MCU uses a serial protocol, for which a transceiver is needed (for instance, an MCP2562) that translates the CAN_H and CAN_L signals into CAN_TX and CAN_RX. Absence of communication with this device causes the HAL_CAN_Start call to fail with a timeout error. Check Check continuity between all relevant pins of the transceiver, the CAN socket, and the MCU pins. Try swapping the transceiver with a new one. Termination resistors not present or of incorrect value On a CAN network it is very important that the bus is terminated on both sides by a 120 \\(\\Omega\\) resistor ( interesting article on why ). Also note that some devices might already incorporate a termination resistor on their end, so pay attention to how many you put. Check Verify that resistors are properly connected to the bus and are of the correct value. Check schematics and datasheets for already-present termination resistors on the connected nodes. Use an oscilloscope to ensure that the quality of the signal is good. List of errors raised by the HAL library CAN errors are defined in the driver file stm32f7xx_hal_can.h as follows: #define HAL_CAN_ERROR_NONE (0x00000000U) /*!< No error */ #define HAL_CAN_ERROR_EWG (0x00000001U) /*!< Protocol Error Warning */ #define HAL_CAN_ERROR_EPV (0x00000002U) /*!< Error Passive */ #define HAL_CAN_ERROR_BOF (0x00000004U) /*!< Bus-off error */ #define HAL_CAN_ERROR_STF (0x00000008U) /*!< Stuff error */ #define HAL_CAN_ERROR_FOR (0x00000010U) /*!< Form error */ #define HAL_CAN_ERROR_ACK (0x00000020U) /*!< Acknowledgment error */ #define HAL_CAN_ERROR_BR (0x00000040U) /*!< Bit recessive error */ #define HAL_CAN_ERROR_BD (0x00000080U) /*!< Bit dominant error */ #define HAL_CAN_ERROR_CRC (0x00000100U) /*!< CRC error */ #define HAL_CAN_ERROR_RX_FOV0 (0x00000200U) /*!< Rx FIFO0 overrun error */ #define HAL_CAN_ERROR_RX_FOV1 (0x00000400U) /*!< Rx FIFO1 overrun error */ #define HAL_CAN_ERROR_TX_ALST0 (0x00000800U) /*!< TxMailbox 0 transmit failure due to arbitration lost */ #define HAL_CAN_ERROR_TX_TERR0 (0x00001000U) /*!< TxMailbox 0 transmit failure due to transmit error */ #define HAL_CAN_ERROR_TX_ALST1 (0x00002000U) /*!< TxMailbox 1 transmit failure due to arbitration lost */ #define HAL_CAN_ERROR_TX_TERR1 (0x00004000U) /*!< TxMailbox 1 transmit failure due to transmit error */ #define HAL_CAN_ERROR_TX_ALST2 (0x00008000U) /*!< TxMailbox 2 transmit failure due to arbitration lost */ #define HAL_CAN_ERROR_TX_TERR2 (0x00010000U) /*!< TxMailbox 2 transmit failure due to transmit error */ #define HAL_CAN_ERROR_TIMEOUT (0x00020000U) /*!< Timeout error */ #define HAL_CAN_ERROR_NOT_INITIALIZED (0x00040000U) /*!< Peripheral not initialized */ #define HAL_CAN_ERROR_NOT_READY (0x00080000U) /*!< Peripheral not ready */ #define HAL_CAN_ERROR_NOT_STARTED (0x00100000U) /*!< Peripheral not started */ #define HAL_CAN_ERROR_PARAM (0x00200000U) /*!< Parameter error */ In general, bus-related and protocol-related errors ( protocol error warning, error passive, bus-off, stuff error, form error, ACK error, bit dominant, bit recessive, CRC error ) indicate either an electric problem with the wiring, or an underlying issue with the clock precision or frequency. Check Double check with a multimeter that the bus is wired properly and that any jumpers make good contact. Use an oscilloscope to ensure that the signal is clear from interference and edges are sharp. Connect a logic analyzer to better understand the communication issue at binary level. See the Clock Skew section and double-check that the configured frequencies match the oscillators. Firmware-related errors such as overruns or transmit failures may instead indicate an overly congested network or a mistake by the developer when invoking low-level API calls. Check Test your device with less traffic to ensure that the performance of the MCU is suitable for the application. If you are using only two devices, try connecting a third one to better understand where and how the errors generate. Carefully compare your code with the HAL and ST application notes. Clock Skew ST's MCUs incorporate an internal low-cost 16MHz crystal (called HSI in the clock tree - High Speed Internal ) which is factory calibrated with a precision up to 1%. However, due to its low accuracy especially with temperature variations of the chip, peripherals can often encounter timing problems, in particular if running at higher frequencies generated by the PLL. Check Set-up an external crystal (HSE) and configure the MCU for the correct frequency. Check at runtime that the HSI is not being used as a fallback after a configuration error with a condition like if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_HSE) . Hardware FIFOs or Mailboxes are not properly cleared For MCUs with transmissions managed via mailboxes, the developer enqueues a new message to send by calling HAL_CAN_AddTxMessage(...) and providing as a last argument the address of a uint32_t variable in which the function will store the ID of the first free mailbox found. Errors may arise in two occasions: either the function is being called so frequently that the bus has no time to send and empty a slot, or no one is listening on the bus and the \"Automatic Retransmission\" option is set, making the MCU hang in a loop where it unsuccessfully tries to send messages over and over again. Conversely, reception queues might as well fill up and cause overruns if they are not read often enough or the network is so congested that the MCU cannot keep up. Warning When a CAN message arrives and its ISR is triggered, remember to call HAL_CAN_GetRxMessage(...) to clear the reception slot, otherwise an overrun will occur after few messages. Check If errors happen when transmitting, make sure you are not sending too frequently and either have free mailboxes available (check with HAL_CAN_GetTxMailboxesFreeLevel(...) ) or a software queue to temporarily store your pending packets. If instead they happen upon reception, test your code with as little incoming traffic as possible and try to understand if your MCU and your software architecture match the intended network performance. Always remember to also properly configure your hardware filters in order to only process what's necessary and not waste resources and CPU cycles. A segmentation fault or other error crashes the MCU The ST drivers and HAL library are generally very solid, so I advise to thoroughly check your code for memory leaks (if the MCU runs out of memory it simply stops) or possible sources of segmentation faults such as handling of pointers or calls to low-level functions like memcpy and such. Remember that if the firmware crashes you won't see any error message printed over serial, the processor will just freeze and stop. Check Print debug statements over UART or blink on-board LEDs to make sure your code keeps executing or, in fact, stops after a while. Use your IDE built-in debugging tools to interface with OpenOCD and find the exact instruction on which the crash happens. Filters not configured properly If a message is discarded by a hardware filter you will not receive interrupts of any kind. Warning Disabling filters will cause every message to be discarded, contrary to what you might expect. Check Carefully read the filter configuration section in CAN-bus Configuration and ensure your filters are behaving as you intend. Interrupts not configured properly For interrupts to be raised by the MCU, they need to be properly configured both from CubeMX and in your code. Check Verify that you followed the correct procedure detailed in the Interrupt section in CAN-bus Configuration .","title":"CAN-bus Troubleshooting"},{"location":"common/shared/can-debugging/#can-bus-troubleshooting","text":"","title":"CAN-bus Troubleshooting"},{"location":"common/shared/can-debugging/#step-1-check-your-configuration","text":"Check that your CubeMX configuration and your code precisely match what is detailed in CAN-bus Configuration . Warning Be sure to activate all error interrupts and log them properly, otherwise you'll have no way of knowing what is failing and how to fix it.","title":"Step 1: Check Your Configuration"},{"location":"common/shared/can-debugging/#step-2-follow-this-flowchart","text":"Find your problem in the flowchart below and more details in the next chapter.","title":"Step 2: Follow This Flowchart"},{"location":"common/shared/can-debugging/#step-3-find-more-details-from-the-flowchart","text":"Look for the paragraph regarding your problem and read through.","title":"Step 3: Find More Details From The Flowchart"},{"location":"common/shared/can-debugging/#can-transceiver-not-communicating-with-the-mcu","text":"While the CAN bus operates on two differential lines, the MCU uses a serial protocol, for which a transceiver is needed (for instance, an MCP2562) that translates the CAN_H and CAN_L signals into CAN_TX and CAN_RX. Absence of communication with this device causes the HAL_CAN_Start call to fail with a timeout error. Check Check continuity between all relevant pins of the transceiver, the CAN socket, and the MCU pins. Try swapping the transceiver with a new one.","title":"CAN Transceiver not communicating with the MCU"},{"location":"common/shared/can-debugging/#termination-resistors-not-present-or-of-incorrect-value","text":"On a CAN network it is very important that the bus is terminated on both sides by a 120 \\(\\Omega\\) resistor ( interesting article on why ). Also note that some devices might already incorporate a termination resistor on their end, so pay attention to how many you put. Check Verify that resistors are properly connected to the bus and are of the correct value. Check schematics and datasheets for already-present termination resistors on the connected nodes. Use an oscilloscope to ensure that the quality of the signal is good.","title":"Termination resistors not present or of incorrect value"},{"location":"common/shared/can-debugging/#list-of-errors-raised-by-the-hal-library","text":"CAN errors are defined in the driver file stm32f7xx_hal_can.h as follows: #define HAL_CAN_ERROR_NONE (0x00000000U) /*!< No error */ #define HAL_CAN_ERROR_EWG (0x00000001U) /*!< Protocol Error Warning */ #define HAL_CAN_ERROR_EPV (0x00000002U) /*!< Error Passive */ #define HAL_CAN_ERROR_BOF (0x00000004U) /*!< Bus-off error */ #define HAL_CAN_ERROR_STF (0x00000008U) /*!< Stuff error */ #define HAL_CAN_ERROR_FOR (0x00000010U) /*!< Form error */ #define HAL_CAN_ERROR_ACK (0x00000020U) /*!< Acknowledgment error */ #define HAL_CAN_ERROR_BR (0x00000040U) /*!< Bit recessive error */ #define HAL_CAN_ERROR_BD (0x00000080U) /*!< Bit dominant error */ #define HAL_CAN_ERROR_CRC (0x00000100U) /*!< CRC error */ #define HAL_CAN_ERROR_RX_FOV0 (0x00000200U) /*!< Rx FIFO0 overrun error */ #define HAL_CAN_ERROR_RX_FOV1 (0x00000400U) /*!< Rx FIFO1 overrun error */ #define HAL_CAN_ERROR_TX_ALST0 (0x00000800U) /*!< TxMailbox 0 transmit failure due to arbitration lost */ #define HAL_CAN_ERROR_TX_TERR0 (0x00001000U) /*!< TxMailbox 0 transmit failure due to transmit error */ #define HAL_CAN_ERROR_TX_ALST1 (0x00002000U) /*!< TxMailbox 1 transmit failure due to arbitration lost */ #define HAL_CAN_ERROR_TX_TERR1 (0x00004000U) /*!< TxMailbox 1 transmit failure due to transmit error */ #define HAL_CAN_ERROR_TX_ALST2 (0x00008000U) /*!< TxMailbox 2 transmit failure due to arbitration lost */ #define HAL_CAN_ERROR_TX_TERR2 (0x00010000U) /*!< TxMailbox 2 transmit failure due to transmit error */ #define HAL_CAN_ERROR_TIMEOUT (0x00020000U) /*!< Timeout error */ #define HAL_CAN_ERROR_NOT_INITIALIZED (0x00040000U) /*!< Peripheral not initialized */ #define HAL_CAN_ERROR_NOT_READY (0x00080000U) /*!< Peripheral not ready */ #define HAL_CAN_ERROR_NOT_STARTED (0x00100000U) /*!< Peripheral not started */ #define HAL_CAN_ERROR_PARAM (0x00200000U) /*!< Parameter error */ In general, bus-related and protocol-related errors ( protocol error warning, error passive, bus-off, stuff error, form error, ACK error, bit dominant, bit recessive, CRC error ) indicate either an electric problem with the wiring, or an underlying issue with the clock precision or frequency. Check Double check with a multimeter that the bus is wired properly and that any jumpers make good contact. Use an oscilloscope to ensure that the signal is clear from interference and edges are sharp. Connect a logic analyzer to better understand the communication issue at binary level. See the Clock Skew section and double-check that the configured frequencies match the oscillators. Firmware-related errors such as overruns or transmit failures may instead indicate an overly congested network or a mistake by the developer when invoking low-level API calls. Check Test your device with less traffic to ensure that the performance of the MCU is suitable for the application. If you are using only two devices, try connecting a third one to better understand where and how the errors generate. Carefully compare your code with the HAL and ST application notes.","title":"List of errors raised by the HAL library"},{"location":"common/shared/can-debugging/#clock-skew","text":"ST's MCUs incorporate an internal low-cost 16MHz crystal (called HSI in the clock tree - High Speed Internal ) which is factory calibrated with a precision up to 1%. However, due to its low accuracy especially with temperature variations of the chip, peripherals can often encounter timing problems, in particular if running at higher frequencies generated by the PLL. Check Set-up an external crystal (HSE) and configure the MCU for the correct frequency. Check at runtime that the HSI is not being used as a fallback after a configuration error with a condition like if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_HSE) .","title":"Clock Skew"},{"location":"common/shared/can-debugging/#hardware-fifos-or-mailboxes-are-not-properly-cleared","text":"For MCUs with transmissions managed via mailboxes, the developer enqueues a new message to send by calling HAL_CAN_AddTxMessage(...) and providing as a last argument the address of a uint32_t variable in which the function will store the ID of the first free mailbox found. Errors may arise in two occasions: either the function is being called so frequently that the bus has no time to send and empty a slot, or no one is listening on the bus and the \"Automatic Retransmission\" option is set, making the MCU hang in a loop where it unsuccessfully tries to send messages over and over again. Conversely, reception queues might as well fill up and cause overruns if they are not read often enough or the network is so congested that the MCU cannot keep up. Warning When a CAN message arrives and its ISR is triggered, remember to call HAL_CAN_GetRxMessage(...) to clear the reception slot, otherwise an overrun will occur after few messages. Check If errors happen when transmitting, make sure you are not sending too frequently and either have free mailboxes available (check with HAL_CAN_GetTxMailboxesFreeLevel(...) ) or a software queue to temporarily store your pending packets. If instead they happen upon reception, test your code with as little incoming traffic as possible and try to understand if your MCU and your software architecture match the intended network performance. Always remember to also properly configure your hardware filters in order to only process what's necessary and not waste resources and CPU cycles.","title":"Hardware FIFOs or Mailboxes are not properly cleared"},{"location":"common/shared/can-debugging/#a-segmentation-fault-or-other-error-crashes-the-mcu","text":"The ST drivers and HAL library are generally very solid, so I advise to thoroughly check your code for memory leaks (if the MCU runs out of memory it simply stops) or possible sources of segmentation faults such as handling of pointers or calls to low-level functions like memcpy and such. Remember that if the firmware crashes you won't see any error message printed over serial, the processor will just freeze and stop. Check Print debug statements over UART or blink on-board LEDs to make sure your code keeps executing or, in fact, stops after a while. Use your IDE built-in debugging tools to interface with OpenOCD and find the exact instruction on which the crash happens.","title":"A segmentation fault or other error crashes the MCU"},{"location":"common/shared/can-debugging/#filters-not-configured-properly","text":"If a message is discarded by a hardware filter you will not receive interrupts of any kind. Warning Disabling filters will cause every message to be discarded, contrary to what you might expect. Check Carefully read the filter configuration section in CAN-bus Configuration and ensure your filters are behaving as you intend.","title":"Filters not configured properly"},{"location":"common/shared/can-debugging/#interrupts-not-configured-properly","text":"For interrupts to be raised by the MCU, they need to be properly configured both from CubeMX and in your code. Check Verify that you followed the correct procedure detailed in the Interrupt section in CAN-bus Configuration .","title":"Interrupts not configured properly"},{"location":"common/shared/openocd-errors/","text":"OpenOCD errors Error connecting DP: cannot read IDR CONDITIONS The following conditions can be observed by using a DAPlink programmer. Enable debug mode level >0 for openOCD, this can be done either via: openocd -d3 ...other_parameters... If using the extension cortex-debug in VSCode, by adding: in file openocd.cfg ------- debug_level 3 If the output of openocd contains: Debug: 229 931 cmsis_dap.c:646 cmsis_dap_swd_read_process(): SWD ack not OK @ 0 JUNK Error: 230 932 adi_v5_swd.c:144 swd_connect(): Error connecting DP: cannot read IDR Debug: 231 932 command.c:628 run_command(): Command 'dap init' failed with error code -4 User : 232 932 command.c:694 command_run_line(): Then the problem is likely to be hardware, i.e. the programmer (DAPlink) is unable to connect/talk to the target via SWD. See this mailling list thread. SOLUTION Check VDD voltages: Do they reach the micro? Are they the correct value? Are there short-circuits to GND ? Check continuity on SWDIO and SWCLK lines Are the micros' pins soldered to the board? Is the micro correctly oriented on the pcb? Check the DAP connection Do the jumper-wires work? Check if debug is enabled on the project present on the flash If not, start flashing the MCU while resetting it, when openocd stops on Info : Listening on port 3333 for gdb connections , release the reset button. Be quick!! Enable debug in CubeMX -> System Core -> SYS -> Debug -> Serial Wire","title":"OpenOCD Troubleshooting"},{"location":"common/shared/openocd-errors/#openocd-errors","text":"","title":"OpenOCD errors"},{"location":"common/shared/openocd-errors/#error-connecting-dp-cannot-read-idr","text":"","title":"Error connecting DP: cannot read IDR"},{"location":"common/shared/openocd-errors/#conditions","text":"The following conditions can be observed by using a DAPlink programmer. Enable debug mode level >0 for openOCD, this can be done either via: openocd -d3 ...other_parameters... If using the extension cortex-debug in VSCode, by adding: in file openocd.cfg ------- debug_level 3 If the output of openocd contains: Debug: 229 931 cmsis_dap.c:646 cmsis_dap_swd_read_process(): SWD ack not OK @ 0 JUNK Error: 230 932 adi_v5_swd.c:144 swd_connect(): Error connecting DP: cannot read IDR Debug: 231 932 command.c:628 run_command(): Command 'dap init' failed with error code -4 User : 232 932 command.c:694 command_run_line(): Then the problem is likely to be hardware, i.e. the programmer (DAPlink) is unable to connect/talk to the target via SWD. See this mailling list thread.","title":"CONDITIONS"},{"location":"common/shared/openocd-errors/#solution","text":"Check VDD voltages: Do they reach the micro? Are they the correct value? Are there short-circuits to GND ? Check continuity on SWDIO and SWCLK lines Are the micros' pins soldered to the board? Is the micro correctly oriented on the pcb? Check the DAP connection Do the jumper-wires work? Check if debug is enabled on the project present on the flash If not, start flashing the MCU while resetting it, when openocd stops on Info : Listening on port 3333 for gdb connections , release the reset button. Be quick!! Enable debug in CubeMX -> System Core -> SYS -> Debug -> Serial Wire","title":"SOLUTION"},{"location":"data-analysis-DMT/Estimation%20Functions/A.Experimental-Tests-and-Data-Estimation/","text":"Experimental Tests and Data Estimation In this paper, the implemented state estimator algorithms are presented. The estimator schemes are divided into two main groups: kinematic states estimators and tire forces observers. Both these groups use the least possible amount of knowledge about vehicle properties. This is important in an analysis that aims to fit the vehicle parameters. The tire forces observers are enough self-explained in terms of their outputs. Actually, they aim to estimate the longitudinal, lateral and vertical tire forces that will be used for the tire characteristics fitting. The kinematic based state observer, instead, aims to estimate the vehicle states on the basis of kinematic relation. The most important one is the lateral velocity estimator that allows determining how much the vehicle is sliding laterally. This observer is widespread for its simplicity. However, it is very sensitive to the noise distribution and to measurement bias that could make the estimation no more valid. More robust methods employ dynamic property to correct the estimation making the algorithm more reliable. Before taking in detail about the estimation algorithms, the test scheduling operation has to be briefly reported, listing the chosen tests for each purpose of our analysis. Also here it is useful to divide the vehicle characteristics into two main categories: longitudinal and lateral. Each of them has its own tests for the properties estimation hence this division helps us in the drafting of the tests list. Let us start with the longitudinal tests. These collect the set of manoeuvre for the estimation of the longitudinal parameters. In practice, the most relevant aspect of these tests is that the vehicle has to travel on a straight trajectory, neglecting the lateral contribute. The manoeuvres that are selected for the following analysis are a set of free-deceleration and a set of acceleration tests, further divided into so-called FullThrottle/Full-Brake (FTFB) and Double Throttle-Step (DTS). The free-deceleration consists of leaving the vehicle stop, starting from a given speed, under the effects of the resistance force only - as, for example, aerodynamic drag and rolling resistance -. The acceleration manoeuvres are performed in a straight acceleration corridor followed by a deceleration one. In the FTFB, the driver has to push completely the throttle until the end of the acceleration corridor. Then, he has to brake strongly. The DTS, instead, is composed of two following step of the throttle, the first under the \\(100 \\%\\) and the second at the maximum. The acceleration corridor is the same and each step span half of the length of the acceleration corridor. Whit respect to the FTFB case, the double step allows us to exploit different tire characteristic region with a lower tire transient. The lateral tests collect a set of turning manoeuvre which aims to highlight the lateral characteristics of the vehicle. These manoeuvres are performed in a steady-state condition, or very close to it, in order to simplify the following analysis. The most common lateral tests are the Ramp Steer and the Steering Pad. In the first case, the driver has to drive at a constant speed progressively increasing the steering angle. In the Steering Pad case, instead, the driver has to drive on a fixed circular trajectory, at constant speed or progressively increasing it. To perform the Ramp Steer properly, a large place is needed. For this reason, only the Steering Pad is used for the following analysis. The dimension of the circular circuit corresponds to the regular Skidpad plant so this test can be also called Half-Skidpad. To evaluate the results of the analysis, a set of tests that combine longitudinal and lateral vehicle behaviour is useful. These tests are called combined and consist of a Track-drive with straight part and turns, at the left and at the right, wide and narrow, to exploit different handling zone of our vehicle. Let us now taking about the estimators into detail, starting with a presentation of the estimation algorithms and then, going in detail talking about the employed observers used in this work. State Estimators The state estimators are necessary when a state of the system is difficult to be directly measured but can be observed using the system theory. The state estimators are directly connected with the sensor fusion world. This allows fusing the information from different sensors in order to have a more correct state measure. The most simple sensor fusion algorithm is the complementary filtering technique. This algorithm starts from the fact that the state can be measured from two different sensors, each of which has a noise in a specific frequency domain - for example, if the sensors are two, one can have noise at low frequency and the other at high frequency -. In this situation, the state can be correctly reconstructed by filtering the outputs of the sensors correctly and summing the filtered data. More in general, the sensor fusion combines more sensors measure, with the relative uncertainty, in order to have a more correct estimation of the state. The observer algorithms, instead, aims to estimate a non-measurable state using the knowledge about the sensors measure. Kalman Filter The Kalman filter is a special case of sensor fusion analysis that fuse the information from the sensors and the knowledge about the system model. It is composed of two steps: Prediction and Updating. In the first step, the states are predicted, using the system model, based on the prior knowledge about the states and the system inputs and eventually the sensor measurements in the case in which the system depends on the measured states -. The updating step corrects the predicted states using the measured quantities. If the system states correspond to the measured states, the Kalman filter is closer to a sensor fusion approach. If instead, the states are more than the measured quantities, the Kalman filter is used as a state estimator. In both cases, the Kalman filter structure is the same. Figure 1: General scheme of a Kalman filter The actual variables are indicated with the time instant subscript \\(k\\) and corresponds to the actual state \\(x_{k}\\) , the actual inputs \\(u_{k}\\) and the actual measure \\(z_{k}\\) . The prediction is performed at the instant \\(k\\) , knowing the estimated states at instant \\(k-1\\) . For this reason, the prediction outputs are indicated with the subscript \\(k \\mid k-1\\) and correspond to the predicted states \\(\\left( {x}_{k \\mid k-1}\\right)\\) and the prediction covariance matrix \\(\\left( {P}_{k \\mid k-1}\\right)\\) . The updating corrects the prediction using the current measure and, for this reason, labels its outputs with the subscript \\(k \\mid k\\left( {x}_{k \\mid k}\\right.\\) and \\(\\left. {P}_{k \\mid k}\\right)\\) . In general, the system model and the measurement system are non-linear functions of time, states, inputs and noise. \\(v_k\\) is the process noise and \\(w\\) is measurement noise. These noises are normally distributed with covariance equal to \\(Q\\) and \\(R\\) respectively \\(v \\sim N(0, Q)\\) and \\(w \\sim N(0, R)-\\) \\[ {x}_{k}=f\\left( {x}_{k-1}, {u}_{k}, {v}_{k}\\right) \\quad ; \\quad z_{k}=h\\left( {x}_{k}, {w}_{k}\\right) \\] In order to proceed with the computation, relation 1 has to be linearized in the following state-space form. \\[ {x}_{k}=F_{k} {x}_{k-1}+B_{k} {u}_{k}+G_{k} {v}_{k} \\quad ; \\quad z_{k}=H_{k} {x}_{k}+D_{k} {w}_{k} \\] where \\[ \\begin{gathered} F_{k}=\\left.\\frac{\\partial f}{\\partial {x}}\\right|_{ {x}_{k-1}, {u}_{k}} \\quad ; \\quad B_{k}=\\left.\\frac{\\partial f}{\\partial {u}}\\right|_{ {x}_{k-1}, {u}_{k}} ; \\quad G_{k}=\\left.\\frac{\\partial f}{\\partial {v}}\\right|_{ {x}_{k-1}, {u}_{k}} \\\\ H_{k}=\\left.\\frac{\\partial h}{\\partial {x}}\\right|_{ {u}_{k}} ; \\quad D_{k}=\\left.\\frac{\\partial h}{\\partial {w}}\\right|_{ {u}_{k}} \\end{gathered} \\] With the system equations written as shown in relation 2, the Kalman estimation algorithms can be defined as follow. \\[ \\begin{gathered} \\text { Prediction: } \\begin{cases} \\hat{x}_{k \\mid k-1}=F_{k} \\hat{x}_{k-1 \\mid k-1}+B_{k}u_{k} \\\\ P_{k \\mid k-1}=F_{K} P_{k-1 \\mid k-1} F_{k}^{T}+G_{k} Q G_{k}^{T} \\end{cases}\\\\ \\text { KalmanMatrix: } \\begin{cases} \\quad K_{k}=P_{k \\mid k-1} H_{k}\\left[H_{k} P_{k \\mid k-1} H_{k}^{T}+R\\right]^{-1} \\end{cases}\\\\ \\text { Updating : } \\begin{cases} \\hat{x}_{k \\mid k} & =\\hat{x}_{k \\mid k-1}+K_{k}\\left[z_{k}-H_{k} \\hat{x}_{k \\mid k-1}\\right] \\\\ P_{k \\mid k} & =\\left[1-K_{k} H_{k}\\right] P_{k \\mid k-1}\\left[1-K_{k} H_{k}\\right]^{T}+K_{k} R K_{k}^{T}\\end{cases} \\end{gathered} \\] To make the notation redundant, the estimated states are indicated with the hat. \\(K_{k}\\) is the so-called Kalman matrix and works as a gain that push the predicted states towards their correct value. The big advantage of the Kalman filter is that it is recursive and it needs only the knowledge about the previous time instant in order to evaluate the following. However, this algorithm, as the other state observer has to be tuned. In this case, the tuning procedure aims to choose the best starting point and the best matrices \\(Q\\) and \\(R\\) to guarantee convergence. While the initialization problem regards mainly the convergence time, the initialization of the process and measure covariance matrices influences the whole performance of the filter. Usually, for what concerns the matrix \\(R\\) , it can be initialized focusing on the uncertainty of the sensors. However, if one of the measured quantity is, for example, the vehicle speed from the wheels, the measure can be affected by sliding effects and it can be useful optimize also the matrix \\(R\\) to have better results. The tuning procedures are related to the filter type and are explained in the related filters sections.","title":"Experimental Tests and Data Estimation"},{"location":"data-analysis-DMT/Estimation%20Functions/A.Experimental-Tests-and-Data-Estimation/#experimental-tests-and-data-estimation","text":"In this paper, the implemented state estimator algorithms are presented. The estimator schemes are divided into two main groups: kinematic states estimators and tire forces observers. Both these groups use the least possible amount of knowledge about vehicle properties. This is important in an analysis that aims to fit the vehicle parameters. The tire forces observers are enough self-explained in terms of their outputs. Actually, they aim to estimate the longitudinal, lateral and vertical tire forces that will be used for the tire characteristics fitting. The kinematic based state observer, instead, aims to estimate the vehicle states on the basis of kinematic relation. The most important one is the lateral velocity estimator that allows determining how much the vehicle is sliding laterally. This observer is widespread for its simplicity. However, it is very sensitive to the noise distribution and to measurement bias that could make the estimation no more valid. More robust methods employ dynamic property to correct the estimation making the algorithm more reliable. Before taking in detail about the estimation algorithms, the test scheduling operation has to be briefly reported, listing the chosen tests for each purpose of our analysis. Also here it is useful to divide the vehicle characteristics into two main categories: longitudinal and lateral. Each of them has its own tests for the properties estimation hence this division helps us in the drafting of the tests list. Let us start with the longitudinal tests. These collect the set of manoeuvre for the estimation of the longitudinal parameters. In practice, the most relevant aspect of these tests is that the vehicle has to travel on a straight trajectory, neglecting the lateral contribute. The manoeuvres that are selected for the following analysis are a set of free-deceleration and a set of acceleration tests, further divided into so-called FullThrottle/Full-Brake (FTFB) and Double Throttle-Step (DTS). The free-deceleration consists of leaving the vehicle stop, starting from a given speed, under the effects of the resistance force only - as, for example, aerodynamic drag and rolling resistance -. The acceleration manoeuvres are performed in a straight acceleration corridor followed by a deceleration one. In the FTFB, the driver has to push completely the throttle until the end of the acceleration corridor. Then, he has to brake strongly. The DTS, instead, is composed of two following step of the throttle, the first under the \\(100 \\%\\) and the second at the maximum. The acceleration corridor is the same and each step span half of the length of the acceleration corridor. Whit respect to the FTFB case, the double step allows us to exploit different tire characteristic region with a lower tire transient. The lateral tests collect a set of turning manoeuvre which aims to highlight the lateral characteristics of the vehicle. These manoeuvres are performed in a steady-state condition, or very close to it, in order to simplify the following analysis. The most common lateral tests are the Ramp Steer and the Steering Pad. In the first case, the driver has to drive at a constant speed progressively increasing the steering angle. In the Steering Pad case, instead, the driver has to drive on a fixed circular trajectory, at constant speed or progressively increasing it. To perform the Ramp Steer properly, a large place is needed. For this reason, only the Steering Pad is used for the following analysis. The dimension of the circular circuit corresponds to the regular Skidpad plant so this test can be also called Half-Skidpad. To evaluate the results of the analysis, a set of tests that combine longitudinal and lateral vehicle behaviour is useful. These tests are called combined and consist of a Track-drive with straight part and turns, at the left and at the right, wide and narrow, to exploit different handling zone of our vehicle. Let us now taking about the estimators into detail, starting with a presentation of the estimation algorithms and then, going in detail talking about the employed observers used in this work.","title":"Experimental Tests and Data Estimation"},{"location":"data-analysis-DMT/Estimation%20Functions/A.Experimental-Tests-and-Data-Estimation/#state-estimators","text":"The state estimators are necessary when a state of the system is difficult to be directly measured but can be observed using the system theory. The state estimators are directly connected with the sensor fusion world. This allows fusing the information from different sensors in order to have a more correct state measure. The most simple sensor fusion algorithm is the complementary filtering technique. This algorithm starts from the fact that the state can be measured from two different sensors, each of which has a noise in a specific frequency domain - for example, if the sensors are two, one can have noise at low frequency and the other at high frequency -. In this situation, the state can be correctly reconstructed by filtering the outputs of the sensors correctly and summing the filtered data. More in general, the sensor fusion combines more sensors measure, with the relative uncertainty, in order to have a more correct estimation of the state. The observer algorithms, instead, aims to estimate a non-measurable state using the knowledge about the sensors measure.","title":"State Estimators"},{"location":"data-analysis-DMT/Estimation%20Functions/A.Experimental-Tests-and-Data-Estimation/#kalman-filter","text":"The Kalman filter is a special case of sensor fusion analysis that fuse the information from the sensors and the knowledge about the system model. It is composed of two steps: Prediction and Updating. In the first step, the states are predicted, using the system model, based on the prior knowledge about the states and the system inputs and eventually the sensor measurements in the case in which the system depends on the measured states -. The updating step corrects the predicted states using the measured quantities. If the system states correspond to the measured states, the Kalman filter is closer to a sensor fusion approach. If instead, the states are more than the measured quantities, the Kalman filter is used as a state estimator. In both cases, the Kalman filter structure is the same. Figure 1: General scheme of a Kalman filter The actual variables are indicated with the time instant subscript \\(k\\) and corresponds to the actual state \\(x_{k}\\) , the actual inputs \\(u_{k}\\) and the actual measure \\(z_{k}\\) . The prediction is performed at the instant \\(k\\) , knowing the estimated states at instant \\(k-1\\) . For this reason, the prediction outputs are indicated with the subscript \\(k \\mid k-1\\) and correspond to the predicted states \\(\\left( {x}_{k \\mid k-1}\\right)\\) and the prediction covariance matrix \\(\\left( {P}_{k \\mid k-1}\\right)\\) . The updating corrects the prediction using the current measure and, for this reason, labels its outputs with the subscript \\(k \\mid k\\left( {x}_{k \\mid k}\\right.\\) and \\(\\left. {P}_{k \\mid k}\\right)\\) . In general, the system model and the measurement system are non-linear functions of time, states, inputs and noise. \\(v_k\\) is the process noise and \\(w\\) is measurement noise. These noises are normally distributed with covariance equal to \\(Q\\) and \\(R\\) respectively \\(v \\sim N(0, Q)\\) and \\(w \\sim N(0, R)-\\) \\[ {x}_{k}=f\\left( {x}_{k-1}, {u}_{k}, {v}_{k}\\right) \\quad ; \\quad z_{k}=h\\left( {x}_{k}, {w}_{k}\\right) \\] In order to proceed with the computation, relation 1 has to be linearized in the following state-space form. \\[ {x}_{k}=F_{k} {x}_{k-1}+B_{k} {u}_{k}+G_{k} {v}_{k} \\quad ; \\quad z_{k}=H_{k} {x}_{k}+D_{k} {w}_{k} \\] where \\[ \\begin{gathered} F_{k}=\\left.\\frac{\\partial f}{\\partial {x}}\\right|_{ {x}_{k-1}, {u}_{k}} \\quad ; \\quad B_{k}=\\left.\\frac{\\partial f}{\\partial {u}}\\right|_{ {x}_{k-1}, {u}_{k}} ; \\quad G_{k}=\\left.\\frac{\\partial f}{\\partial {v}}\\right|_{ {x}_{k-1}, {u}_{k}} \\\\ H_{k}=\\left.\\frac{\\partial h}{\\partial {x}}\\right|_{ {u}_{k}} ; \\quad D_{k}=\\left.\\frac{\\partial h}{\\partial {w}}\\right|_{ {u}_{k}} \\end{gathered} \\] With the system equations written as shown in relation 2, the Kalman estimation algorithms can be defined as follow. \\[ \\begin{gathered} \\text { Prediction: } \\begin{cases} \\hat{x}_{k \\mid k-1}=F_{k} \\hat{x}_{k-1 \\mid k-1}+B_{k}u_{k} \\\\ P_{k \\mid k-1}=F_{K} P_{k-1 \\mid k-1} F_{k}^{T}+G_{k} Q G_{k}^{T} \\end{cases}\\\\ \\text { KalmanMatrix: } \\begin{cases} \\quad K_{k}=P_{k \\mid k-1} H_{k}\\left[H_{k} P_{k \\mid k-1} H_{k}^{T}+R\\right]^{-1} \\end{cases}\\\\ \\text { Updating : } \\begin{cases} \\hat{x}_{k \\mid k} & =\\hat{x}_{k \\mid k-1}+K_{k}\\left[z_{k}-H_{k} \\hat{x}_{k \\mid k-1}\\right] \\\\ P_{k \\mid k} & =\\left[1-K_{k} H_{k}\\right] P_{k \\mid k-1}\\left[1-K_{k} H_{k}\\right]^{T}+K_{k} R K_{k}^{T}\\end{cases} \\end{gathered} \\] To make the notation redundant, the estimated states are indicated with the hat. \\(K_{k}\\) is the so-called Kalman matrix and works as a gain that push the predicted states towards their correct value. The big advantage of the Kalman filter is that it is recursive and it needs only the knowledge about the previous time instant in order to evaluate the following. However, this algorithm, as the other state observer has to be tuned. In this case, the tuning procedure aims to choose the best starting point and the best matrices \\(Q\\) and \\(R\\) to guarantee convergence. While the initialization problem regards mainly the convergence time, the initialization of the process and measure covariance matrices influences the whole performance of the filter. Usually, for what concerns the matrix \\(R\\) , it can be initialized focusing on the uncertainty of the sensors. However, if one of the measured quantity is, for example, the vehicle speed from the wheels, the measure can be affected by sliding effects and it can be useful optimize also the matrix \\(R\\) to have better results. The tuning procedures are related to the filter type and are explained in the related filters sections.","title":"Kalman Filter"},{"location":"data-analysis-DMT/Estimation%20Functions/B.Longitudinal-Velocity-Estimators/","text":"Longitudinal Velocity Estimators Let us now start talking about the kinematic states observers. The first algorithms that we would like to present are employed for the longitudinal velocity estimation. The most common way to measure the vehicle longitudinal speed is to focus on the wheel speed. However, the wheels can slide on the road surface and, for this reason, invalidate the measure. Here, three possible methods for the longitudinal velocity estimation are presented. Front-Wheels Velocity Estimation The most common approach to estimate the longitudinal velocity is to focus on the un-driven wheels: since the considered vehicle is rear-wheel-driven, the front wheels speed can be used to estimate the longitudinal velocity. This because, at least in the acceleration case, the front wheels are not subjected to any torque, hence, they do not slide. Nevertheless, in braking, the torque is applied to all wheels and the no-slip assumption is no longer valid. However, remaining in the acceleration region, the usage of the front wheels to estimate the longitudinal velocity can be a good compromise between simplicity and accuracy. Since the vehicle is front-wheel steering, to increase the estimation accuracy, the velocity of the wheels has to be corrected using the steering angle. The estimation formula is reported in expression 6 . \\[ u_{F W}=\\frac{\\omega_{F R} \\cos \\left(\\delta_{F R}\\right)+\\omega_{F L} \\cos \\left(\\delta_{F L}\\right)}{2} R \\] State-Machine Estimation Another simple method for the longitudinal velocity estimation uses a state-machine combining the most accurate data depending on the driving situation. It is dived in four states depending on the vehicle condition: very low speed \\((s=-2)\\) , acceleration \\((s=-1)\\) , constant speed \\((s=0)\\) and braking \\((s=1)\\) . If the vehicle is moving under a certain velocity - very low-speed case -, all the four wheels speed are used for the velocity estimation. \\[ \\text { if } s=-2 \\quad u_{S M}=\\bar{u}=\\frac{1}{4} \\sum_{i} \\omega_{i} R \\cos \\left(\\delta_{i}\\right) \\quad i=\\{F R, F L, R R, R L\\} \\] In the acceleration case, as it is explained before, only the front wheels can be used for the velocity estimation. In this case, the state machine velocity corresponds with the velocity of the front wheels reported in expression 6 \\[ \\text { if } s=-1 \\quad u_{S M}=u_{F W} \\] If the vehicle is proceeding at a constant speed, the torque applied to the wheels is almost equal to zero. For this reason, the four wheels speed can be used again for the velocity estimation. \\[ \\text { if } s=0 \\quad u_{S M}=\\bar{u} \\] In braking condition, the braking torque is applied to all the wheels. For this reason, any information from the wheel speed can be considered. In this case, the most effective way to estimate the longitudinal velocity is by integrating a filtered version of the longitudinal acceleration \\(\\left(a_{x, \\text { Filt }}\\right)\\) . The main problem of this approach is the acceleration bias that can make the estimation diverges for a long integration time. However, in our case, the braking time is not so long and this approach can return a good velocity estimation. \\[ \\text { if } s=1 \\quad u_{S M}=u_{A}=\\int a_{x, \\text { Filt }} d t \\] The state switching logic is reported in table 1, Each intersection between previous states and new states describes the conditions for switching. The value of \\(u_{\\min }\\) is the velocity threshold under which the vehicle is in the low-speed condition. \\(h_{u}\\) is a small value introduced to avoid chattering between state \\(-2\\) and the others. \\(\\delta\\) is a small acceleration value that identifies the upper limit for the constant speed condition. Above the value of \\(\\delta\\) , the vehicle is in acceleration state. \\(\\beta\\) has the same function of \\(\\delta\\) but in braking case. However, this value can be higher than its' analogue to include also the deceleration due to the aerodynamic drag. \\(h_{a}\\) has the same function of \\(h_{u}\\) but in the acceleration domain. Table 1: Conditions for switching logic The state-machine estimation is a simple way to combine longitudinal acceleration from the IMU sensor and the wheels spin. Nevertheless, the estimator output can jump in the state switching. In order to smooth the jumps, the state machine output can be filtered. Sensor Fusion Estimation A more sophisticated strategy for the IMU/wheels spin combination is presented by Panzani et al. [15]. In this work, it is demonstrated that a sensor fusion by means Kalman filter can be written using a second-order complementary filtering technique. In this way, quantitative guidelines for the estimator tuning are given. The basic idea is the introduction of an offset dynamics in the evolution of the longitudinal velocity to account for some unmodelled effects. The usage of this offset can be seen in the system process and measurement equations (relation 11). \\[ \\begin{cases}\\dot{u}=o+a_{x}+\\eta_{1} & u_{F W}=u+\\epsilon_{1} \\\\ \\dot{o}=\\eta_{2} & \\end{cases} \\] where \\(u\\) and \\(o\\) are the system states and corresponds to the estimated velocity and the offset dynamics respectively. \\(u_{F W}\\) is the front wheels estimation of the longitudinal velocity, defined in the expression 6 and \\(\\epsilon_{1}\\) is the noise associated with this measure with variance equal to \\(r\\left(\\epsilon_{1} \\backsim N(0, r)\\right)\\) . \\(\\eta_{1}\\) and \\(\\eta_{2}\\) are the noises associated with the process. They are white and normally distributed, with variance equal to \\(q_{1}\\) and \\(q_{2}\\) respectively \\(\\left(\\eta_{1} \\backsim N\\left(0, q_{1}\\right)\\right.\\) and \\(\\left.\\eta_{2} \\backsim N\\left(0, q_{2}\\right)\\right)\\) . The evolution in time of the estimated states is reported in equation 12. The demonstration is not reported here, however, it resembles the Kalman filter procedure, explained in the previous sections. \\[ \\dot{\\hat{x}}_{k \\mid k}=\\left(F_{k}-K_{k} H_{k}\\right) \\hat{x}_{k-1 \\mid k-1}+B_{k} {u}_{k}+K_{k} z_{k} \\] where \\(\\hat{ {x}}=[\\hat{u}, \\hat{o}]^{T}\\) is the estimated state vector, \\(u = a_x\\) is the process input vector and \\(z=u_{F W}\\) is the vector of the measure. \\(A, B\\) and \\(C\\) are the state-space matrices while \\(K\\) is the Kalman matrix. \\[ A=\\left[\\begin{array}{cc} 0 & -1 \\\\ 0 & 0 \\end{array}\\right] \\quad B=\\left[\\begin{array}{l} 1 \\\\ 0 \\end{array}\\right] \\quad H=\\left[\\begin{array}{ll} 1 & 0 \\end{array}\\right] \\quad K=\\frac{1}{r}\\left[\\begin{array}{l} \\alpha \\\\ \\beta \\end{array}\\right] \\] The parameters \\(\\alpha\\) and \\(\\beta\\) can be computed from the relation 13 . \\[ \\left\\{\\begin{array}{l} \\alpha=\\sqrt{q_{1} r+2 r \\sqrt{r q_{2}}} \\\\ \\beta=-\\sqrt{r q 2} \\end{array}\\right. \\] The advantage of a Kalman filter defined as in [15] is that some tuning guidelines are intrinsically given in the design structure. Looking at the second-order complementary filter formulation, it is possible to demonstrate that the natural frequency \\(\\left(\\omega_{n}\\right)\\) and the damping factor \\((\\xi)\\) of the optimal filters depends on the process and the measurement noise. \\[ \\omega_{n}=\\sqrt{-\\frac{\\beta}{r}} \\quad \\xi=\\frac{\\frac{\\alpha}{r}}{2 \\omega_{n}} \\] Setting the desired natural frequency and damping factor, it is possible to compute the process noises \\(q_{1}\\) and \\(q_{2}\\) as a function of the measurement variance \\(r\\) . \\(\\omega_{n}(\\mathrm{~Hz})\\) \\(\\xi\\) \\(r\\) \\(q_{1}\\) \\(q_{2}\\) 2 1 0.01 3.16 249.37 Table 2: Longitudinal velocity estimator - tuning results Algorithms Performance In figure 2 the results of the longitudinal velocity estimation are reported for a simulated double throttle step manoeuvre. The yellow line corresponds to the simulated longitudinal velocity that is the actual reference for the estimator outputs. It is possible to see that, since the data are filtered, the estimation does not properly work in the region in which the speed profile is sharp. However, mainly in the acceleration zone, the longitudinal velocity estimation of all algorithms are good. This because, in this region, the front wheels longitudinal velocity is a good approximation of the real velocity. The sensor fusion estimation takes as inputs the raw (unfiltered) data and the filtering procedure is done by the intrinsic structure of the estimator. Figure 2: Longitudinal velocity estimation Proceeding with the analysis, from turning tests, it is possible to notice that for a narrow corner, close to the handling limit, the state machine estimation tends to diverge giving a bad approximation of the longitudinal velocity. The sensor fusion and the front wheel velocity, instead, gives a less accurate estimation with respect to the normal driving case, but the output value of these algorithms stays close to the real one. In conclusion, when real data are used, it can be noticed that the sensor fusion velocity gives better results in different conditions. The discriminant factor is the performance in the longitudinal slip computation - described in a dedicated section - where the sensor fusion speed gives the best performances.","title":"Longitudinal Velocity Estimators"},{"location":"data-analysis-DMT/Estimation%20Functions/B.Longitudinal-Velocity-Estimators/#longitudinal-velocity-estimators","text":"Let us now start talking about the kinematic states observers. The first algorithms that we would like to present are employed for the longitudinal velocity estimation. The most common way to measure the vehicle longitudinal speed is to focus on the wheel speed. However, the wheels can slide on the road surface and, for this reason, invalidate the measure. Here, three possible methods for the longitudinal velocity estimation are presented.","title":"Longitudinal Velocity Estimators"},{"location":"data-analysis-DMT/Estimation%20Functions/B.Longitudinal-Velocity-Estimators/#front-wheels-velocity-estimation","text":"The most common approach to estimate the longitudinal velocity is to focus on the un-driven wheels: since the considered vehicle is rear-wheel-driven, the front wheels speed can be used to estimate the longitudinal velocity. This because, at least in the acceleration case, the front wheels are not subjected to any torque, hence, they do not slide. Nevertheless, in braking, the torque is applied to all wheels and the no-slip assumption is no longer valid. However, remaining in the acceleration region, the usage of the front wheels to estimate the longitudinal velocity can be a good compromise between simplicity and accuracy. Since the vehicle is front-wheel steering, to increase the estimation accuracy, the velocity of the wheels has to be corrected using the steering angle. The estimation formula is reported in expression 6 . \\[ u_{F W}=\\frac{\\omega_{F R} \\cos \\left(\\delta_{F R}\\right)+\\omega_{F L} \\cos \\left(\\delta_{F L}\\right)}{2} R \\]","title":"Front-Wheels Velocity Estimation"},{"location":"data-analysis-DMT/Estimation%20Functions/B.Longitudinal-Velocity-Estimators/#state-machine-estimation","text":"Another simple method for the longitudinal velocity estimation uses a state-machine combining the most accurate data depending on the driving situation. It is dived in four states depending on the vehicle condition: very low speed \\((s=-2)\\) , acceleration \\((s=-1)\\) , constant speed \\((s=0)\\) and braking \\((s=1)\\) . If the vehicle is moving under a certain velocity - very low-speed case -, all the four wheels speed are used for the velocity estimation. \\[ \\text { if } s=-2 \\quad u_{S M}=\\bar{u}=\\frac{1}{4} \\sum_{i} \\omega_{i} R \\cos \\left(\\delta_{i}\\right) \\quad i=\\{F R, F L, R R, R L\\} \\] In the acceleration case, as it is explained before, only the front wheels can be used for the velocity estimation. In this case, the state machine velocity corresponds with the velocity of the front wheels reported in expression 6 \\[ \\text { if } s=-1 \\quad u_{S M}=u_{F W} \\] If the vehicle is proceeding at a constant speed, the torque applied to the wheels is almost equal to zero. For this reason, the four wheels speed can be used again for the velocity estimation. \\[ \\text { if } s=0 \\quad u_{S M}=\\bar{u} \\] In braking condition, the braking torque is applied to all the wheels. For this reason, any information from the wheel speed can be considered. In this case, the most effective way to estimate the longitudinal velocity is by integrating a filtered version of the longitudinal acceleration \\(\\left(a_{x, \\text { Filt }}\\right)\\) . The main problem of this approach is the acceleration bias that can make the estimation diverges for a long integration time. However, in our case, the braking time is not so long and this approach can return a good velocity estimation. \\[ \\text { if } s=1 \\quad u_{S M}=u_{A}=\\int a_{x, \\text { Filt }} d t \\] The state switching logic is reported in table 1, Each intersection between previous states and new states describes the conditions for switching. The value of \\(u_{\\min }\\) is the velocity threshold under which the vehicle is in the low-speed condition. \\(h_{u}\\) is a small value introduced to avoid chattering between state \\(-2\\) and the others. \\(\\delta\\) is a small acceleration value that identifies the upper limit for the constant speed condition. Above the value of \\(\\delta\\) , the vehicle is in acceleration state. \\(\\beta\\) has the same function of \\(\\delta\\) but in braking case. However, this value can be higher than its' analogue to include also the deceleration due to the aerodynamic drag. \\(h_{a}\\) has the same function of \\(h_{u}\\) but in the acceleration domain. Table 1: Conditions for switching logic The state-machine estimation is a simple way to combine longitudinal acceleration from the IMU sensor and the wheels spin. Nevertheless, the estimator output can jump in the state switching. In order to smooth the jumps, the state machine output can be filtered.","title":"State-Machine Estimation"},{"location":"data-analysis-DMT/Estimation%20Functions/B.Longitudinal-Velocity-Estimators/#sensor-fusion-estimation","text":"A more sophisticated strategy for the IMU/wheels spin combination is presented by Panzani et al. [15]. In this work, it is demonstrated that a sensor fusion by means Kalman filter can be written using a second-order complementary filtering technique. In this way, quantitative guidelines for the estimator tuning are given. The basic idea is the introduction of an offset dynamics in the evolution of the longitudinal velocity to account for some unmodelled effects. The usage of this offset can be seen in the system process and measurement equations (relation 11). \\[ \\begin{cases}\\dot{u}=o+a_{x}+\\eta_{1} & u_{F W}=u+\\epsilon_{1} \\\\ \\dot{o}=\\eta_{2} & \\end{cases} \\] where \\(u\\) and \\(o\\) are the system states and corresponds to the estimated velocity and the offset dynamics respectively. \\(u_{F W}\\) is the front wheels estimation of the longitudinal velocity, defined in the expression 6 and \\(\\epsilon_{1}\\) is the noise associated with this measure with variance equal to \\(r\\left(\\epsilon_{1} \\backsim N(0, r)\\right)\\) . \\(\\eta_{1}\\) and \\(\\eta_{2}\\) are the noises associated with the process. They are white and normally distributed, with variance equal to \\(q_{1}\\) and \\(q_{2}\\) respectively \\(\\left(\\eta_{1} \\backsim N\\left(0, q_{1}\\right)\\right.\\) and \\(\\left.\\eta_{2} \\backsim N\\left(0, q_{2}\\right)\\right)\\) . The evolution in time of the estimated states is reported in equation 12. The demonstration is not reported here, however, it resembles the Kalman filter procedure, explained in the previous sections. \\[ \\dot{\\hat{x}}_{k \\mid k}=\\left(F_{k}-K_{k} H_{k}\\right) \\hat{x}_{k-1 \\mid k-1}+B_{k} {u}_{k}+K_{k} z_{k} \\] where \\(\\hat{ {x}}=[\\hat{u}, \\hat{o}]^{T}\\) is the estimated state vector, \\(u = a_x\\) is the process input vector and \\(z=u_{F W}\\) is the vector of the measure. \\(A, B\\) and \\(C\\) are the state-space matrices while \\(K\\) is the Kalman matrix. \\[ A=\\left[\\begin{array}{cc} 0 & -1 \\\\ 0 & 0 \\end{array}\\right] \\quad B=\\left[\\begin{array}{l} 1 \\\\ 0 \\end{array}\\right] \\quad H=\\left[\\begin{array}{ll} 1 & 0 \\end{array}\\right] \\quad K=\\frac{1}{r}\\left[\\begin{array}{l} \\alpha \\\\ \\beta \\end{array}\\right] \\] The parameters \\(\\alpha\\) and \\(\\beta\\) can be computed from the relation 13 . \\[ \\left\\{\\begin{array}{l} \\alpha=\\sqrt{q_{1} r+2 r \\sqrt{r q_{2}}} \\\\ \\beta=-\\sqrt{r q 2} \\end{array}\\right. \\] The advantage of a Kalman filter defined as in [15] is that some tuning guidelines are intrinsically given in the design structure. Looking at the second-order complementary filter formulation, it is possible to demonstrate that the natural frequency \\(\\left(\\omega_{n}\\right)\\) and the damping factor \\((\\xi)\\) of the optimal filters depends on the process and the measurement noise. \\[ \\omega_{n}=\\sqrt{-\\frac{\\beta}{r}} \\quad \\xi=\\frac{\\frac{\\alpha}{r}}{2 \\omega_{n}} \\] Setting the desired natural frequency and damping factor, it is possible to compute the process noises \\(q_{1}\\) and \\(q_{2}\\) as a function of the measurement variance \\(r\\) . \\(\\omega_{n}(\\mathrm{~Hz})\\) \\(\\xi\\) \\(r\\) \\(q_{1}\\) \\(q_{2}\\) 2 1 0.01 3.16 249.37 Table 2: Longitudinal velocity estimator - tuning results","title":"Sensor Fusion Estimation"},{"location":"data-analysis-DMT/Estimation%20Functions/B.Longitudinal-Velocity-Estimators/#algorithms-performance","text":"In figure 2 the results of the longitudinal velocity estimation are reported for a simulated double throttle step manoeuvre. The yellow line corresponds to the simulated longitudinal velocity that is the actual reference for the estimator outputs. It is possible to see that, since the data are filtered, the estimation does not properly work in the region in which the speed profile is sharp. However, mainly in the acceleration zone, the longitudinal velocity estimation of all algorithms are good. This because, in this region, the front wheels longitudinal velocity is a good approximation of the real velocity. The sensor fusion estimation takes as inputs the raw (unfiltered) data and the filtering procedure is done by the intrinsic structure of the estimator. Figure 2: Longitudinal velocity estimation Proceeding with the analysis, from turning tests, it is possible to notice that for a narrow corner, close to the handling limit, the state machine estimation tends to diverge giving a bad approximation of the longitudinal velocity. The sensor fusion and the front wheel velocity, instead, gives a less accurate estimation with respect to the normal driving case, but the output value of these algorithms stays close to the real one. In conclusion, when real data are used, it can be noticed that the sensor fusion velocity gives better results in different conditions. The discriminant factor is the performance in the longitudinal slip computation - described in a dedicated section - where the sensor fusion speed gives the best performances.","title":"Algorithms Performance"},{"location":"data-analysis-DMT/Estimation%20Functions/C.Lateral-Velocity-Estimator/","text":"Lateral Velocity Estimator Lateral Velocity Luemberger Observer One of the most common problem in the vehicle state estimation is the estimation of the lateral velocity \\((v)\\) , or the body-side slip angle \\((\\beta)\\) . A simple method to solve this problem is the kinematic-based Luemberger observer, presented also in [7]. This observer is based on the following system of equations. \\[ \\left\\{\\begin{array}{l} \\dot{u}=v \\Omega+a_{x} \\\\ \\dot{v}=-u \\Omega+a_{y} \\end{array}\\right. \\] In order to implement the observer, the system has to be written in state-space form. \\[ \\begin{gathered} \\dot{ {x}}=\\left[\\begin{array}{l} \\dot{u} \\\\ \\dot{v} \\end{array}\\right]=\\left[\\begin{array}{cc} 0 & \\Omega \\\\ -\\Omega & 0 \\end{array}\\right]\\left[\\begin{array}{l} u \\\\ v \\end{array}\\right]+\\left[\\begin{array}{ll} 1 & 0 \\\\ 0 & 1 \\end{array}\\right]\\left[\\begin{array}{l} a_{x} \\\\ a_{y} \\end{array}\\right]=F {x}+B {c} \\\\ z=[u]=\\left[\\begin{array}{ll} 1 & 0 \\end{array}\\right]\\left[\\begin{array}{l} u \\\\ v \\end{array}\\right]=H {x} \\end{gathered} \\] Equation 16 correspond to the system evolution equation while equation 17 is the output equation, namely, the computation of the measurable quantities. Since the lateral velocity is not in the output vector, it can not be measured. The observer uses the state evolution equation in order to estimate the states and corrects the estimation using the estimation error on the measurable output \\((z-\\hat{z})\\) . \\[ \\begin{aligned} \\dot{\\hat{x}} & =F \\hat{x}+B {c}+L( {z}-\\hat{ {z}}) \\\\ & =(F-L H) \\hat{x}+B {c}+L {z} \\end{aligned} \\] Where \\(\\hat{ {x}}\\) and \\(\\hat{ {z}}\\) are the estimated state and output vector respectively and \\(L\\) is the so-called Luemberger's matrix. From equation 18, the estimation error \\(( {e}= {x}-\\hat{ {x}})\\) dynamical equation can be extrapolated. \\[ \\dot{e}=(F-L H) {e}=G {e} \\] Looking at equation 19, the error is asymptotically stable if and only if the matrix \\((F-L H)\\) is Hurwitz, i.e. its eigenvalues has a negative real part. In order to impose this condition, the Luemberger's matrix has to be properly tuned. A possible choice for the matrix \\(L\\) is reported in relation 20. This matrix ensures that the eigenvalues of the matrix \\(G\\) are \\(e_{v-1,2}=-\\gamma|\\Omega|\\) , providing error stability. The parameter \\(\\gamma\\) is a tunable parameter and is connected to the convergence rate. \\[ L=\\left[\\begin{array}{c} 2 \\gamma|\\Omega| \\\\ \\left(\\gamma^{2}-1\\right) \\Omega \\end{array}\\right] \\] An observability check is useful to evaluate the performance of this algorithm. It consists in the computation of the rank of the Observability matrix \\((O)\\) . If \\(\\operatorname{Rank}(O)=\\) \\(n\\) , where \\(n\\) is the state dimension - in this case 2 -, the system is observable. \\[ O=\\left[\\begin{array}{c} H \\\\ F H \\end{array}\\right]=\\left[\\begin{array}{cc} 1 & 0 \\\\ 0 & -\\Omega \\end{array}\\right] \\] From equation 21, it is possible to see that the matrix \\(O\\) has rank equal to 2 if the yawrate is different from 0 . This means that the system is not observable if the trajectory is straight. This may be deduced also from the eigenvalues of the matrix \\(G\\) , that goes to zero making the system simply stable when \\(\\Omega\\) tends to zero. However, this problem can be easily solved by resetting the observer when the yaw-rate is close to zero - as explained in the results of [7] -. This observer does not require any prior knowledge about the vehicle and is computationally simple. These characteristics allow the spreading of this algorithm. Luemberger Observer Tuning As we already said, the performance of the Luemberger observer is given by the tunable parameter \\(\\gamma\\) . Theoretically, it should be higher as possible in order to guarantee convergence. However, increasing it too much can generate chattering in the estimation. On the contrary, if the value of \\(\\gamma\\) is low, the estimation tends to diverge under the effects of dynamical bias that are difficult to be compensated. In an offline analysis, a simple solution to this problem is to increase the observer gain to ensure a correct estimation and strongly filter the observer output. For this application, a moving average filter is applied further and backwards in time to compensate for the filtering delay. Using this trick, the parameter \\(\\gamma\\) can be set equal to 100 . Real-time estimation of the lateral velocity needs a more sophisticated observer tuning, a different filtering technique - for example, similarly to the one applied to the SOSM observer presented in the following section - or a more robust estimation scheme, involving vehicle dynamical properties. KF Lateral Velocity Estimators - Planar Estimator Alternatively to the Luemberger observer, there are other methods for the lateral velocity estimation. In this thesis, two different Kalman filters are shown, with two different levels of complexity. The first presented Kalman filter is based on the same system model described in equations of Luemberger observer and reported also below. However, the definition of the system and measurement errors ( \\(v\\) and \\(w\\) respectively) is needed. The integration scheme is included in the system matrices. The vector z contains the measured quatities from the sensor, instead the vector x the states. N.B. \\(\\dot{u}\\) and \\(\\dot{v}\\) are different form \\(a_{x}\\) and \\(a_{y}\\) (measured from the IMU), because the time partial derivate of the velocity in states ( \\(\\dot{u}\\) and \\(\\dot{v}\\) ) measure only the absolute value variation of u and v! \\[ \\left\\{\\begin{array}{l} {x}_{k}=F_{k} {x}_{k-1}+B_{k} {c}_{k}+ {v}_{k} \\\\ {z}_{k}=H_{k} {x}_{k-1}+ {w}_{k} \\end{array}\\right. \\] where \\[ F_{k} {x}_{k-1}+B_{k} {c}_{k} = \\left\\{\\begin{array}{l} u_{k} = u_{k-1} + Ts*a_{x} \\\\ \\dot{u}=v \\Omega+a_{x} \\\\ v_{k} = v_{k-1} + Ts*a_{y} \\\\ \\dot{v}=-u \\Omega+a_{y} \\end{array}\\right. \\] \\[ H_{k} {x}_{k-1} = \\left\\{\\begin{array}{l} u_{k_{SF}} = u_{k-1}\\\\ a_{x_{IMU}} = \\dot{u} - v \\Omega \\\\ a_{y_{IMU}} = \\dot{v} + u \\Omega \\end{array}\\right. \\] so the matrices become: \\[ \\begin{aligned} & \\hspace{5em} {x}_{k}=\\left[\\begin{array}{c}u_{k} \\\\\\dot{u}_{k} \\\\v_{k} \\\\\\dot{v}_{k}\\end{array}\\right] \\hspace{10em} z_{k}=\\left[\\begin{array}{c}u_{k} \\\\a_{x, k} \\\\a_{y, k}\\end{array}\\right] \\\\ & F_{k}=\\left[\\begin{array}{cccc}1 & T_{s} & 0 & 0 \\\\0 & 0 & \\Omega_{k} & 0 \\\\0 & 0 & 1 & T_{s} \\\\-\\Omega_{k} & 0 & 0 & 0\\end{array}\\right] \\quad B_{k}=\\left[\\begin{array}{ll}0 & 0 \\\\1 & 0 \\\\0 & 0 \\\\0 & 1\\end{array}\\right] \\quad H_{k}=\\left[\\begin{array}{cccc}1 & 0 & 0 & 0 \\\\0 & 1 & -\\Omega_{k} & 0 \\\\\\Omega_{k} & 0 & 0 & 1\\end{array}\\right] \\end{aligned} \\] Differently from the Luemberger case, this algorithm uses also the information on the measured acceleration in order to correct the estimation. The estimated accelerations are computed in the updating step inverting the process equations. Hence, the same values of accelerations are used as inputs, in the prediction steps, and as measured quantities in the updating step. The algorithm iteration scheme is shown in equations 3, 4 and 5. To increase the estimation accuracy, the estimator output is reset when the yaw-rate is close to zero. KF Lateral Velocity Estimators - 3D Estimator The second state estimator Kalman filter that is presented in this thesis is based on the work of Alatorre et al. [4]. This estimator is based on a larger system of equations that include also the third dimension. This allows us to take advantage of the gravity term in order to correct some acceleration bias and to estimate the roll and the pitch angle. The system of equations is reported in relation 23. The vector z contains the measured quatities from the sensor, instead the vector x the states. N.B. \\(\\dot{u}\\) , \\(\\dot{v}\\) and \\(\\dot{w}\\) are different form \\(a_{x}\\) , \\(a_{y}\\) and \\(a_{z}\\) (measured from the IMU), because the time partial derivative of the velocity in the states ( \\(\\dot{u}\\) , \\(\\dot{v}\\) and \\(\\dot{w}\\) ) measure only the absolute value variation of u and v! The equation is used directly for the matrix H, instead need to be inverted to find matrix F, which needs \\(\\dot{u}\\) , \\(\\dot{v}\\) and \\(\\dot{w}\\) . \\[ \\left\\{\\begin{array}{l} a_{x}=\\dot{u}+\\dot{\\theta} w-\\Omega v-g \\sin (\\theta) \\\\ a_{y}=\\dot{v}+\\Omega u-\\dot{\\phi} w+g \\sin (\\phi) \\cos (\\theta) \\\\ a_{z}=\\dot{w}+\\dot{\\phi} v-\\dot{\\theta} u-g \\cos (\\phi) \\cos (\\theta) \\end{array}\\right. \\] where \\(w\\) is the vertical component of the centre of mass velocity and \\(g\\) is the gravity acceleration value - equal to \\(-9,81 \\mathrm{~m} / \\mathrm{s}^{2}\\) - In relation 23, roll and pitch appear in the trigonometric functions. To remove these non-linearity terms, the sine and the cosine of these angles are considered as system states defining its evolution as follow, where \\(\\alpha\\) is a generic angle. \\[ \\frac{d}{d t} \\sin (\\alpha)=\\sin (\\alpha)=\\cos (\\alpha) \\dot{\\alpha} \\quad ; \\quad \\frac{d}{d t} \\cos (\\alpha)=\\cos (\\alpha)=-\\sin (\\alpha) \\dot{\\alpha} \\] To sum up, the system states are collected in the vector \\(x\\) . The measurements are collected in the vector \\(z\\) and includes the longitudinal velocity computed from the frot wheels - or another estimation method -, the centre of mass accelerations and the value of sine and cosine of roll and pitch, estimated using the steady-state formulation in the load transfer model - reported in the following section in the expressions 39 and 40 The system input vector collects the centre of mass accelerations. The system equations in state-space can be written as reported in the expression 22 where, in this case, the terms are defined as follow. \\[ \\begin{aligned} & x=[u, \\dot{u}, v, \\dot{v}, w, \\dot{w}, \\\\ & \\sin (\\theta), \\sin (\\theta), \\cos (\\theta), \\cos (\\theta), \\sin (\\phi), \\sin (\\phi), \\cos (\\phi), \\cos (\\phi)]^{T} \\\\ & z=\\left[u, a_{x}, a_{y}, a_{z}, \\sin (\\theta), \\cos (\\theta), \\sin (\\phi), \\cos (\\phi), 1,1\\right]^{T} \\\\ & B {c}=\\left[0, a_{x}, 0, a_{y}, 0, a_{z}, 0,0,0,0,0,0,0,0\\right]^{T} \\end{aligned} \\] In this case, the system matrices are defined as follow. \\[ F=\\left[\\begin{array}{cc} F_{1,1} & F_{1,2} \\\\ 0 & F_{2,2} \\end{array}\\right] \\quad H=\\left[\\begin{array}{cc} H_{1,1} & H_{1,2} \\\\ 0 & H_{2,2} \\end{array}\\right] \\] where \\[ F_{1,1}=\\left[\\begin{array}{cccccc}1 & T_{s} & 0 & 0 & 0 & 0 \\\\ 0 & 0 & \\Omega & 0 & -\\dot{\\theta} & 0 \\\\ 0 & 0 & 1 & T_{s} & 0 & 0 \\\\ -\\Omega & 0 & 0 & 0 & \\dot{\\phi} & 0 \\\\ 0 & 0 & 0 & 0 & 1 & T_{s} \\\\ \\dot{\\theta} & 0 & -\\dot{\\phi} & 0 & 0 & 0\\end{array}\\right] \\] \\[ F_{1,2}=\\left[\\begin{array}{cccccccc}0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ -g & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & \\frac{g \\sin (\\phi)}{2} & 0 & \\frac{g \\cos (\\theta)}{2} & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & -\\frac{g \\cos (\\phi)}{2} & 0 & 0 & 0 & -\\frac{g \\cos (\\theta)}{2} & 0\\end{array}\\right] \\\\ \\] \\[ F_{2,2}=\\left[\\begin{array}{cccccccc} 1 & T_{s} & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & \\dot{\\theta} & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & T_{s} & 0 & 0 & 0 & 0 \\\\ -\\dot{\\theta} & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & T_{s} & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & \\dot{\\phi} & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & T_{s} \\\\ 0 & 0 & 0 & 0 & -\\dot{\\phi} & 0 & 0 & 0\\end{array}\\right] \\\\ \\] \\[ H_{1,1}=\\left[\\begin{array}{cccccc}1 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 1 & -\\Omega & 0 & \\dot{\\theta} & 0 \\\\ \\Omega & 0 & 0 & 1 & -\\dot{\\phi} & 0 \\\\ -\\dot{\\theta} & 0 & \\dot{\\phi} & 0 & 0 & 1\\end{array}\\right] \\\\ \\] \\[ H_{1,2}=\\left[\\begin{array}{cccccccc}0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ g & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & -\\frac{g \\sin (\\phi)}{2} & 0 & -\\frac{g \\cos (\\theta)}{2} & 0 & 0 & 0 \\\\ 0 & 0 & \\frac{g \\cos (\\phi)}{2} & 0 & 0 & 0 & \\frac{g \\cos (\\theta)}{2} & 0\\end{array}\\right] \\] \\[ H_{2,2}=\\left[\\begin{array}{cccccccc}1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\\ \\sin (\\theta) & 0 & \\cos (\\theta) & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\sin (\\phi) & 0 & \\cos (\\phi) & 0\\end{array}\\right] \\\\ \\] The matrices are not constant but depend on the states, as in the previous case. In order to fill these matrices, the data from the current measurement vector are used. The last two rows of the matrix \\(H\\) correspond to the constraints about the sum of the square of sine and cosine of pitch and roll respectively. These constraints must be always equal to 1 , as can be seen in the last two terms of the vector \\(z\\) . Also, in this case, the estimator output is reset when the yaw rate is close to zero. In [4], is reported also a different notation for this system using the quaternions formulation. However, since the vehicle model is defined using the Euler angle - roll \\((\\phi)\\) , pitch \\((\\theta)\\) and yaw \\((\\psi)\\) -, this formulation allows being closer to the vehicle model description. The usage of quaternions can reflect on a more robust numerical stability with respect to Euler angle. However, the Euler angles appear in their trigonometric functions which correspond with the quaternions definition. Kalman Filters tuning In literature, there are several methods for Kalman filter tuning. The estimators aforementioned are based on time-variant systems. For this reason, a method that uses Monte-Carlo simulation is suggested. In this work, the Genetic Algorithm [14] is used in order to optimize the covariance matrices. The tuning algorithm aims to optimize the matrix \\(Q \\in \\mathbb{R}^{n, n}\\) and the matrix \\(R \\in \\mathbb{R}^{m, m}\\) , where \\(n\\) is the dimension of the state vector and \\(m\\) is the dimension of the measurements vector. The theory behind this algorithm consists of check the statistical consistency between the estimation error and their covariance. This means that that the estimation error has to be normally distributed, with covariance matrix equal to \\(P- {e}_{k} \\backsim N(0, P) ; {e}_{k}=x_{k}-\\hat{x}_{k \\mid k}\\) , where \\(x_{k}\\) is the actual state and \\(x_{k \\mid k}\\) is the KF estimation - To check the consistency, a simulated data sample is built in a simulation environment. This sample contains \\(N\\) sample discretized with \\(N_{k}\\) time interval. For each time-step \\((k)\\) , the normalized error statistic \\(\\xi_{k}\\) can be computed as shown in relation 24 . \\[ \\xi_{k}= {e}_{k}^{T} P_{k \\mid k}^{-1} {e}_{k} \\] The algorithm is evaluated, at each iteration, over \\(N_{M C}\\) Monte-Carlo runs. Averaging the error statistic over the \\(N_{M C}\\) runs, the mean normalized error statistic is defined as \\[ \\bar{\\xi}_{k}=\\sum_{r=1}^{N_{M C}} \\xi_{k} \\] If the estimation error \\(e_{k}\\) has a Gaussian distribution, \\(\\bar{\\xi}_{k}\\) is distributed as a \\(\\chi^{2}\\) random variable with \\(n N_{M C}\\) degrees of freedom Thus the filter consistency can be verified via statistical hypothesis that \\(\\bar{\\xi}_{k}\\) is distributed as a \\(\\chi_{n N_{M C}}^{2}\\) . To do that, \\(F_{k}^{\\chi^{2}}\\) has to be defined for each time-step. \\[ F_{k}^{\\chi^{2}}=\\operatorname{Prob}\\left\\{\\chi_{n N_{M C}^{2}}^{2}<\\bar{\\xi}_{k}\\right\\} \\] Then, the couples \\(\\left[\\bar{\\xi}_{k}, F_{k}^{\\chi^{2}}\\right]\\) have to be sorted in ascending order. The index \\(i(k) \\in\\) \\(\\left[1, N_{k}\\right]\\) denotes the position of \\(F_{k}^{\\chi^{2}}\\) in the sorted array. Finally, \\(F_{k}^{\\chi^{2}}\\) can be plotted against \\(i(k) / N_{k}\\) (figure 3). Figure 3: \\(\\chi^{2}\\) consistency test \\(1 \"[\\ldots]\\) In statistic, it is the number of values or of variables which can be chosen arbitrarily in a stocastic model identification. [...]\" see \"libert\u00e0, gradi di\" treccani.com Regarding figure 3, the actual distribution is consistent if it is close to the desired distribution \\(\\left(\\chi^{2}\\right)\\) . In order to measure the consistency of the filter, a performance index \\((J)\\) is mathematically defined as the area between the two curves, actual and desired. \\[ J=\\frac{1}{N_{k}} \\sum_{i=1}^{N_{k}}\\left|d_{i(k)}\\right| \\] If a filter is consistent, the optimization structure aims to minimize the estimation covariance. For this reason, the algorithm cost function is defined as the norm of the estimation covariance matrix \\((\\|P\\|)\\) . To distinguish when a filter is consistent, a simple threshold over the performance index is set - typically equal to \\(0.05\\) -. Algorithmically, the cost function is called fitness and is defined in relation 28 . \\[ \\text { fitness }= \\begin{cases}\\|P\\| & J<0.05 \\\\ -J & \\text { otherwise }\\end{cases} \\] If the fitness is negative, it means that the system is inconsistent since the \\(J\\) is an always positive value. Among the inconsistent filters, the best fitness is a value close to zero. When a filter becomes consistent, the best choice is a value of fitness the smallest as possible. Between a consistent and an inconsistent filter, the best choice is always the consistent one. The algorithm starts initializing a population: each individual is identified using a chromosome in which the optimized parameters are encoded in a string of bits. Once the initial population is evaluated, the algorithm iterations start. Each iteration is composed of three parts: reproduction, mutation and reevaluation. In the reproduction step, a certain number of individuals, randomly extracted from the population, are selected to be mother or father of two new individuals. The chromosome of the parents is cut and crossed to generate the chromosome of the children. This operation is called crossover. In order to speed up the convergence of the algorithm, the individuals with a better level of \"fitness\" will reproduce more. In the following step, some individuals of the original population are randomly selected to become mutants: a small number of bits is randomly selected and are inverted. Finally, to compensate for particular \"lucky\" Monte-Carlo simulations some individuals are chosen to be reevaluated. These new individuals are evaluated and added to the starting population. The individuals with the worst \"fitness\" are the ones that should die. For what concerns the Kalman filter implemented in this thesis, the process is timevariant. For this reason, the tuning procedure is more challenging. Nevertheless, if the sample of simulated data is enough comprehensive, the results can be still good. For both the tuning, the algorithm parameters are set as follow: The parameters are encoded in the chromosome using 10 bits; The population has a fixed size of 50 individuals; At each iteration, 26 children are generated; At each iteration, 20 mutants are created with 10 mutations each; At each iteration, 5 individuals are selected to be reevaluated; The number of Monte-Carlo runs are set equal to 250 over a sample of 324 tests; The number of iterations is set equal to 1000 In order to have a proper tuning and results evaluation, the simulated quantities, considered as virtual sensors, are perturbed with a random noise that is closest as possible to the noise of the real sensor. In particular, for the IMU data, the MATLAB model of the inertial measurement unit (imuSensor()) is employed, considering also random walk effects. Tuning results - Planar Estimator The tuning procedure for the first exposed Kalman filter starts with the definition of the parameters that the algorithm has to tune. Assuming an uncorrelated processnoise and measurement noise, the covariance matrices are diagonal and their elements are the variance of the related state or measure. \\[ Q=\\left[\\begin{array}{cccc} \\sigma_{u}^{2} & 0 & 0 & 0 \\\\ 0 & \\sigma_{u_{-} d o t}^{2} & 0 & 0 \\\\ 0 & 0 & \\sigma_{v}^{2} & 0 \\\\ 0 & 0 & 0 & \\sigma_{u-d o t}^{2} \\end{array}\\right] \\quad R=\\left[\\begin{array}{ccc} \\sigma_{u_{m}}^{2} & 0 & 0 \\\\ 0 & \\sigma_{a}^{2} & 0 \\\\ 0 & 0 & \\sigma_{a}^{2} \\end{array}\\right] \\] These variances are free to vary over a certain interval during the optimization. Table 3 reports these intervals and the optimized value for each parameter. Value Min. Val. Max. Val. Opt. Val. \\(\\sigma_{u}^{2}\\) \\(0.0\\) \\(15.0\\) \\(9.432\\) \\(\\sigma_{u_{d} d o t}^{2}\\) \\(0.0\\) \\(10.0\\) \\(2.601\\) \\(\\sigma_{v}^{2}\\) \\(0.0\\) \\(10.0\\) \\(6.247\\) \\(\\sigma_{v-d o t}^{2}\\) \\(0.0\\) \\(15.0\\) \\(9.521\\) \\(\\sigma_{u_{m}}^{2}\\) \\(0.0\\) \\(5.0\\) \\(3.468\\) \\(\\sigma_{a}^{2}\\) \\(0.5\\) \\(2.0\\) \\(0.605\\) Table 3: Tuning results - planar state estimator Adopting these parameters in the covariance matrices, the consistency test gives a performance index \\(J=0.143\\) . This means that the filter is not consistent, using the aforementioned definition. This definition, coupled with the fact that the consistency graph (figure 4) shows two curves different from each other, suggests not use this estimation algorithm. However, looking at the algorithm output for a simulation manoeuvre - the simulation inputs of this manoeuvre are shown in figure 5-, the results seem to be proper (figure 6). Figure 4: \\(\\chi^{2}\\) consistency test - planar state estimator Figure 5: Inputs of the manoeuvre used for the tuning evaluation Figure 6: Estimation results - planar state estimator Tuning results - 3D Estimator For what concern the second Kalman filter, the process and the measurement covariance matrices are larger than in the case before - \\(Q \\in \\mathbb{R}^{14,14}\\) and \\(R \\in \\mathbb{R}^{10,10}\\) -. However, it is possible to assume that the process state and the measure are uncorrelated with each other. Using this hypothesis, the matrices \\(Q\\) and \\(R\\) can be initialized as diagonal matrices, with their elements equal to the variance of the associated state or measure. In table \\(4 \\sigma_{\\text {sin/cos }}^{2}\\) and \\(\\sigma_{\\text {sin/cos-dot }}^{2}\\) are the variance related to the trigonometric functions of pitch and roll and their derivatives. \\(\\sigma_{1}^{2}\\) is, instead, connected to the constraint about the trigonometric functions: ideally, it is equal to zero. However the non-absolutely correctness of the expressions, due to estimation errors, makes the constraint vary causing a non-zero variance. With this set of parameters (table 4), the resulting performance index results \\(J=\\) 0.175. As in the case before, the filter results non-consistent. However, looking at the figures 8 and 9, obtained with the same manoeuvre of the case before (figure 5), the estimation results give a sufficiently good estimation for the states of interest. The only state that seems to be wrong estimated is the vertical velocity \\(w\\) . Nevertheless, the reference value of it is equal to zero and the estimated value does not differ too much from the reference. Value Min. Max. Opt. Value Min. Max. Opt. \\(\\sigma_{u}^{2}\\) \\(5.0\\) \\(15.0\\) \\(6.769\\) \\(\\sigma_{w-dot}^{2}\\) \\(0.0\\) \\(10.0\\) \\(7.811\\) \\(\\sigma_{u ext { dot }}^{2}\\) \\(15.0\\) \\(25.0\\) \\(15.684\\) \\(\\sigma_{\\text {sin }}^{2}\\) \\(0.0\\) \\(1.0\\) \\(0.116\\) \\(\\sigma_{v}^{2}\\) \\(0.0\\) \\(10.0\\) \\(2.601\\) \\(\\sigma_{\\text {sin-dot }}^{2}\\) \\(0.0\\) \\(5.0\\) \\(4.057\\) \\(\\sigma_{v_{-d o t}}^{2}\\) \\(0.0\\) \\(10.0\\) \\(0.627\\) \\(\\sigma_{\\text {cos }}^{2}\\) \\(0.0\\) \\(0.5\\) \\(0.546\\) \\(\\sigma_{w}^{2}\\) \\(8.0\\) \\(18.0\\) \\(15.410\\) \\(\\sigma_{\\text {cos-dot }}^{2}\\) \\(0.0\\) \\(5.0\\) \\(1.418\\) \\(\\sigma_{u_{m}}^{2}\\) \\(0.0\\) \\(5.0\\) \\(3.803\\) \\(\\sigma_{\\text {cos } m }^{2}\\) \\(0.0\\) \\(0.5\\) \\(0.256\\) \\(\\sigma_{a}^{2}\\) \\(0.0\\) \\(2.0\\) \\(0.714\\) \\(\\sigma_{1}^{2}\\) \\(0.0\\) \\(1.0\\) \\(0.224\\) \\(\\sigma_{\\text {sin } \\mathrm{m} .}^{2}\\) \\(0.0\\) \\(1.0\\) \\(0.499\\) Table 4: Tuning results - three dimensional state estimator Figure 7: \\(\\chi^{2}\\) consistency test - 3D estimator Figure 8: Estimation results - 3D estimator - Part 1 Figure 9: Estimation results - 3D estimator - Part 2 Algorithms Performances Finally, let us evaluate the lateral velocity estimators performances both applied to simulated data and the real telemetry data from the tests. Figure 10 illustrates the outputs of the algorithms using the simulated data for a constant steering angle test. The noise model used for this simulation is the same used in the tuning case and in the manoeuvre which inputs are reported in figure 5. It can be seen that the lateral velocity shows a different behaviour depending on the estimation algorithm used. The most simple algorithm (Luemberger) shows the best estimation of the lateral velocity, remaining very close to the actual simulated value, both at low speed and at high speed. The Kalman filter, instead, gives out useless estimation of the states. This can be related to the nature of the estimators itself: these are estimators that use kinematic relations. For this reason, they are strongly subjected to the type of noise and to the bias terms. In particular, a very small bias term in the acceleration can make the algorithm diverge, as it happens in the second Kalman filter case. However, in the data loading part, some acceleration biases due to a not perfectly planar mounting of the IMU sensor is compensated. This correction works thanks to a rotation matrix evaluated knowing that, in the static condition, the only measurable acceleration is the gravity term (perfectly vertical). Hence, the failure of the algorithms can be due to some other non-modelled effects as the chassis motion. The diverging behaviour of the Kalman algorithms can be also caused by the filter inconsistency: this property can give good results for some specific scenarios but completely wrong estimation in normal situations. Figure 10: Estimation results using simulated telemetry data Working with real telemetry data (figure 11), the effects aforementioned are stronger and the Kalman estimations are even worse than in the previous case. The Luemberger estimation, instead, seems to give a good estimation of the real lateral velocity. The graph reported in figure 11, shows the longitudinal and lateral velocity during a steering pad, driven with a gradually increasing speed. Figure 11: Estimation results using real telemetry data The divergent attitude of the Kalman algorithms encourages the usage of the Luemberger observer as lateral velocity estimator.","title":"Lateral Velocity Estimator"},{"location":"data-analysis-DMT/Estimation%20Functions/C.Lateral-Velocity-Estimator/#lateral-velocity-estimator","text":"","title":"Lateral Velocity Estimator"},{"location":"data-analysis-DMT/Estimation%20Functions/C.Lateral-Velocity-Estimator/#lateral-velocity-luemberger-observer","text":"One of the most common problem in the vehicle state estimation is the estimation of the lateral velocity \\((v)\\) , or the body-side slip angle \\((\\beta)\\) . A simple method to solve this problem is the kinematic-based Luemberger observer, presented also in [7]. This observer is based on the following system of equations. \\[ \\left\\{\\begin{array}{l} \\dot{u}=v \\Omega+a_{x} \\\\ \\dot{v}=-u \\Omega+a_{y} \\end{array}\\right. \\] In order to implement the observer, the system has to be written in state-space form. \\[ \\begin{gathered} \\dot{ {x}}=\\left[\\begin{array}{l} \\dot{u} \\\\ \\dot{v} \\end{array}\\right]=\\left[\\begin{array}{cc} 0 & \\Omega \\\\ -\\Omega & 0 \\end{array}\\right]\\left[\\begin{array}{l} u \\\\ v \\end{array}\\right]+\\left[\\begin{array}{ll} 1 & 0 \\\\ 0 & 1 \\end{array}\\right]\\left[\\begin{array}{l} a_{x} \\\\ a_{y} \\end{array}\\right]=F {x}+B {c} \\\\ z=[u]=\\left[\\begin{array}{ll} 1 & 0 \\end{array}\\right]\\left[\\begin{array}{l} u \\\\ v \\end{array}\\right]=H {x} \\end{gathered} \\] Equation 16 correspond to the system evolution equation while equation 17 is the output equation, namely, the computation of the measurable quantities. Since the lateral velocity is not in the output vector, it can not be measured. The observer uses the state evolution equation in order to estimate the states and corrects the estimation using the estimation error on the measurable output \\((z-\\hat{z})\\) . \\[ \\begin{aligned} \\dot{\\hat{x}} & =F \\hat{x}+B {c}+L( {z}-\\hat{ {z}}) \\\\ & =(F-L H) \\hat{x}+B {c}+L {z} \\end{aligned} \\] Where \\(\\hat{ {x}}\\) and \\(\\hat{ {z}}\\) are the estimated state and output vector respectively and \\(L\\) is the so-called Luemberger's matrix. From equation 18, the estimation error \\(( {e}= {x}-\\hat{ {x}})\\) dynamical equation can be extrapolated. \\[ \\dot{e}=(F-L H) {e}=G {e} \\] Looking at equation 19, the error is asymptotically stable if and only if the matrix \\((F-L H)\\) is Hurwitz, i.e. its eigenvalues has a negative real part. In order to impose this condition, the Luemberger's matrix has to be properly tuned. A possible choice for the matrix \\(L\\) is reported in relation 20. This matrix ensures that the eigenvalues of the matrix \\(G\\) are \\(e_{v-1,2}=-\\gamma|\\Omega|\\) , providing error stability. The parameter \\(\\gamma\\) is a tunable parameter and is connected to the convergence rate. \\[ L=\\left[\\begin{array}{c} 2 \\gamma|\\Omega| \\\\ \\left(\\gamma^{2}-1\\right) \\Omega \\end{array}\\right] \\] An observability check is useful to evaluate the performance of this algorithm. It consists in the computation of the rank of the Observability matrix \\((O)\\) . If \\(\\operatorname{Rank}(O)=\\) \\(n\\) , where \\(n\\) is the state dimension - in this case 2 -, the system is observable. \\[ O=\\left[\\begin{array}{c} H \\\\ F H \\end{array}\\right]=\\left[\\begin{array}{cc} 1 & 0 \\\\ 0 & -\\Omega \\end{array}\\right] \\] From equation 21, it is possible to see that the matrix \\(O\\) has rank equal to 2 if the yawrate is different from 0 . This means that the system is not observable if the trajectory is straight. This may be deduced also from the eigenvalues of the matrix \\(G\\) , that goes to zero making the system simply stable when \\(\\Omega\\) tends to zero. However, this problem can be easily solved by resetting the observer when the yaw-rate is close to zero - as explained in the results of [7] -. This observer does not require any prior knowledge about the vehicle and is computationally simple. These characteristics allow the spreading of this algorithm.","title":"Lateral Velocity Luemberger Observer"},{"location":"data-analysis-DMT/Estimation%20Functions/C.Lateral-Velocity-Estimator/#luemberger-observer-tuning","text":"As we already said, the performance of the Luemberger observer is given by the tunable parameter \\(\\gamma\\) . Theoretically, it should be higher as possible in order to guarantee convergence. However, increasing it too much can generate chattering in the estimation. On the contrary, if the value of \\(\\gamma\\) is low, the estimation tends to diverge under the effects of dynamical bias that are difficult to be compensated. In an offline analysis, a simple solution to this problem is to increase the observer gain to ensure a correct estimation and strongly filter the observer output. For this application, a moving average filter is applied further and backwards in time to compensate for the filtering delay. Using this trick, the parameter \\(\\gamma\\) can be set equal to 100 . Real-time estimation of the lateral velocity needs a more sophisticated observer tuning, a different filtering technique - for example, similarly to the one applied to the SOSM observer presented in the following section - or a more robust estimation scheme, involving vehicle dynamical properties.","title":"Luemberger Observer Tuning"},{"location":"data-analysis-DMT/Estimation%20Functions/C.Lateral-Velocity-Estimator/#kf-lateral-velocity-estimators-planar-estimator","text":"Alternatively to the Luemberger observer, there are other methods for the lateral velocity estimation. In this thesis, two different Kalman filters are shown, with two different levels of complexity. The first presented Kalman filter is based on the same system model described in equations of Luemberger observer and reported also below. However, the definition of the system and measurement errors ( \\(v\\) and \\(w\\) respectively) is needed. The integration scheme is included in the system matrices. The vector z contains the measured quatities from the sensor, instead the vector x the states. N.B. \\(\\dot{u}\\) and \\(\\dot{v}\\) are different form \\(a_{x}\\) and \\(a_{y}\\) (measured from the IMU), because the time partial derivate of the velocity in states ( \\(\\dot{u}\\) and \\(\\dot{v}\\) ) measure only the absolute value variation of u and v! \\[ \\left\\{\\begin{array}{l} {x}_{k}=F_{k} {x}_{k-1}+B_{k} {c}_{k}+ {v}_{k} \\\\ {z}_{k}=H_{k} {x}_{k-1}+ {w}_{k} \\end{array}\\right. \\] where \\[ F_{k} {x}_{k-1}+B_{k} {c}_{k} = \\left\\{\\begin{array}{l} u_{k} = u_{k-1} + Ts*a_{x} \\\\ \\dot{u}=v \\Omega+a_{x} \\\\ v_{k} = v_{k-1} + Ts*a_{y} \\\\ \\dot{v}=-u \\Omega+a_{y} \\end{array}\\right. \\] \\[ H_{k} {x}_{k-1} = \\left\\{\\begin{array}{l} u_{k_{SF}} = u_{k-1}\\\\ a_{x_{IMU}} = \\dot{u} - v \\Omega \\\\ a_{y_{IMU}} = \\dot{v} + u \\Omega \\end{array}\\right. \\] so the matrices become: \\[ \\begin{aligned} & \\hspace{5em} {x}_{k}=\\left[\\begin{array}{c}u_{k} \\\\\\dot{u}_{k} \\\\v_{k} \\\\\\dot{v}_{k}\\end{array}\\right] \\hspace{10em} z_{k}=\\left[\\begin{array}{c}u_{k} \\\\a_{x, k} \\\\a_{y, k}\\end{array}\\right] \\\\ & F_{k}=\\left[\\begin{array}{cccc}1 & T_{s} & 0 & 0 \\\\0 & 0 & \\Omega_{k} & 0 \\\\0 & 0 & 1 & T_{s} \\\\-\\Omega_{k} & 0 & 0 & 0\\end{array}\\right] \\quad B_{k}=\\left[\\begin{array}{ll}0 & 0 \\\\1 & 0 \\\\0 & 0 \\\\0 & 1\\end{array}\\right] \\quad H_{k}=\\left[\\begin{array}{cccc}1 & 0 & 0 & 0 \\\\0 & 1 & -\\Omega_{k} & 0 \\\\\\Omega_{k} & 0 & 0 & 1\\end{array}\\right] \\end{aligned} \\] Differently from the Luemberger case, this algorithm uses also the information on the measured acceleration in order to correct the estimation. The estimated accelerations are computed in the updating step inverting the process equations. Hence, the same values of accelerations are used as inputs, in the prediction steps, and as measured quantities in the updating step. The algorithm iteration scheme is shown in equations 3, 4 and 5. To increase the estimation accuracy, the estimator output is reset when the yaw-rate is close to zero.","title":"KF Lateral Velocity Estimators - Planar Estimator"},{"location":"data-analysis-DMT/Estimation%20Functions/C.Lateral-Velocity-Estimator/#kf-lateral-velocity-estimators-3d-estimator","text":"The second state estimator Kalman filter that is presented in this thesis is based on the work of Alatorre et al. [4]. This estimator is based on a larger system of equations that include also the third dimension. This allows us to take advantage of the gravity term in order to correct some acceleration bias and to estimate the roll and the pitch angle. The system of equations is reported in relation 23. The vector z contains the measured quatities from the sensor, instead the vector x the states. N.B. \\(\\dot{u}\\) , \\(\\dot{v}\\) and \\(\\dot{w}\\) are different form \\(a_{x}\\) , \\(a_{y}\\) and \\(a_{z}\\) (measured from the IMU), because the time partial derivative of the velocity in the states ( \\(\\dot{u}\\) , \\(\\dot{v}\\) and \\(\\dot{w}\\) ) measure only the absolute value variation of u and v! The equation is used directly for the matrix H, instead need to be inverted to find matrix F, which needs \\(\\dot{u}\\) , \\(\\dot{v}\\) and \\(\\dot{w}\\) . \\[ \\left\\{\\begin{array}{l} a_{x}=\\dot{u}+\\dot{\\theta} w-\\Omega v-g \\sin (\\theta) \\\\ a_{y}=\\dot{v}+\\Omega u-\\dot{\\phi} w+g \\sin (\\phi) \\cos (\\theta) \\\\ a_{z}=\\dot{w}+\\dot{\\phi} v-\\dot{\\theta} u-g \\cos (\\phi) \\cos (\\theta) \\end{array}\\right. \\] where \\(w\\) is the vertical component of the centre of mass velocity and \\(g\\) is the gravity acceleration value - equal to \\(-9,81 \\mathrm{~m} / \\mathrm{s}^{2}\\) - In relation 23, roll and pitch appear in the trigonometric functions. To remove these non-linearity terms, the sine and the cosine of these angles are considered as system states defining its evolution as follow, where \\(\\alpha\\) is a generic angle. \\[ \\frac{d}{d t} \\sin (\\alpha)=\\sin (\\alpha)=\\cos (\\alpha) \\dot{\\alpha} \\quad ; \\quad \\frac{d}{d t} \\cos (\\alpha)=\\cos (\\alpha)=-\\sin (\\alpha) \\dot{\\alpha} \\] To sum up, the system states are collected in the vector \\(x\\) . The measurements are collected in the vector \\(z\\) and includes the longitudinal velocity computed from the frot wheels - or another estimation method -, the centre of mass accelerations and the value of sine and cosine of roll and pitch, estimated using the steady-state formulation in the load transfer model - reported in the following section in the expressions 39 and 40 The system input vector collects the centre of mass accelerations. The system equations in state-space can be written as reported in the expression 22 where, in this case, the terms are defined as follow. \\[ \\begin{aligned} & x=[u, \\dot{u}, v, \\dot{v}, w, \\dot{w}, \\\\ & \\sin (\\theta), \\sin (\\theta), \\cos (\\theta), \\cos (\\theta), \\sin (\\phi), \\sin (\\phi), \\cos (\\phi), \\cos (\\phi)]^{T} \\\\ & z=\\left[u, a_{x}, a_{y}, a_{z}, \\sin (\\theta), \\cos (\\theta), \\sin (\\phi), \\cos (\\phi), 1,1\\right]^{T} \\\\ & B {c}=\\left[0, a_{x}, 0, a_{y}, 0, a_{z}, 0,0,0,0,0,0,0,0\\right]^{T} \\end{aligned} \\] In this case, the system matrices are defined as follow. \\[ F=\\left[\\begin{array}{cc} F_{1,1} & F_{1,2} \\\\ 0 & F_{2,2} \\end{array}\\right] \\quad H=\\left[\\begin{array}{cc} H_{1,1} & H_{1,2} \\\\ 0 & H_{2,2} \\end{array}\\right] \\] where \\[ F_{1,1}=\\left[\\begin{array}{cccccc}1 & T_{s} & 0 & 0 & 0 & 0 \\\\ 0 & 0 & \\Omega & 0 & -\\dot{\\theta} & 0 \\\\ 0 & 0 & 1 & T_{s} & 0 & 0 \\\\ -\\Omega & 0 & 0 & 0 & \\dot{\\phi} & 0 \\\\ 0 & 0 & 0 & 0 & 1 & T_{s} \\\\ \\dot{\\theta} & 0 & -\\dot{\\phi} & 0 & 0 & 0\\end{array}\\right] \\] \\[ F_{1,2}=\\left[\\begin{array}{cccccccc}0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ -g & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & \\frac{g \\sin (\\phi)}{2} & 0 & \\frac{g \\cos (\\theta)}{2} & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & -\\frac{g \\cos (\\phi)}{2} & 0 & 0 & 0 & -\\frac{g \\cos (\\theta)}{2} & 0\\end{array}\\right] \\\\ \\] \\[ F_{2,2}=\\left[\\begin{array}{cccccccc} 1 & T_{s} & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & \\dot{\\theta} & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & T_{s} & 0 & 0 & 0 & 0 \\\\ -\\dot{\\theta} & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & T_{s} & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & \\dot{\\phi} & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & T_{s} \\\\ 0 & 0 & 0 & 0 & -\\dot{\\phi} & 0 & 0 & 0\\end{array}\\right] \\\\ \\] \\[ H_{1,1}=\\left[\\begin{array}{cccccc}1 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 1 & -\\Omega & 0 & \\dot{\\theta} & 0 \\\\ \\Omega & 0 & 0 & 1 & -\\dot{\\phi} & 0 \\\\ -\\dot{\\theta} & 0 & \\dot{\\phi} & 0 & 0 & 1\\end{array}\\right] \\\\ \\] \\[ H_{1,2}=\\left[\\begin{array}{cccccccc}0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ g & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & -\\frac{g \\sin (\\phi)}{2} & 0 & -\\frac{g \\cos (\\theta)}{2} & 0 & 0 & 0 \\\\ 0 & 0 & \\frac{g \\cos (\\phi)}{2} & 0 & 0 & 0 & \\frac{g \\cos (\\theta)}{2} & 0\\end{array}\\right] \\] \\[ H_{2,2}=\\left[\\begin{array}{cccccccc}1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\\ \\sin (\\theta) & 0 & \\cos (\\theta) & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\sin (\\phi) & 0 & \\cos (\\phi) & 0\\end{array}\\right] \\\\ \\] The matrices are not constant but depend on the states, as in the previous case. In order to fill these matrices, the data from the current measurement vector are used. The last two rows of the matrix \\(H\\) correspond to the constraints about the sum of the square of sine and cosine of pitch and roll respectively. These constraints must be always equal to 1 , as can be seen in the last two terms of the vector \\(z\\) . Also, in this case, the estimator output is reset when the yaw rate is close to zero. In [4], is reported also a different notation for this system using the quaternions formulation. However, since the vehicle model is defined using the Euler angle - roll \\((\\phi)\\) , pitch \\((\\theta)\\) and yaw \\((\\psi)\\) -, this formulation allows being closer to the vehicle model description. The usage of quaternions can reflect on a more robust numerical stability with respect to Euler angle. However, the Euler angles appear in their trigonometric functions which correspond with the quaternions definition.","title":"KF Lateral Velocity Estimators - 3D Estimator"},{"location":"data-analysis-DMT/Estimation%20Functions/C.Lateral-Velocity-Estimator/#kalman-filters-tuning","text":"In literature, there are several methods for Kalman filter tuning. The estimators aforementioned are based on time-variant systems. For this reason, a method that uses Monte-Carlo simulation is suggested. In this work, the Genetic Algorithm [14] is used in order to optimize the covariance matrices. The tuning algorithm aims to optimize the matrix \\(Q \\in \\mathbb{R}^{n, n}\\) and the matrix \\(R \\in \\mathbb{R}^{m, m}\\) , where \\(n\\) is the dimension of the state vector and \\(m\\) is the dimension of the measurements vector. The theory behind this algorithm consists of check the statistical consistency between the estimation error and their covariance. This means that that the estimation error has to be normally distributed, with covariance matrix equal to \\(P- {e}_{k} \\backsim N(0, P) ; {e}_{k}=x_{k}-\\hat{x}_{k \\mid k}\\) , where \\(x_{k}\\) is the actual state and \\(x_{k \\mid k}\\) is the KF estimation - To check the consistency, a simulated data sample is built in a simulation environment. This sample contains \\(N\\) sample discretized with \\(N_{k}\\) time interval. For each time-step \\((k)\\) , the normalized error statistic \\(\\xi_{k}\\) can be computed as shown in relation 24 . \\[ \\xi_{k}= {e}_{k}^{T} P_{k \\mid k}^{-1} {e}_{k} \\] The algorithm is evaluated, at each iteration, over \\(N_{M C}\\) Monte-Carlo runs. Averaging the error statistic over the \\(N_{M C}\\) runs, the mean normalized error statistic is defined as \\[ \\bar{\\xi}_{k}=\\sum_{r=1}^{N_{M C}} \\xi_{k} \\] If the estimation error \\(e_{k}\\) has a Gaussian distribution, \\(\\bar{\\xi}_{k}\\) is distributed as a \\(\\chi^{2}\\) random variable with \\(n N_{M C}\\) degrees of freedom Thus the filter consistency can be verified via statistical hypothesis that \\(\\bar{\\xi}_{k}\\) is distributed as a \\(\\chi_{n N_{M C}}^{2}\\) . To do that, \\(F_{k}^{\\chi^{2}}\\) has to be defined for each time-step. \\[ F_{k}^{\\chi^{2}}=\\operatorname{Prob}\\left\\{\\chi_{n N_{M C}^{2}}^{2}<\\bar{\\xi}_{k}\\right\\} \\] Then, the couples \\(\\left[\\bar{\\xi}_{k}, F_{k}^{\\chi^{2}}\\right]\\) have to be sorted in ascending order. The index \\(i(k) \\in\\) \\(\\left[1, N_{k}\\right]\\) denotes the position of \\(F_{k}^{\\chi^{2}}\\) in the sorted array. Finally, \\(F_{k}^{\\chi^{2}}\\) can be plotted against \\(i(k) / N_{k}\\) (figure 3). Figure 3: \\(\\chi^{2}\\) consistency test \\(1 \"[\\ldots]\\) In statistic, it is the number of values or of variables which can be chosen arbitrarily in a stocastic model identification. [...]\" see \"libert\u00e0, gradi di\" treccani.com Regarding figure 3, the actual distribution is consistent if it is close to the desired distribution \\(\\left(\\chi^{2}\\right)\\) . In order to measure the consistency of the filter, a performance index \\((J)\\) is mathematically defined as the area between the two curves, actual and desired. \\[ J=\\frac{1}{N_{k}} \\sum_{i=1}^{N_{k}}\\left|d_{i(k)}\\right| \\] If a filter is consistent, the optimization structure aims to minimize the estimation covariance. For this reason, the algorithm cost function is defined as the norm of the estimation covariance matrix \\((\\|P\\|)\\) . To distinguish when a filter is consistent, a simple threshold over the performance index is set - typically equal to \\(0.05\\) -. Algorithmically, the cost function is called fitness and is defined in relation 28 . \\[ \\text { fitness }= \\begin{cases}\\|P\\| & J<0.05 \\\\ -J & \\text { otherwise }\\end{cases} \\] If the fitness is negative, it means that the system is inconsistent since the \\(J\\) is an always positive value. Among the inconsistent filters, the best fitness is a value close to zero. When a filter becomes consistent, the best choice is a value of fitness the smallest as possible. Between a consistent and an inconsistent filter, the best choice is always the consistent one. The algorithm starts initializing a population: each individual is identified using a chromosome in which the optimized parameters are encoded in a string of bits. Once the initial population is evaluated, the algorithm iterations start. Each iteration is composed of three parts: reproduction, mutation and reevaluation. In the reproduction step, a certain number of individuals, randomly extracted from the population, are selected to be mother or father of two new individuals. The chromosome of the parents is cut and crossed to generate the chromosome of the children. This operation is called crossover. In order to speed up the convergence of the algorithm, the individuals with a better level of \"fitness\" will reproduce more. In the following step, some individuals of the original population are randomly selected to become mutants: a small number of bits is randomly selected and are inverted. Finally, to compensate for particular \"lucky\" Monte-Carlo simulations some individuals are chosen to be reevaluated. These new individuals are evaluated and added to the starting population. The individuals with the worst \"fitness\" are the ones that should die. For what concerns the Kalman filter implemented in this thesis, the process is timevariant. For this reason, the tuning procedure is more challenging. Nevertheless, if the sample of simulated data is enough comprehensive, the results can be still good. For both the tuning, the algorithm parameters are set as follow: The parameters are encoded in the chromosome using 10 bits; The population has a fixed size of 50 individuals; At each iteration, 26 children are generated; At each iteration, 20 mutants are created with 10 mutations each; At each iteration, 5 individuals are selected to be reevaluated; The number of Monte-Carlo runs are set equal to 250 over a sample of 324 tests; The number of iterations is set equal to 1000 In order to have a proper tuning and results evaluation, the simulated quantities, considered as virtual sensors, are perturbed with a random noise that is closest as possible to the noise of the real sensor. In particular, for the IMU data, the MATLAB model of the inertial measurement unit (imuSensor()) is employed, considering also random walk effects.","title":"Kalman Filters tuning"},{"location":"data-analysis-DMT/Estimation%20Functions/C.Lateral-Velocity-Estimator/#tuning-results-planar-estimator","text":"The tuning procedure for the first exposed Kalman filter starts with the definition of the parameters that the algorithm has to tune. Assuming an uncorrelated processnoise and measurement noise, the covariance matrices are diagonal and their elements are the variance of the related state or measure. \\[ Q=\\left[\\begin{array}{cccc} \\sigma_{u}^{2} & 0 & 0 & 0 \\\\ 0 & \\sigma_{u_{-} d o t}^{2} & 0 & 0 \\\\ 0 & 0 & \\sigma_{v}^{2} & 0 \\\\ 0 & 0 & 0 & \\sigma_{u-d o t}^{2} \\end{array}\\right] \\quad R=\\left[\\begin{array}{ccc} \\sigma_{u_{m}}^{2} & 0 & 0 \\\\ 0 & \\sigma_{a}^{2} & 0 \\\\ 0 & 0 & \\sigma_{a}^{2} \\end{array}\\right] \\] These variances are free to vary over a certain interval during the optimization. Table 3 reports these intervals and the optimized value for each parameter. Value Min. Val. Max. Val. Opt. Val. \\(\\sigma_{u}^{2}\\) \\(0.0\\) \\(15.0\\) \\(9.432\\) \\(\\sigma_{u_{d} d o t}^{2}\\) \\(0.0\\) \\(10.0\\) \\(2.601\\) \\(\\sigma_{v}^{2}\\) \\(0.0\\) \\(10.0\\) \\(6.247\\) \\(\\sigma_{v-d o t}^{2}\\) \\(0.0\\) \\(15.0\\) \\(9.521\\) \\(\\sigma_{u_{m}}^{2}\\) \\(0.0\\) \\(5.0\\) \\(3.468\\) \\(\\sigma_{a}^{2}\\) \\(0.5\\) \\(2.0\\) \\(0.605\\) Table 3: Tuning results - planar state estimator Adopting these parameters in the covariance matrices, the consistency test gives a performance index \\(J=0.143\\) . This means that the filter is not consistent, using the aforementioned definition. This definition, coupled with the fact that the consistency graph (figure 4) shows two curves different from each other, suggests not use this estimation algorithm. However, looking at the algorithm output for a simulation manoeuvre - the simulation inputs of this manoeuvre are shown in figure 5-, the results seem to be proper (figure 6). Figure 4: \\(\\chi^{2}\\) consistency test - planar state estimator Figure 5: Inputs of the manoeuvre used for the tuning evaluation Figure 6: Estimation results - planar state estimator","title":"Tuning results - Planar Estimator"},{"location":"data-analysis-DMT/Estimation%20Functions/C.Lateral-Velocity-Estimator/#tuning-results-3d-estimator","text":"For what concern the second Kalman filter, the process and the measurement covariance matrices are larger than in the case before - \\(Q \\in \\mathbb{R}^{14,14}\\) and \\(R \\in \\mathbb{R}^{10,10}\\) -. However, it is possible to assume that the process state and the measure are uncorrelated with each other. Using this hypothesis, the matrices \\(Q\\) and \\(R\\) can be initialized as diagonal matrices, with their elements equal to the variance of the associated state or measure. In table \\(4 \\sigma_{\\text {sin/cos }}^{2}\\) and \\(\\sigma_{\\text {sin/cos-dot }}^{2}\\) are the variance related to the trigonometric functions of pitch and roll and their derivatives. \\(\\sigma_{1}^{2}\\) is, instead, connected to the constraint about the trigonometric functions: ideally, it is equal to zero. However the non-absolutely correctness of the expressions, due to estimation errors, makes the constraint vary causing a non-zero variance. With this set of parameters (table 4), the resulting performance index results \\(J=\\) 0.175. As in the case before, the filter results non-consistent. However, looking at the figures 8 and 9, obtained with the same manoeuvre of the case before (figure 5), the estimation results give a sufficiently good estimation for the states of interest. The only state that seems to be wrong estimated is the vertical velocity \\(w\\) . Nevertheless, the reference value of it is equal to zero and the estimated value does not differ too much from the reference. Value Min. Max. Opt. Value Min. Max. Opt. \\(\\sigma_{u}^{2}\\) \\(5.0\\) \\(15.0\\) \\(6.769\\) \\(\\sigma_{w-dot}^{2}\\) \\(0.0\\) \\(10.0\\) \\(7.811\\) \\(\\sigma_{u ext { dot }}^{2}\\) \\(15.0\\) \\(25.0\\) \\(15.684\\) \\(\\sigma_{\\text {sin }}^{2}\\) \\(0.0\\) \\(1.0\\) \\(0.116\\) \\(\\sigma_{v}^{2}\\) \\(0.0\\) \\(10.0\\) \\(2.601\\) \\(\\sigma_{\\text {sin-dot }}^{2}\\) \\(0.0\\) \\(5.0\\) \\(4.057\\) \\(\\sigma_{v_{-d o t}}^{2}\\) \\(0.0\\) \\(10.0\\) \\(0.627\\) \\(\\sigma_{\\text {cos }}^{2}\\) \\(0.0\\) \\(0.5\\) \\(0.546\\) \\(\\sigma_{w}^{2}\\) \\(8.0\\) \\(18.0\\) \\(15.410\\) \\(\\sigma_{\\text {cos-dot }}^{2}\\) \\(0.0\\) \\(5.0\\) \\(1.418\\) \\(\\sigma_{u_{m}}^{2}\\) \\(0.0\\) \\(5.0\\) \\(3.803\\) \\(\\sigma_{\\text {cos } m }^{2}\\) \\(0.0\\) \\(0.5\\) \\(0.256\\) \\(\\sigma_{a}^{2}\\) \\(0.0\\) \\(2.0\\) \\(0.714\\) \\(\\sigma_{1}^{2}\\) \\(0.0\\) \\(1.0\\) \\(0.224\\) \\(\\sigma_{\\text {sin } \\mathrm{m} .}^{2}\\) \\(0.0\\) \\(1.0\\) \\(0.499\\) Table 4: Tuning results - three dimensional state estimator Figure 7: \\(\\chi^{2}\\) consistency test - 3D estimator Figure 8: Estimation results - 3D estimator - Part 1 Figure 9: Estimation results - 3D estimator - Part 2","title":"Tuning results - 3D Estimator"},{"location":"data-analysis-DMT/Estimation%20Functions/C.Lateral-Velocity-Estimator/#algorithms-performances","text":"Finally, let us evaluate the lateral velocity estimators performances both applied to simulated data and the real telemetry data from the tests. Figure 10 illustrates the outputs of the algorithms using the simulated data for a constant steering angle test. The noise model used for this simulation is the same used in the tuning case and in the manoeuvre which inputs are reported in figure 5. It can be seen that the lateral velocity shows a different behaviour depending on the estimation algorithm used. The most simple algorithm (Luemberger) shows the best estimation of the lateral velocity, remaining very close to the actual simulated value, both at low speed and at high speed. The Kalman filter, instead, gives out useless estimation of the states. This can be related to the nature of the estimators itself: these are estimators that use kinematic relations. For this reason, they are strongly subjected to the type of noise and to the bias terms. In particular, a very small bias term in the acceleration can make the algorithm diverge, as it happens in the second Kalman filter case. However, in the data loading part, some acceleration biases due to a not perfectly planar mounting of the IMU sensor is compensated. This correction works thanks to a rotation matrix evaluated knowing that, in the static condition, the only measurable acceleration is the gravity term (perfectly vertical). Hence, the failure of the algorithms can be due to some other non-modelled effects as the chassis motion. The diverging behaviour of the Kalman algorithms can be also caused by the filter inconsistency: this property can give good results for some specific scenarios but completely wrong estimation in normal situations. Figure 10: Estimation results using simulated telemetry data Working with real telemetry data (figure 11), the effects aforementioned are stronger and the Kalman estimations are even worse than in the previous case. The Luemberger estimation, instead, seems to give a good estimation of the real lateral velocity. The graph reported in figure 11, shows the longitudinal and lateral velocity during a steering pad, driven with a gradually increasing speed. Figure 11: Estimation results using real telemetry data The divergent attitude of the Kalman algorithms encourages the usage of the Luemberger observer as lateral velocity estimator.","title":"Algorithms Performances"},{"location":"data-analysis-DMT/Estimation%20Functions/D.Tire-Slips-Estimation/","text":"Tire Slips Estimation The slip computation procedure is a kinematic based estimation that needs to know in detail the vehicle kinematics on the ground plane. This knowledge, coupled with the knowledge about the wheel spin, allows identifying the tire slips. For this reason, the results of the kinematic based estimator aforementioned are used in this computation. The practical slip definition is taken as a reference - expression ?? - Tire Contact Points Velocities Before talking in details about the slip estimation, some considerations about the vehicle planar velocity has to be done. This allows us to compute the wheels contact points speed that are used in the slips computation. Let us define as \\(P_{0}\\) the projection of the vehicle centre of mass on the ground plane: the wheel contact point \\(\\left(P_{c i j}\\right)\\) are defined as follow. \\[ \\begin{array}{cc} P_{c R R}=P_{0}+\\left[R_{\\psi}\\right]\\left[\\begin{array}{c} -L_{R} \\\\ -W_{R} / 2 \\\\ 0 \\end{array}\\right] & P_{c R L}=P_{0}+\\left[R_{\\psi}\\right]\\left[\\begin{array}{c} -L_{R} \\\\ W_{R} / 2 \\\\ 0 \\end{array}\\right] \\\\ P_{c F R}=P_{0}+\\left[R_{\\psi}\\right]\\left[\\begin{array}{c} L_{F} \\\\ -W_{R} / 2 \\\\ 0 \\end{array}\\right] & P_{c F L}=P_{0}+\\left[R_{\\psi}\\right]\\left[\\begin{array}{c} L_{F} \\\\ W_{R} / 2 \\\\ 0 \\end{array}\\right] \\end{array} \\] where \\(\\left[R_{\\psi}\\right]\\) is the three-by-three matrix that describes the yaw rotation. The velocity of the contact points are found deriving \\(P_{c i j}\\) . In order to write the velocities in a suitable form, they are projected in the vehicle frame \\(-V_{c i j}=\\left[R_{\\psi}\\right]^{-1} \\dot{P}_{c i j}-\\) . \\[ \\begin{gathered} V_{c R R}=\\left[R_{\\psi}\\right]^{-1} \\dot{P}_{0}+\\left[P_{\\Omega}\\right]\\left[\\begin{array}{c} -L_{R} \\\\ -W_{R} / 2 \\\\ 0 \\end{array}\\right]=\\left[\\begin{array}{c} u \\\\ v \\\\ 0 \\end{array}\\right]+\\left[\\begin{array}{ccc} 0 & -\\Omega & 0 \\\\ \\Omega & 0 & 0 \\\\ 0 & 0 & 0 \\end{array}\\right]\\left[\\begin{array}{c} -L_{R} \\\\ -W_{R} / 2 \\\\ 0 \\end{array}\\right]=\\left[\\begin{array}{c} u+\\Omega W_{R} / 2 \\\\ v-\\Omega L_{R} \\\\ 0 \\end{array}\\right] \\\\ V_{c R L}=\\left[R_{\\psi}\\right]^{-1} \\dot{P}_{0}+\\left[P_{\\Omega}\\right]\\left[\\begin{array}{c} -L_{R} \\\\ W_{R} / 2 \\\\ 0 \\end{array}\\right]=\\left[\\begin{array}{l} u \\\\ v \\\\ 0 \\end{array}\\right]+\\left[\\begin{array}{ccc} 0 & -\\Omega & 0 \\\\ \\Omega & 0 & 0 \\\\ 0 & 0 & 0 \\end{array}\\right]\\left[\\begin{array}{c} -L_{R} \\\\ W_{R} / 2 \\\\ 0 \\end{array}\\right]=\\left[\\begin{array}{c} u-\\Omega W_{R} / 2 \\\\ v-\\Omega L_{R} \\\\ 0 \\end{array}\\right] \\\\ V_{c F R}=\\left[R_{\\psi}\\right]^{-1} \\dot{P}_{0}+\\left[P_{\\Omega}\\right]\\left[\\begin{array}{c} L_{F} \\\\ -W_{F} / 2 \\\\ 0 \\end{array}\\right]=\\left[\\begin{array}{l} u \\\\ v \\\\ 0 \\end{array}\\right]+\\left[\\begin{array}{ccc} 0 & -\\Omega & 0 \\\\ \\Omega & 0 & 0 \\\\ 0 & 0 & 0 \\end{array}\\right]\\left[\\begin{array}{c} L_{F} \\\\ -W_{F} / 2 \\\\ 0 \\end{array}\\right]=\\left[\\begin{array}{c} u+\\Omega W_{F} / 2 \\\\ v+\\Omega L_{F} \\\\ 0 \\end{array}\\right] \\end{gathered} \\] \\[V_{c F L}=\\left[R_{\\psi}\\right]^{-1} \\dot{P}_{0}+\\left[P_{\\Omega}\\right]\\left[\\begin{array}{c}L_{F} \\\\ W_{F} / 2 \\\\ 0\\end{array}\\right]=\\left[\\begin{array}{c}u \\\\ v \\\\ 0\\end{array}\\right]+\\left[\\begin{array}{ccc}0 & -\\Omega & 0 \\\\ \\Omega & 0 & 0 \\\\ 0 & 0 & 0\\end{array}\\right]\\left[\\begin{array}{c}L_{F} \\\\ W_{F} / 2 \\\\ 0\\end{array}\\right]=\\left[\\begin{array}{c}u-\\Omega W_{F} / 2 \\\\ v+\\Omega L_{F} \\\\ 0\\end{array}\\right]\\] where \\(\\left[P_{\\Omega}\\right]=\\left[R_{\\psi}\\right]^{-1}\\left[\\dot{R}_{\\psi}\\right]\\) . Besides, the front wheels are rotated by the steering angle. To consider it, the contact point velocity has to be projected in the wheel reference frame - \\(\\left[R_{\\delta_{F R}}\\right]\\) is the three-bythree matrix that describes the steering angle rotation around \\(\\mathrm{z}\\) -axis \\(-\\) . If the steering angle is small, the results can be linearized as follow. \\[ \\begin{gathered} V_{c F R}^{\\delta}=\\left[R_{\\delta_{F R}}\\right]^{-1} V_{c F R} \\approx\\left[\\begin{array}{c} \\left(u+\\Omega W_{F} / 2\\right)+\\left(v+\\Omega L_{F}\\right) \\delta_{F R} \\\\ -\\left(u+\\Omega W_{F} / 2\\right) \\delta_{F R}+\\left(v+\\Omega L_{F}\\right) \\\\ 0 \\end{array}\\right] \\\\ V_{c F L}^{\\delta}=\\left[R_{\\delta_{F L}}\\right]^{-1} V_{c F L} \\approx\\left[\\begin{array}{c} \\left(u-\\Omega W_{F} / 2\\right)+\\left(v+\\Omega L_{F}\\right) \\delta_{F L} \\\\ -\\left(u-\\Omega W_{F} / 2\\right) \\delta_{F L}+\\left(v+\\Omega L_{F}\\right) \\\\ 0 \\end{array}\\right] \\\\ V_{c R R}^{\\delta}=V_{c R R} \\quad=V_{c R L}^{\\delta} \\end{gathered} \\] Moreover, the term \\(v \\cdot \\delta\\) can be neglected because it is usually small. This further simplifies the notation. The slip computation uses these final results \\(\\left(V_{c i j}^{\\delta}\\right)\\) to evaluate the slips. The x-component of the velocity vectors is called \\(u_{c o r r}\\left(u_{c o r r, i j}=V_{c i j}^{\\delta}(1)\\right)\\) while the ycomponent of them is labelled with \\(v_{\\text {corr }}\\left(v_{c o r r, i j}=V_{c i j}^{\\delta}(2)\\right)\\) . Slips Estimation The longitudinal slip is very sensitive to the noise. For this reason, the input data has to be properly cleaned to be used. Moreover, for the slip computation, especially for the longitudinal one, a good estimation of the longitudinal velocity are necessary for the reliability of the measure. This is because the longitudinal slip compares two quantities that can be very similar to each other and a small error in the velocity reconstruction can generate significant errors on the slip value. Beyond this premise, if a reliable longitudinal speed estimation has already performed, the slip computation results simple. The slip formulation is reported in relation 29 considering also the smooth function definition, described in expression ??. \\[ \\lambda= \\begin{cases}\\left(\\omega R-u_{\\text {corr }}\\right) / u_{\\text {corr }} & \\text { if }\\left|u_{\\text {corr }}\\right|>V_{\\text {low }} \\\\ \\left(\\omega R-u_{\\text {corr }}\\right) /\\left[\\frac{1}{2}\\left(V_{\\text {low }}+\\frac{u_{\\text {corr }}^{2}}{V_{\\text {low }}}\\right)\\right] & \\text { if }\\left|u_{\\text {corr }}\\right| \\leq V_{\\text {low }}\\end{cases} \\] The lateral slip, instead, is defined as the arctangent of \\(v_{\\text {corr }} / u_{\\text {corr }}\\) . Since the lateral slip is usually small, the definition can be linearized. Also, in this case, the smooth function is used to avoid the denominator annulment. \\[ \\alpha= \\begin{cases}-v_{\\text {corr }} / u_{\\text {corr }} & \\text { if }\\left|u_{\\text {corr }}\\right|>V_{\\text {low }} \\\\ -v_{\\text {corr }} /\\left[\\frac{1}{2}\\left(V_{\\text {low }}+\\frac{u_{\\text {corr }}^{2}}{V_{\\text {low }}}\\right)\\right] & \\text { if }\\left|u_{\\text {corr }}\\right| \\leq V_{\\text {low }}\\end{cases} \\] From expression 30, substituting the value of \\(u_{\\text {corr }}\\) and \\(v_{\\text {corr }}\\) , some observation can be done. Since the value of yaw rate is small - usually \\(|\\Omega|<0.5,|\\Omega \\mathrm{W} / 2| \\ll u\\) - and the value of the steering angle is generally under \\(10^{\\circ}\\) , the slip definition can be even more simplified until reaching the axle slip notation, described in the following relation. \\[ \\begin{gathered} \\alpha_{R} \\simeq \\alpha_{R R} \\simeq \\alpha_{R L} \\simeq-\\frac{v}{u}+L_{R} \\frac{\\Omega}{u} \\\\ \\alpha_{F} \\simeq \\alpha_{F R} \\simeq \\alpha_{F L} \\simeq \\delta_{F}-\\frac{v}{u}-L_{F} \\frac{\\Omega}{u} \\end{gathered} \\] where \\(\\delta_{F}\\) is the mean of the right and left steering angle. Also here the smooth function has to be used to avoid the denominator annulment.","title":"Tire Slips Estimation"},{"location":"data-analysis-DMT/Estimation%20Functions/D.Tire-Slips-Estimation/#tire-slips-estimation","text":"The slip computation procedure is a kinematic based estimation that needs to know in detail the vehicle kinematics on the ground plane. This knowledge, coupled with the knowledge about the wheel spin, allows identifying the tire slips. For this reason, the results of the kinematic based estimator aforementioned are used in this computation. The practical slip definition is taken as a reference - expression ?? -","title":"Tire Slips Estimation"},{"location":"data-analysis-DMT/Estimation%20Functions/D.Tire-Slips-Estimation/#tire-contact-points-velocities","text":"Before talking in details about the slip estimation, some considerations about the vehicle planar velocity has to be done. This allows us to compute the wheels contact points speed that are used in the slips computation. Let us define as \\(P_{0}\\) the projection of the vehicle centre of mass on the ground plane: the wheel contact point \\(\\left(P_{c i j}\\right)\\) are defined as follow. \\[ \\begin{array}{cc} P_{c R R}=P_{0}+\\left[R_{\\psi}\\right]\\left[\\begin{array}{c} -L_{R} \\\\ -W_{R} / 2 \\\\ 0 \\end{array}\\right] & P_{c R L}=P_{0}+\\left[R_{\\psi}\\right]\\left[\\begin{array}{c} -L_{R} \\\\ W_{R} / 2 \\\\ 0 \\end{array}\\right] \\\\ P_{c F R}=P_{0}+\\left[R_{\\psi}\\right]\\left[\\begin{array}{c} L_{F} \\\\ -W_{R} / 2 \\\\ 0 \\end{array}\\right] & P_{c F L}=P_{0}+\\left[R_{\\psi}\\right]\\left[\\begin{array}{c} L_{F} \\\\ W_{R} / 2 \\\\ 0 \\end{array}\\right] \\end{array} \\] where \\(\\left[R_{\\psi}\\right]\\) is the three-by-three matrix that describes the yaw rotation. The velocity of the contact points are found deriving \\(P_{c i j}\\) . In order to write the velocities in a suitable form, they are projected in the vehicle frame \\(-V_{c i j}=\\left[R_{\\psi}\\right]^{-1} \\dot{P}_{c i j}-\\) . \\[ \\begin{gathered} V_{c R R}=\\left[R_{\\psi}\\right]^{-1} \\dot{P}_{0}+\\left[P_{\\Omega}\\right]\\left[\\begin{array}{c} -L_{R} \\\\ -W_{R} / 2 \\\\ 0 \\end{array}\\right]=\\left[\\begin{array}{c} u \\\\ v \\\\ 0 \\end{array}\\right]+\\left[\\begin{array}{ccc} 0 & -\\Omega & 0 \\\\ \\Omega & 0 & 0 \\\\ 0 & 0 & 0 \\end{array}\\right]\\left[\\begin{array}{c} -L_{R} \\\\ -W_{R} / 2 \\\\ 0 \\end{array}\\right]=\\left[\\begin{array}{c} u+\\Omega W_{R} / 2 \\\\ v-\\Omega L_{R} \\\\ 0 \\end{array}\\right] \\\\ V_{c R L}=\\left[R_{\\psi}\\right]^{-1} \\dot{P}_{0}+\\left[P_{\\Omega}\\right]\\left[\\begin{array}{c} -L_{R} \\\\ W_{R} / 2 \\\\ 0 \\end{array}\\right]=\\left[\\begin{array}{l} u \\\\ v \\\\ 0 \\end{array}\\right]+\\left[\\begin{array}{ccc} 0 & -\\Omega & 0 \\\\ \\Omega & 0 & 0 \\\\ 0 & 0 & 0 \\end{array}\\right]\\left[\\begin{array}{c} -L_{R} \\\\ W_{R} / 2 \\\\ 0 \\end{array}\\right]=\\left[\\begin{array}{c} u-\\Omega W_{R} / 2 \\\\ v-\\Omega L_{R} \\\\ 0 \\end{array}\\right] \\\\ V_{c F R}=\\left[R_{\\psi}\\right]^{-1} \\dot{P}_{0}+\\left[P_{\\Omega}\\right]\\left[\\begin{array}{c} L_{F} \\\\ -W_{F} / 2 \\\\ 0 \\end{array}\\right]=\\left[\\begin{array}{l} u \\\\ v \\\\ 0 \\end{array}\\right]+\\left[\\begin{array}{ccc} 0 & -\\Omega & 0 \\\\ \\Omega & 0 & 0 \\\\ 0 & 0 & 0 \\end{array}\\right]\\left[\\begin{array}{c} L_{F} \\\\ -W_{F} / 2 \\\\ 0 \\end{array}\\right]=\\left[\\begin{array}{c} u+\\Omega W_{F} / 2 \\\\ v+\\Omega L_{F} \\\\ 0 \\end{array}\\right] \\end{gathered} \\] \\[V_{c F L}=\\left[R_{\\psi}\\right]^{-1} \\dot{P}_{0}+\\left[P_{\\Omega}\\right]\\left[\\begin{array}{c}L_{F} \\\\ W_{F} / 2 \\\\ 0\\end{array}\\right]=\\left[\\begin{array}{c}u \\\\ v \\\\ 0\\end{array}\\right]+\\left[\\begin{array}{ccc}0 & -\\Omega & 0 \\\\ \\Omega & 0 & 0 \\\\ 0 & 0 & 0\\end{array}\\right]\\left[\\begin{array}{c}L_{F} \\\\ W_{F} / 2 \\\\ 0\\end{array}\\right]=\\left[\\begin{array}{c}u-\\Omega W_{F} / 2 \\\\ v+\\Omega L_{F} \\\\ 0\\end{array}\\right]\\] where \\(\\left[P_{\\Omega}\\right]=\\left[R_{\\psi}\\right]^{-1}\\left[\\dot{R}_{\\psi}\\right]\\) . Besides, the front wheels are rotated by the steering angle. To consider it, the contact point velocity has to be projected in the wheel reference frame - \\(\\left[R_{\\delta_{F R}}\\right]\\) is the three-bythree matrix that describes the steering angle rotation around \\(\\mathrm{z}\\) -axis \\(-\\) . If the steering angle is small, the results can be linearized as follow. \\[ \\begin{gathered} V_{c F R}^{\\delta}=\\left[R_{\\delta_{F R}}\\right]^{-1} V_{c F R} \\approx\\left[\\begin{array}{c} \\left(u+\\Omega W_{F} / 2\\right)+\\left(v+\\Omega L_{F}\\right) \\delta_{F R} \\\\ -\\left(u+\\Omega W_{F} / 2\\right) \\delta_{F R}+\\left(v+\\Omega L_{F}\\right) \\\\ 0 \\end{array}\\right] \\\\ V_{c F L}^{\\delta}=\\left[R_{\\delta_{F L}}\\right]^{-1} V_{c F L} \\approx\\left[\\begin{array}{c} \\left(u-\\Omega W_{F} / 2\\right)+\\left(v+\\Omega L_{F}\\right) \\delta_{F L} \\\\ -\\left(u-\\Omega W_{F} / 2\\right) \\delta_{F L}+\\left(v+\\Omega L_{F}\\right) \\\\ 0 \\end{array}\\right] \\\\ V_{c R R}^{\\delta}=V_{c R R} \\quad=V_{c R L}^{\\delta} \\end{gathered} \\] Moreover, the term \\(v \\cdot \\delta\\) can be neglected because it is usually small. This further simplifies the notation. The slip computation uses these final results \\(\\left(V_{c i j}^{\\delta}\\right)\\) to evaluate the slips. The x-component of the velocity vectors is called \\(u_{c o r r}\\left(u_{c o r r, i j}=V_{c i j}^{\\delta}(1)\\right)\\) while the ycomponent of them is labelled with \\(v_{\\text {corr }}\\left(v_{c o r r, i j}=V_{c i j}^{\\delta}(2)\\right)\\) .","title":"Tire Contact Points Velocities"},{"location":"data-analysis-DMT/Estimation%20Functions/D.Tire-Slips-Estimation/#slips-estimation","text":"The longitudinal slip is very sensitive to the noise. For this reason, the input data has to be properly cleaned to be used. Moreover, for the slip computation, especially for the longitudinal one, a good estimation of the longitudinal velocity are necessary for the reliability of the measure. This is because the longitudinal slip compares two quantities that can be very similar to each other and a small error in the velocity reconstruction can generate significant errors on the slip value. Beyond this premise, if a reliable longitudinal speed estimation has already performed, the slip computation results simple. The slip formulation is reported in relation 29 considering also the smooth function definition, described in expression ??. \\[ \\lambda= \\begin{cases}\\left(\\omega R-u_{\\text {corr }}\\right) / u_{\\text {corr }} & \\text { if }\\left|u_{\\text {corr }}\\right|>V_{\\text {low }} \\\\ \\left(\\omega R-u_{\\text {corr }}\\right) /\\left[\\frac{1}{2}\\left(V_{\\text {low }}+\\frac{u_{\\text {corr }}^{2}}{V_{\\text {low }}}\\right)\\right] & \\text { if }\\left|u_{\\text {corr }}\\right| \\leq V_{\\text {low }}\\end{cases} \\] The lateral slip, instead, is defined as the arctangent of \\(v_{\\text {corr }} / u_{\\text {corr }}\\) . Since the lateral slip is usually small, the definition can be linearized. Also, in this case, the smooth function is used to avoid the denominator annulment. \\[ \\alpha= \\begin{cases}-v_{\\text {corr }} / u_{\\text {corr }} & \\text { if }\\left|u_{\\text {corr }}\\right|>V_{\\text {low }} \\\\ -v_{\\text {corr }} /\\left[\\frac{1}{2}\\left(V_{\\text {low }}+\\frac{u_{\\text {corr }}^{2}}{V_{\\text {low }}}\\right)\\right] & \\text { if }\\left|u_{\\text {corr }}\\right| \\leq V_{\\text {low }}\\end{cases} \\] From expression 30, substituting the value of \\(u_{\\text {corr }}\\) and \\(v_{\\text {corr }}\\) , some observation can be done. Since the value of yaw rate is small - usually \\(|\\Omega|<0.5,|\\Omega \\mathrm{W} / 2| \\ll u\\) - and the value of the steering angle is generally under \\(10^{\\circ}\\) , the slip definition can be even more simplified until reaching the axle slip notation, described in the following relation. \\[ \\begin{gathered} \\alpha_{R} \\simeq \\alpha_{R R} \\simeq \\alpha_{R L} \\simeq-\\frac{v}{u}+L_{R} \\frac{\\Omega}{u} \\\\ \\alpha_{F} \\simeq \\alpha_{F R} \\simeq \\alpha_{F L} \\simeq \\delta_{F}-\\frac{v}{u}-L_{F} \\frac{\\Omega}{u} \\end{gathered} \\] where \\(\\delta_{F}\\) is the mean of the right and left steering angle. Also here the smooth function has to be used to avoid the denominator annulment.","title":"Slips Estimation"},{"location":"data-analysis-DMT/Estimation%20Functions/E.Tire-Force-Estimation/","text":"Tire Force Estimation Now, the tire force estimator can be presented. However, before talking about the out-and-out estimators, the torque at the wheels has to be computed. Wheels Torque Estimation The wheel torque is the sum of the motor and the braking torque. For what concerns the motor torque, it is measured by the inverters and it is reported to the wheel torque by a simple multiplication by the reduction rate and the reducer efficiency (look at equation ??). The braking torque, instead, is not directly measured. The available measure is on the pressure of the braking oil circuits \\(\\left(P_{s}\\right)\\) , different for the front and the rear. Having this pressure, an analysis regarding the braking system must be done. Firstly, the braking system configuration must be known. In the vehicle, the CRG V04 brake callipers are mounted, with four pistons having a diameter \\(\\phi_{P}=26 \\mathrm{~mm}\\) . The main dimensions of the callipers are shown in figure 12. Secondly, the force that the pads generate perpendicular to the braking disk \\(\\left(F_{p}\\right)\\) can be computed using equation 33. where \\(n\\) is the number of pistons in the calliper and \\(A_{p}\\) is the pistons area. \\[ F_{p}=\\frac{P_{s} A_{p} n}{2}=\\frac{P_{s} \\pi \\phi_{p}^{2} n}{8} \\] Finally, having the perpendicular force, it is possible to compute the maximum friction force acting on the disk, hence, also the maximum braking torque. \\[ T_{b, \\text { Max }}=2 F_{p} \\mu_{s} b=\\frac{P_{s} \\pi \\phi_{p}^{2} n}{4} \\mu_{s} b \\] where \\(\\mu_{s}\\) is the friction coefficient between the disk and the pads - it is assumed to be equal to \\(0.42\\) - and \\(b\\) is the friction force arm, indicated in figure 12 . A threshold value has to be set in the measured pressure for the two circuits. This pressure is needed to overcome the pistons spring resistance. Tire Longitudinal Force via Dynamical Equation Once the wheel torques are computed, the tire forces can be estimated starting from them. The tire forces estimation problem is divided into three main sub-problems: longitudinal, lateral and vertical force estimation. In this section, some methods are introduced to solve these. Let's start talking about the longitudinal force \\(\\left(F_{x}\\right)\\) . The simpler way to estimate the longitudinal force is to use the wheel spin dynamics equation - equation ?? -. In this way, the longitudinal tyre forces are the results of a simple open-loop computation. However, this computation can discard some unmodelled effects. Besides, it includes the numerical derivation of the wheel speed. This means that this data has to be strongly \"cleaned\" in order to avoid numerical noise generation in the derivative computation. However, if the wheel speed data is sufficiently filtered, the open-loop force computation can give a sufficiently good approximation of the real tire forces, at least in acceleration. \\[ I_{a, W} \\dot{\\omega}(t)=T_{w, m o t}-T_{w, b r k}-F_{x} R \\] where \\(I_{a, W}\\) is the wheel spin inertia, \\(T_{w}\\) is the wheel torque due to motor (mot) and bracking (brk) and \\(R\\) is the wheel radius. Axle Lateral Force via Steady-State Analysis For what concerns the lateral force estimation \\(\\left(F_{y}\\right)\\) , at this stage, it is impossible to have a lateral force value for the four wheels. This because, without sufficient vehicle knowledge, there are no descriptions for the single tire lateral dynamics. Therefore, our analysis focuses on the lateral axles forces. The simplest way to estimate these forces is to remains in the steady-state condition - relation 37 - . This is a strong assumption but, in practice, the steady-state results can give a good approximation of the real axle forces. \\[ \\left\\{\\begin{array}{l} F_{y R}=M a_{y} \\frac{L_{F}}{L} \\\\ F_{y F}=M a_{y} \\frac{L_{R}}{L} \\end{array}\\right. \\] where \\(M\\) is the whole vehicle mass, \\(a_{y}\\) is the lateral acceleration, \\(L\\) is the vehicle wheelbase and \\(L_{F}\\) and \\(L_{R}\\) is the CoM distance from the front and the rear axle respectively. Even if the steady-state description gives a good level of accuracy, it can be expanded considering also the yaw moments \\(\\left(M_{z}\\right)\\) generated by a differential wheel torque, by the self-aligning torque or by the yaw-rate variation \\((\\dot{\\Omega})\\) . \\[ \\left\\{\\begin{array}{l} F_{y R}=M a_{y} \\frac{L_{F}}{L}-\\frac{M_{z, t o t}}{L} \\\\ F_{y F}=M a_{y} \\frac{L_{R}}{L}+\\frac{M_{z, t o t}}{L} \\end{array}\\right. \\] Since the self-aligning torques are difficult to be measured with the employed sensors, their effects are neglected. However, the differential torque and the yaw-rate variation are still considered. \\[ M_{z, \\text { tot }}=\\left(F_{x R R}-F_{x R L}\\right) W_{R}+\\left(F_{x F R}-F_{x F L}\\right) W_{F}-I_{z z, V} \\dot{\\Omega} \\] Vertical Tire Load via Load Transfer The vertical load can be computed using the load transfer theory, presented in relations ?? and ??. As already said, this convention divides the vertical forces into two main contributes: the fist one contains the static and the aerodynamic forces and the longitudinal load transfer; the second one includes the lateral load transfer. \\[ \\begin{gathered} \\left\\{\\begin{array}{l} F_{z R R}=F_{z R} / 2+\\Delta F_{z R} \\\\ F_{z R L}=F_{z R} / 2-\\Delta F_{z R} \\\\ F_{z F R}=F_{z F} / 2+\\Delta F_{z F} \\\\ F_{z F L}=F_{z F} / 2-\\Delta F_{z F} \\end{array}\\right. \\\\ F_{z R}=M g \\frac{L_{F}}{L}+M a_{x} \\frac{h_{G s}}{L}+\\left|F_{z A R}\\right| \\quad \\Delta F_{z R}=F_{y R} \\frac{h_{R R}}{W_{R}}+\\frac{K_{\\phi R}}{W_{R}} \\phi \\\\ F_{z F}=M g \\frac{L_{R}}{L}-M a_{x} \\frac{h_{G s}}{L}+\\left|F_{z A F}\\right| \\quad \\Delta F_{z F}=F_{y F} \\frac{h_{R F}}{W_{F}}+\\frac{K_{\\phi F}}{W_{F}} \\phi \\end{gathered} \\] As far as the aerodynamic force contribute, they are computed according to equation ?? - \\(F_{z A R}=C_{A z R} u^{2}\\) and \\(F_{z A F}=C_{A z F} u^{2}-\\) -. The aerodynamic coefficients are extrapolated thanks to aerodynamic simulation. Their values are reported in table 5 . \\(C_{A x}\\) \\(C_{A z F}\\) \\(C_{A z R}\\) \\(1.56\\) \\(0.64\\) \\(0.92\\) Table 5: Aerodynamic coefficients - \\(N s^{2} / \\mathrm{m}^{2}\\) The lateral forces are computed using the expression 38 that consider also the transient yaw contribute. The roll angle \\(\\phi\\) , instead, is computed using the steady-state formulation. It involves the roll stiffness \\(\\left(K_{\\phi}\\right)\\) definition in order to evaluate the roll angle. \\[ \\phi=M a_{y} \\frac{h_{G s}}{K_{\\phi F}+K_{\\phi R}} \\] where the roll stiffnesses are a function of the total suspension/tire stiffness \\(\\left(K_{z}\\right)\\) . This stiffness is computed as a spring series. This is an approximation but this method is shown valid for simulation. Then, the roll stiffness can be defined as follow: \\[ K_{z}=\\frac{1}{\\frac{1}{K_{z}^{S}}+\\frac{1}{K_{z}^{T}}} \\quad K_{\\phi i}=K_{z i} \\frac{W_{i}^{2}}{2}, \\quad i=\\{F, R\\} \\] Also, the pitch angle \\(\\theta\\) can be estimated in steady-state using the definition of Anti-Dive \\((A D)\\) , Anti-Lift \\((A L)\\) and Anti-Squat \\((A S)\\) coefficients. These coefficients determine how much of the longitudinal load transfer is adsorbed by the suspension structure and how much by the suspension deformation. Anti-Dive reefers to the front suspensions, Anti-Lift and Anti-Squat to the rear ones depending on the condition of the suspensions: stretching or compressing. The computation of the pitch angle is reported in relation 40 . \\[ \\theta=\\frac{\\Delta z_{R}-\\Delta z_{F}}{L} \\] where \\[ \\Delta z_{R}=\\left\\{\\begin{array}{ll} -M \\frac{h_{G s}}{L} \\frac{a_{x}}{K_{z F}}(1-A S) & \\text { if } a_{x} \\geq 0 \\\\ -M \\frac{h_{G s}}{L} \\frac{a_{x}}{K_{z F}}(1-A L) & \\text { if } a_{x}<0 \\end{array} \\quad ; \\quad \\Delta z_{F}=M \\frac{h_{G s}}{L} \\frac{a_{x}}{K_{z F}}(1-A D)\\right. \\] Longitudinal and Lateral Force via S-SOSM and KF An alternative method for the longitudinal and lateral force estimation is the combination of a Suboptimal-Second Order Sliding Mode (S-SOSM) observer and a Kalman filter, presented in [17] and used also in [21]. The S-SOSM is used as a virtual sensor for the force estimation while the Kalman filter is used to smooth the observer output. The S-SOSM-based force observer is divided into three main parts: longitudinal force observer, lateral force observer and wheel torque adaption. Longitudinal Tire Force Observer The longitudinal force \\(\\left(F_{x i j}\\right)\\) observer is based on a slightly modified version of the wheel rotation dynamic equation (??) which includes a correcting term \\(\\left(\\Delta \\hat{T}_{i j}\\right)\\) (see 41 . \\[ I_{a, W} \\dot{\\hat{\\omega}}_{i j}=T_{w i j}-\\Delta \\hat{T}_{i j}-R u_{x i j} \\] where \\(\\hat{\\omega}_{i j}\\) is the wheel speed obtained from the observer evolution and \\(u_{x i j}\\) is the observer output and corresponds to the estimated longitudinal force \\(\\left(\\hat{F}_{x i j}^{S M}\\right)\\) . The measured and the observed wheel speed are used to generate a sliding surface \\(\\left(\\sigma_{x i j}=\\omega_{i j}-\\hat{\\omega}_{i j}\\right)\\) in which the SOSM is developed. The observer input law is reported in relation 42 . \\[ u_{x i j}=-\\int K_{x} \\operatorname{sign}\\left(\\sigma_{x i j}-\\frac{\\sigma_{x, M a x}}{2}\\right) d t \\] \\(\\sigma_{x, \\text { Max }}\\) is the value in of \\(\\sigma_{x}\\) in the last time instant and \\(K_{x}\\) is a tunable gain. Using expression 41 with the input law 42 , the wheel spin derivatives can be found without any numerical derivation. Then, the observed wheel speed can be found integrating the \\(\\dot{\\hat{\\omega}}_{i j}\\) . Lateral Axle Force Observer In this case, only one sliding mode observer is sufficient, that aims to estimate the front or the rear axle force. The non-estimated axle force is computed using the lateral equilibrium \\(-M a_{y}=F_{y F[v]}+F_{y R[v]}\\) where the indicator \\([v]\\) means that the forces are projected in the vehicle reference frame \\(-\\) . The sliding surface is now based on the yaw-rate dynamic equation - expression 43 - written around the front axle centre point and the sliding surface is defined as the difference between the measured yaw rate and the estimated one \\(\\left(\\sigma_{y}=\\Omega-\\hat{\\Omega}\\right)\\) . \\[ I_{z z, V} \\dot{\\hat{\\Omega}}=L_{F} M a_{y}-L u_{y}+\\frac{W_{F}}{2} \\Delta \\hat{F}_{x F[v]}^{S M}+\\frac{W_{R}}{2} \\Delta \\hat{F}_{x R[v]}^{S M} \\] In the reported formulation, \\(u_{y}\\) is the input law that corresponds to the estimated rear lateral axle force in the vehicle reference frame \\(\\left(F_{y R[v]}^{S M}\\right)\\) . The terms \\(\\Delta \\hat{F}_{x j[v]}\\) corresponds to the difference between the left and the right tire forces and is the cause of a yaw moment. In order to compute these terms, the force projection in the vehicle RF must occur. \\[ \\Delta \\hat{F}_{x F[v]}^{S M}=\\hat{F}_{x F R}^{S M} \\cos \\left(\\delta_{F R}\\right)-\\hat{F}_{x F L}^{S M} \\cos \\left(\\delta_{F L}\\right) \\quad ; \\quad \\Delta \\hat{F}_{x R[v]}^{S M}=\\hat{F}_{x R R}^{S M}-\\hat{F}_{x R L}^{S M} \\] The input law, in this case, is \\[ u_{y}=-\\int K_{y} \\operatorname{sign}\\left(\\sigma_{y}-\\frac{\\sigma_{y, M a x}}{2}\\right) d t \\] Wheel torque adaption The correction term introduced in the expression 41 is a Proportional-Integral (PI) adaptive law which considers the longitudinal error dynamics. \\[ \\Delta \\hat{T}=K_{P} e_{F_{x}}+K_{I} \\int e_{F_{x}} d t \\] The error-dynamics is computed using the deviation from the longitudinal equilibrium \\(-M a_{x}=\\sum F_{x}-\\) \\[ e_{F_{x}}=\\left(\\sum_{i j} \\hat{F}_{x i j[v]}^{S M}-F_{\\text {Res }}\\right)-M a_{x} \\] where \\(F_{\\text {Res }}\\) is the sum of all the resistance forces - for example, aerodynamic drag and rolling resistance effects - and \\(\\hat{F}_{x i j[v]}^{S M}\\) are the longitudinal tire forces, which are computed as follow. \\[ \\begin{gathered} \\hat{F}_{x F R[v]}^{S M}+\\hat{F}_{x F L[v]}^{S M}=\\hat{F}_{x F R}^{S M} \\cos \\left(\\delta_{F R}\\right)+\\hat{F}_{x F L}^{S M} \\cos \\left(\\delta_{F L}\\right)-\\hat{F}_{y F[v]}^{S M} \\tan \\left[\\frac{\\delta_{F R}+\\delta_{F L}}{2}\\right] \\\\ \\hat{F}_{x R R[v]}^{S M}=\\hat{F}_{x R R}^{S M} \\quad \\hat{F}_{x R L[v]}^{S M}=\\hat{F}_{x R L}^{S M} \\end{gathered} \\] The total \\(\\Delta \\hat{T}\\) term, obtained by equation 45 , is split among the four wheels depending on the driving situation. Moreover, if a negligible torque is applied to a specific wheel, the torque correction is null. For a rear-wheel-driven vehicle, the torque splitting is the following. \\[ \\begin{aligned} & \\text { Front wheels: } \\Delta \\hat{T}_{F j}=\\left\\{\\begin{array}{lll} 0 & \\text { if } a_{x}>a_{t h} & \\text { (Acceleration) } \\\\ \\Delta \\hat{T} \\frac{F_{z F j}}{M g} & \\text { if }\\left|a_{x}\\right|<a_{t h} & \\text { (Coasting) } \\\\ \\Delta \\hat{T} \\frac{F_{z F j}}{M g} \\epsilon_{b r k} & \\text { if } a_{x}<-a_{t h} & \\text { (Braking) } \\end{array}\\right. \\\\ & \\text { Rear wheels: } \\Delta \\hat{T}_{R j}=\\left\\{\\begin{array}{lll} \\Delta \\hat{T} \\frac{F_{z R j}}{F_{z R R}+F_{z R L}} & \\text { if } a_{x}>a_{t h} & \\text { (Acceleration) } \\\\ \\Delta \\hat{T} \\frac{F_{z R j}}{M g} & \\text { if }\\left|a_{x}\\right|<a_{t h} & \\text { (Coasting) } \\\\ \\Delta \\hat{T} \\frac{F_{z R j}}{M g}\\left(1-\\epsilon_{b r k}\\right) & \\text { if } a_{x}<-a_{t h} & \\text { (Braking) } \\end{array}\\right. \\end{aligned} \\] where the vertical forces are computed according to ?? and \\(\\epsilon_{b r k}\\) is the front braking balance, i.e. it said how much braking torque is applied at the front with respect to the total one - in our case, it is equal to \\(0.6\\) -. \\(a_{t h}\\) is a threshold acceleration that is set equal to \\(0.5 \\mathrm{~m} / \\mathrm{s}^{2}\\) in our case. Kalman Filter Smoothing The observer outputs are taken as input from an Extended Kalman filter. The implemented here Kalman filter is based on the wheel spin equations - equation ?? - and on the vehicle yaw dynamics around the centre point of the front axle - already used in \\(43-\\) The filter states, collected in the vector \\(x\\) , are indicated with the hat only, while the outputs of the observer have the hat indicator and the superscript \"SM\". The measured quantities and the data do not have any indicator. \\[ \\begin{gathered} \\dot{\\omega}_{i j}=\\frac{T_{w i j}-\\hat{F}_{x i j} R}{I_{a, W}} \\\\ \\dot{\\Omega}=\\frac{L_{F} M \\hat{a}_{y}-L \\hat{F}_{y R}+\\frac{W_{R}}{2}\\left(\\hat{F}_{x R R}-\\hat{F}_{x R L}\\right)+\\frac{W_{F}}{2}\\left(\\hat{F}_{x F R}-\\hat{F}_{x F L}\\right) \\cos \\left(\\delta_{F}\\right)}{I_{z z, V}} \\end{gathered} \\] The vector \\(z\\) collects the set of all the measures, virtual or not, and the vector \\(u\\) contains the system inputs. \\[ \\begin{aligned} {x} & =\\left[\\hat{F}_{x i j}, \\hat{F}_{y R}, \\hat{a}_{y}, \\hat{\\omega}_{i j}, \\hat{\\Omega}\\right] \\\\ {z} & =\\left[\\hat{F}_{x i j}^{S M}, \\hat{F}_{y R}^{S M}, a_{y}, \\omega_{i j}, \\Omega\\right] \\\\ {u} & =\\left[T_{w i j}, \\delta_{F}\\right] \\end{aligned} \\] \\(\\delta_{F}\\) is the mean of the left and right steering angle. The process and output evolution are vectorial functions reported in 49 . The process and measurement noise ( \\(v\\) and \\(w\\) ) are assumed to be zero-mean and normal distributed with covariance matrices equal to \\(Q\\) and \\(R\\) respectively - \\(v \\sim N(0, Q)\\) and \\(w \\backsim N(0, R)\\) -. The measurement vector and the state vector contain the same quantities. For this reason, deriving the function \\(h(\\cdot)\\) with respect to the state, the identity matrix will return \\((H=I)\\) . \\[ \\dot{x}=f( {x}, {u}, {v}) \\quad ; \\quad z=h( {x}, {u}, {w}) \\] The matrix \\(F\\) is obtained deriving the function \\(f(\\cdot)\\) with respect to the system states. \\[ F_{k}=\\left.\\frac{\\partial f}{\\partial x}\\right|_{\\hat{x}_{k-1 \\mid k-1}}=\\left[\\begin{array}{cc} 0 & 0 \\\\ F_{21} & 0 \\end{array}\\right] \\] where \\[ F_{21}=\\left[\\begin{array}{cccccc} -\\frac{R}{I_{a, W}} & 0 & 0 & 0 & 0 & 0 \\\\ 0 & -\\frac{R}{I_{a, W}} & 0 & 0 & 0 & 0 \\\\ 0 & 0 & -\\frac{R}{I_{a, W}} & 0 & 0 & 0 \\\\ 0 & 0 & 0 & -\\frac{R}{I_{a, W}} & 0 & 0 \\\\ \\frac{W_{R}}{2 I_{a, W}} & -\\frac{W_{R}}{2 I_{a, W}} & \\frac{W_{F}}{2 I_{a, W}} \\cos \\left(\\delta_{F}\\right) & -\\frac{W_{R}}{2 I_{a, W}} \\cos \\left(\\delta_{F}\\right) & -\\frac{L}{I_{a, W}} & \\frac{L_{F} M}{I_{a, W}} \\end{array}\\right] \\] This algorithm has to be properly tuned to have good performances. The tuning procedure is performed by means of trial and error approach starting from the values proposed in [21]. The optimized values can be found in table 6 \\(K_{x}\\) \\(K_{y}\\) \\(\\sigma_{x / y, ext { Max }}\\) \\(K_{P}\\) \\(K_{I}\\) \\(3 \\cdot 10^{5}\\) \\(3 \\cdot 10^{5}\\) 0 \\(5 \\cdot 10^{-2}\\) \\(1 \\cdot 10^{-3}\\) \\(Q_{F_{x}}\\) \\(Q_{F_{y}}\\) \\(Q_{a_{y}}\\) \\(Q_{\\omega}\\) \\(Q_{\\Omega}\\) \\(26.03\\) \\(7.68\\) \\(8.93\\) \\(93.28\\) \\(77.86\\) \\(R_{F_{x}}\\) \\(R_{F_{y}}\\) \\(R_{a_{y}}\\) \\(R_{\\omega}\\) \\(R_{\\Omega}\\) 600 500 \\(0.785\\) \\(0.1\\) \\(4 \\cdot 10^{-2}\\) Table 6: Parameters for the S-SOSM observer with EKF enhancement A high value for the parameters \\(K_{x / y}\\) allows us to have a faster convergence to the actual value but it causes chattering in the force estimation. The Kalman filter sees the observer outputs as a noisy signal and it is able to clean the data avoiding the chattering. In this way, the observer gains can be high to favour a fast convergence rate. Algorithms Performances To conclude the analysis regarding force estimation, a qualitative performance analysis must be done. In particular, the results will be shown in two simulated pure conditions: using a simulated double throttle step, the performance of the longitudinal force estimators are highlighted while, with a simulated constant steering angle tests, the performances of the axle lateral force observers are illustrated. The vertical load are reported in both situations to see how the load transfer performs in both cases. Firstly, the acceleration results are considered. In figure 13, the longitudinal force estimations are reported in relation with the simulated data. The first thing that can be noticed is that for the front wheels, in which the force is low, an oscillation is present in the force estimation. This is the remaining part of the chattering due to the high gain of the observer. However, when the force value grows, this chattering is negligible. As we can see, the results using the wheel spin dynamical equations is enough similar to the output of the SOSM observer, that is a good approximation of the actual force. However, especially using the real telemetry data, the unmodelled effects can be high and the simpler estimation can be not reliable. Moreover, the numerical derivation of the wheel spin can generate numerical noise if the signal is not properly filtered. The load transfer results (figure 14) seems a good approximation of the real tire load. Figure 13: Longitudinal force estimation results - Acceleration case Figure 14: Vertical force estimation results - Acceleration case In figure 15 the lateral axles forces for a constant steering test are reported. The results of both the estimator are sufficiently good. However, it can be seen that the SOSM observer has a smaller estimation error. In addition, the computation of the yaw moment, in the standard estimation, involves the numerical derivation of the yaw rate. This can generate a lot of numerical noise when the estimation is done over the real telemetry data. Figure 15: Longitudinal force estimation results - Acceleration case Also in the turning case, the vertical load is well estimated from relation ??. The estimation shows the greatest difference with respect to the actual force in the last part of the test. In this part, the vehicle is subjected to a very high lateral acceleration - that generate a high roll -. The possible cause of this mismatch can be the approximation done in the roll stiffness case. Nevertheless, the maximum error is acceptable for our analysis. Figure 16: Vertical force estimation results - Acceleration case","title":"Tire Force Estimation"},{"location":"data-analysis-DMT/Estimation%20Functions/E.Tire-Force-Estimation/#tire-force-estimation","text":"Now, the tire force estimator can be presented. However, before talking about the out-and-out estimators, the torque at the wheels has to be computed.","title":"Tire Force Estimation"},{"location":"data-analysis-DMT/Estimation%20Functions/E.Tire-Force-Estimation/#wheels-torque-estimation","text":"The wheel torque is the sum of the motor and the braking torque. For what concerns the motor torque, it is measured by the inverters and it is reported to the wheel torque by a simple multiplication by the reduction rate and the reducer efficiency (look at equation ??). The braking torque, instead, is not directly measured. The available measure is on the pressure of the braking oil circuits \\(\\left(P_{s}\\right)\\) , different for the front and the rear. Having this pressure, an analysis regarding the braking system must be done. Firstly, the braking system configuration must be known. In the vehicle, the CRG V04 brake callipers are mounted, with four pistons having a diameter \\(\\phi_{P}=26 \\mathrm{~mm}\\) . The main dimensions of the callipers are shown in figure 12. Secondly, the force that the pads generate perpendicular to the braking disk \\(\\left(F_{p}\\right)\\) can be computed using equation 33. where \\(n\\) is the number of pistons in the calliper and \\(A_{p}\\) is the pistons area. \\[ F_{p}=\\frac{P_{s} A_{p} n}{2}=\\frac{P_{s} \\pi \\phi_{p}^{2} n}{8} \\] Finally, having the perpendicular force, it is possible to compute the maximum friction force acting on the disk, hence, also the maximum braking torque. \\[ T_{b, \\text { Max }}=2 F_{p} \\mu_{s} b=\\frac{P_{s} \\pi \\phi_{p}^{2} n}{4} \\mu_{s} b \\] where \\(\\mu_{s}\\) is the friction coefficient between the disk and the pads - it is assumed to be equal to \\(0.42\\) - and \\(b\\) is the friction force arm, indicated in figure 12 . A threshold value has to be set in the measured pressure for the two circuits. This pressure is needed to overcome the pistons spring resistance.","title":"Wheels Torque Estimation"},{"location":"data-analysis-DMT/Estimation%20Functions/E.Tire-Force-Estimation/#tire-longitudinal-force-via-dynamical-equation","text":"Once the wheel torques are computed, the tire forces can be estimated starting from them. The tire forces estimation problem is divided into three main sub-problems: longitudinal, lateral and vertical force estimation. In this section, some methods are introduced to solve these. Let's start talking about the longitudinal force \\(\\left(F_{x}\\right)\\) . The simpler way to estimate the longitudinal force is to use the wheel spin dynamics equation - equation ?? -. In this way, the longitudinal tyre forces are the results of a simple open-loop computation. However, this computation can discard some unmodelled effects. Besides, it includes the numerical derivation of the wheel speed. This means that this data has to be strongly \"cleaned\" in order to avoid numerical noise generation in the derivative computation. However, if the wheel speed data is sufficiently filtered, the open-loop force computation can give a sufficiently good approximation of the real tire forces, at least in acceleration. \\[ I_{a, W} \\dot{\\omega}(t)=T_{w, m o t}-T_{w, b r k}-F_{x} R \\] where \\(I_{a, W}\\) is the wheel spin inertia, \\(T_{w}\\) is the wheel torque due to motor (mot) and bracking (brk) and \\(R\\) is the wheel radius.","title":"Tire Longitudinal Force via Dynamical Equation"},{"location":"data-analysis-DMT/Estimation%20Functions/E.Tire-Force-Estimation/#axle-lateral-force-via-steady-state-analysis","text":"For what concerns the lateral force estimation \\(\\left(F_{y}\\right)\\) , at this stage, it is impossible to have a lateral force value for the four wheels. This because, without sufficient vehicle knowledge, there are no descriptions for the single tire lateral dynamics. Therefore, our analysis focuses on the lateral axles forces. The simplest way to estimate these forces is to remains in the steady-state condition - relation 37 - . This is a strong assumption but, in practice, the steady-state results can give a good approximation of the real axle forces. \\[ \\left\\{\\begin{array}{l} F_{y R}=M a_{y} \\frac{L_{F}}{L} \\\\ F_{y F}=M a_{y} \\frac{L_{R}}{L} \\end{array}\\right. \\] where \\(M\\) is the whole vehicle mass, \\(a_{y}\\) is the lateral acceleration, \\(L\\) is the vehicle wheelbase and \\(L_{F}\\) and \\(L_{R}\\) is the CoM distance from the front and the rear axle respectively. Even if the steady-state description gives a good level of accuracy, it can be expanded considering also the yaw moments \\(\\left(M_{z}\\right)\\) generated by a differential wheel torque, by the self-aligning torque or by the yaw-rate variation \\((\\dot{\\Omega})\\) . \\[ \\left\\{\\begin{array}{l} F_{y R}=M a_{y} \\frac{L_{F}}{L}-\\frac{M_{z, t o t}}{L} \\\\ F_{y F}=M a_{y} \\frac{L_{R}}{L}+\\frac{M_{z, t o t}}{L} \\end{array}\\right. \\] Since the self-aligning torques are difficult to be measured with the employed sensors, their effects are neglected. However, the differential torque and the yaw-rate variation are still considered. \\[ M_{z, \\text { tot }}=\\left(F_{x R R}-F_{x R L}\\right) W_{R}+\\left(F_{x F R}-F_{x F L}\\right) W_{F}-I_{z z, V} \\dot{\\Omega} \\]","title":"Axle Lateral Force via Steady-State Analysis"},{"location":"data-analysis-DMT/Estimation%20Functions/E.Tire-Force-Estimation/#vertical-tire-load-via-load-transfer","text":"The vertical load can be computed using the load transfer theory, presented in relations ?? and ??. As already said, this convention divides the vertical forces into two main contributes: the fist one contains the static and the aerodynamic forces and the longitudinal load transfer; the second one includes the lateral load transfer. \\[ \\begin{gathered} \\left\\{\\begin{array}{l} F_{z R R}=F_{z R} / 2+\\Delta F_{z R} \\\\ F_{z R L}=F_{z R} / 2-\\Delta F_{z R} \\\\ F_{z F R}=F_{z F} / 2+\\Delta F_{z F} \\\\ F_{z F L}=F_{z F} / 2-\\Delta F_{z F} \\end{array}\\right. \\\\ F_{z R}=M g \\frac{L_{F}}{L}+M a_{x} \\frac{h_{G s}}{L}+\\left|F_{z A R}\\right| \\quad \\Delta F_{z R}=F_{y R} \\frac{h_{R R}}{W_{R}}+\\frac{K_{\\phi R}}{W_{R}} \\phi \\\\ F_{z F}=M g \\frac{L_{R}}{L}-M a_{x} \\frac{h_{G s}}{L}+\\left|F_{z A F}\\right| \\quad \\Delta F_{z F}=F_{y F} \\frac{h_{R F}}{W_{F}}+\\frac{K_{\\phi F}}{W_{F}} \\phi \\end{gathered} \\] As far as the aerodynamic force contribute, they are computed according to equation ?? - \\(F_{z A R}=C_{A z R} u^{2}\\) and \\(F_{z A F}=C_{A z F} u^{2}-\\) -. The aerodynamic coefficients are extrapolated thanks to aerodynamic simulation. Their values are reported in table 5 . \\(C_{A x}\\) \\(C_{A z F}\\) \\(C_{A z R}\\) \\(1.56\\) \\(0.64\\) \\(0.92\\) Table 5: Aerodynamic coefficients - \\(N s^{2} / \\mathrm{m}^{2}\\) The lateral forces are computed using the expression 38 that consider also the transient yaw contribute. The roll angle \\(\\phi\\) , instead, is computed using the steady-state formulation. It involves the roll stiffness \\(\\left(K_{\\phi}\\right)\\) definition in order to evaluate the roll angle. \\[ \\phi=M a_{y} \\frac{h_{G s}}{K_{\\phi F}+K_{\\phi R}} \\] where the roll stiffnesses are a function of the total suspension/tire stiffness \\(\\left(K_{z}\\right)\\) . This stiffness is computed as a spring series. This is an approximation but this method is shown valid for simulation. Then, the roll stiffness can be defined as follow: \\[ K_{z}=\\frac{1}{\\frac{1}{K_{z}^{S}}+\\frac{1}{K_{z}^{T}}} \\quad K_{\\phi i}=K_{z i} \\frac{W_{i}^{2}}{2}, \\quad i=\\{F, R\\} \\] Also, the pitch angle \\(\\theta\\) can be estimated in steady-state using the definition of Anti-Dive \\((A D)\\) , Anti-Lift \\((A L)\\) and Anti-Squat \\((A S)\\) coefficients. These coefficients determine how much of the longitudinal load transfer is adsorbed by the suspension structure and how much by the suspension deformation. Anti-Dive reefers to the front suspensions, Anti-Lift and Anti-Squat to the rear ones depending on the condition of the suspensions: stretching or compressing. The computation of the pitch angle is reported in relation 40 . \\[ \\theta=\\frac{\\Delta z_{R}-\\Delta z_{F}}{L} \\] where \\[ \\Delta z_{R}=\\left\\{\\begin{array}{ll} -M \\frac{h_{G s}}{L} \\frac{a_{x}}{K_{z F}}(1-A S) & \\text { if } a_{x} \\geq 0 \\\\ -M \\frac{h_{G s}}{L} \\frac{a_{x}}{K_{z F}}(1-A L) & \\text { if } a_{x}<0 \\end{array} \\quad ; \\quad \\Delta z_{F}=M \\frac{h_{G s}}{L} \\frac{a_{x}}{K_{z F}}(1-A D)\\right. \\]","title":"Vertical Tire Load via Load Transfer"},{"location":"data-analysis-DMT/Estimation%20Functions/E.Tire-Force-Estimation/#longitudinal-and-lateral-force-via-s-sosm-and-kf","text":"An alternative method for the longitudinal and lateral force estimation is the combination of a Suboptimal-Second Order Sliding Mode (S-SOSM) observer and a Kalman filter, presented in [17] and used also in [21]. The S-SOSM is used as a virtual sensor for the force estimation while the Kalman filter is used to smooth the observer output. The S-SOSM-based force observer is divided into three main parts: longitudinal force observer, lateral force observer and wheel torque adaption.","title":"Longitudinal and Lateral Force via S-SOSM and KF"},{"location":"data-analysis-DMT/Estimation%20Functions/E.Tire-Force-Estimation/#longitudinal-tire-force-observer","text":"The longitudinal force \\(\\left(F_{x i j}\\right)\\) observer is based on a slightly modified version of the wheel rotation dynamic equation (??) which includes a correcting term \\(\\left(\\Delta \\hat{T}_{i j}\\right)\\) (see 41 . \\[ I_{a, W} \\dot{\\hat{\\omega}}_{i j}=T_{w i j}-\\Delta \\hat{T}_{i j}-R u_{x i j} \\] where \\(\\hat{\\omega}_{i j}\\) is the wheel speed obtained from the observer evolution and \\(u_{x i j}\\) is the observer output and corresponds to the estimated longitudinal force \\(\\left(\\hat{F}_{x i j}^{S M}\\right)\\) . The measured and the observed wheel speed are used to generate a sliding surface \\(\\left(\\sigma_{x i j}=\\omega_{i j}-\\hat{\\omega}_{i j}\\right)\\) in which the SOSM is developed. The observer input law is reported in relation 42 . \\[ u_{x i j}=-\\int K_{x} \\operatorname{sign}\\left(\\sigma_{x i j}-\\frac{\\sigma_{x, M a x}}{2}\\right) d t \\] \\(\\sigma_{x, \\text { Max }}\\) is the value in of \\(\\sigma_{x}\\) in the last time instant and \\(K_{x}\\) is a tunable gain. Using expression 41 with the input law 42 , the wheel spin derivatives can be found without any numerical derivation. Then, the observed wheel speed can be found integrating the \\(\\dot{\\hat{\\omega}}_{i j}\\) .","title":"Longitudinal Tire Force Observer"},{"location":"data-analysis-DMT/Estimation%20Functions/E.Tire-Force-Estimation/#lateral-axle-force-observer","text":"In this case, only one sliding mode observer is sufficient, that aims to estimate the front or the rear axle force. The non-estimated axle force is computed using the lateral equilibrium \\(-M a_{y}=F_{y F[v]}+F_{y R[v]}\\) where the indicator \\([v]\\) means that the forces are projected in the vehicle reference frame \\(-\\) . The sliding surface is now based on the yaw-rate dynamic equation - expression 43 - written around the front axle centre point and the sliding surface is defined as the difference between the measured yaw rate and the estimated one \\(\\left(\\sigma_{y}=\\Omega-\\hat{\\Omega}\\right)\\) . \\[ I_{z z, V} \\dot{\\hat{\\Omega}}=L_{F} M a_{y}-L u_{y}+\\frac{W_{F}}{2} \\Delta \\hat{F}_{x F[v]}^{S M}+\\frac{W_{R}}{2} \\Delta \\hat{F}_{x R[v]}^{S M} \\] In the reported formulation, \\(u_{y}\\) is the input law that corresponds to the estimated rear lateral axle force in the vehicle reference frame \\(\\left(F_{y R[v]}^{S M}\\right)\\) . The terms \\(\\Delta \\hat{F}_{x j[v]}\\) corresponds to the difference between the left and the right tire forces and is the cause of a yaw moment. In order to compute these terms, the force projection in the vehicle RF must occur. \\[ \\Delta \\hat{F}_{x F[v]}^{S M}=\\hat{F}_{x F R}^{S M} \\cos \\left(\\delta_{F R}\\right)-\\hat{F}_{x F L}^{S M} \\cos \\left(\\delta_{F L}\\right) \\quad ; \\quad \\Delta \\hat{F}_{x R[v]}^{S M}=\\hat{F}_{x R R}^{S M}-\\hat{F}_{x R L}^{S M} \\] The input law, in this case, is \\[ u_{y}=-\\int K_{y} \\operatorname{sign}\\left(\\sigma_{y}-\\frac{\\sigma_{y, M a x}}{2}\\right) d t \\]","title":"Lateral Axle Force Observer"},{"location":"data-analysis-DMT/Estimation%20Functions/E.Tire-Force-Estimation/#wheel-torque-adaption","text":"The correction term introduced in the expression 41 is a Proportional-Integral (PI) adaptive law which considers the longitudinal error dynamics. \\[ \\Delta \\hat{T}=K_{P} e_{F_{x}}+K_{I} \\int e_{F_{x}} d t \\] The error-dynamics is computed using the deviation from the longitudinal equilibrium \\(-M a_{x}=\\sum F_{x}-\\) \\[ e_{F_{x}}=\\left(\\sum_{i j} \\hat{F}_{x i j[v]}^{S M}-F_{\\text {Res }}\\right)-M a_{x} \\] where \\(F_{\\text {Res }}\\) is the sum of all the resistance forces - for example, aerodynamic drag and rolling resistance effects - and \\(\\hat{F}_{x i j[v]}^{S M}\\) are the longitudinal tire forces, which are computed as follow. \\[ \\begin{gathered} \\hat{F}_{x F R[v]}^{S M}+\\hat{F}_{x F L[v]}^{S M}=\\hat{F}_{x F R}^{S M} \\cos \\left(\\delta_{F R}\\right)+\\hat{F}_{x F L}^{S M} \\cos \\left(\\delta_{F L}\\right)-\\hat{F}_{y F[v]}^{S M} \\tan \\left[\\frac{\\delta_{F R}+\\delta_{F L}}{2}\\right] \\\\ \\hat{F}_{x R R[v]}^{S M}=\\hat{F}_{x R R}^{S M} \\quad \\hat{F}_{x R L[v]}^{S M}=\\hat{F}_{x R L}^{S M} \\end{gathered} \\] The total \\(\\Delta \\hat{T}\\) term, obtained by equation 45 , is split among the four wheels depending on the driving situation. Moreover, if a negligible torque is applied to a specific wheel, the torque correction is null. For a rear-wheel-driven vehicle, the torque splitting is the following. \\[ \\begin{aligned} & \\text { Front wheels: } \\Delta \\hat{T}_{F j}=\\left\\{\\begin{array}{lll} 0 & \\text { if } a_{x}>a_{t h} & \\text { (Acceleration) } \\\\ \\Delta \\hat{T} \\frac{F_{z F j}}{M g} & \\text { if }\\left|a_{x}\\right|<a_{t h} & \\text { (Coasting) } \\\\ \\Delta \\hat{T} \\frac{F_{z F j}}{M g} \\epsilon_{b r k} & \\text { if } a_{x}<-a_{t h} & \\text { (Braking) } \\end{array}\\right. \\\\ & \\text { Rear wheels: } \\Delta \\hat{T}_{R j}=\\left\\{\\begin{array}{lll} \\Delta \\hat{T} \\frac{F_{z R j}}{F_{z R R}+F_{z R L}} & \\text { if } a_{x}>a_{t h} & \\text { (Acceleration) } \\\\ \\Delta \\hat{T} \\frac{F_{z R j}}{M g} & \\text { if }\\left|a_{x}\\right|<a_{t h} & \\text { (Coasting) } \\\\ \\Delta \\hat{T} \\frac{F_{z R j}}{M g}\\left(1-\\epsilon_{b r k}\\right) & \\text { if } a_{x}<-a_{t h} & \\text { (Braking) } \\end{array}\\right. \\end{aligned} \\] where the vertical forces are computed according to ?? and \\(\\epsilon_{b r k}\\) is the front braking balance, i.e. it said how much braking torque is applied at the front with respect to the total one - in our case, it is equal to \\(0.6\\) -. \\(a_{t h}\\) is a threshold acceleration that is set equal to \\(0.5 \\mathrm{~m} / \\mathrm{s}^{2}\\) in our case.","title":"Wheel torque adaption"},{"location":"data-analysis-DMT/Estimation%20Functions/E.Tire-Force-Estimation/#kalman-filter-smoothing","text":"The observer outputs are taken as input from an Extended Kalman filter. The implemented here Kalman filter is based on the wheel spin equations - equation ?? - and on the vehicle yaw dynamics around the centre point of the front axle - already used in \\(43-\\) The filter states, collected in the vector \\(x\\) , are indicated with the hat only, while the outputs of the observer have the hat indicator and the superscript \"SM\". The measured quantities and the data do not have any indicator. \\[ \\begin{gathered} \\dot{\\omega}_{i j}=\\frac{T_{w i j}-\\hat{F}_{x i j} R}{I_{a, W}} \\\\ \\dot{\\Omega}=\\frac{L_{F} M \\hat{a}_{y}-L \\hat{F}_{y R}+\\frac{W_{R}}{2}\\left(\\hat{F}_{x R R}-\\hat{F}_{x R L}\\right)+\\frac{W_{F}}{2}\\left(\\hat{F}_{x F R}-\\hat{F}_{x F L}\\right) \\cos \\left(\\delta_{F}\\right)}{I_{z z, V}} \\end{gathered} \\] The vector \\(z\\) collects the set of all the measures, virtual or not, and the vector \\(u\\) contains the system inputs. \\[ \\begin{aligned} {x} & =\\left[\\hat{F}_{x i j}, \\hat{F}_{y R}, \\hat{a}_{y}, \\hat{\\omega}_{i j}, \\hat{\\Omega}\\right] \\\\ {z} & =\\left[\\hat{F}_{x i j}^{S M}, \\hat{F}_{y R}^{S M}, a_{y}, \\omega_{i j}, \\Omega\\right] \\\\ {u} & =\\left[T_{w i j}, \\delta_{F}\\right] \\end{aligned} \\] \\(\\delta_{F}\\) is the mean of the left and right steering angle. The process and output evolution are vectorial functions reported in 49 . The process and measurement noise ( \\(v\\) and \\(w\\) ) are assumed to be zero-mean and normal distributed with covariance matrices equal to \\(Q\\) and \\(R\\) respectively - \\(v \\sim N(0, Q)\\) and \\(w \\backsim N(0, R)\\) -. The measurement vector and the state vector contain the same quantities. For this reason, deriving the function \\(h(\\cdot)\\) with respect to the state, the identity matrix will return \\((H=I)\\) . \\[ \\dot{x}=f( {x}, {u}, {v}) \\quad ; \\quad z=h( {x}, {u}, {w}) \\] The matrix \\(F\\) is obtained deriving the function \\(f(\\cdot)\\) with respect to the system states. \\[ F_{k}=\\left.\\frac{\\partial f}{\\partial x}\\right|_{\\hat{x}_{k-1 \\mid k-1}}=\\left[\\begin{array}{cc} 0 & 0 \\\\ F_{21} & 0 \\end{array}\\right] \\] where \\[ F_{21}=\\left[\\begin{array}{cccccc} -\\frac{R}{I_{a, W}} & 0 & 0 & 0 & 0 & 0 \\\\ 0 & -\\frac{R}{I_{a, W}} & 0 & 0 & 0 & 0 \\\\ 0 & 0 & -\\frac{R}{I_{a, W}} & 0 & 0 & 0 \\\\ 0 & 0 & 0 & -\\frac{R}{I_{a, W}} & 0 & 0 \\\\ \\frac{W_{R}}{2 I_{a, W}} & -\\frac{W_{R}}{2 I_{a, W}} & \\frac{W_{F}}{2 I_{a, W}} \\cos \\left(\\delta_{F}\\right) & -\\frac{W_{R}}{2 I_{a, W}} \\cos \\left(\\delta_{F}\\right) & -\\frac{L}{I_{a, W}} & \\frac{L_{F} M}{I_{a, W}} \\end{array}\\right] \\] This algorithm has to be properly tuned to have good performances. The tuning procedure is performed by means of trial and error approach starting from the values proposed in [21]. The optimized values can be found in table 6 \\(K_{x}\\) \\(K_{y}\\) \\(\\sigma_{x / y, ext { Max }}\\) \\(K_{P}\\) \\(K_{I}\\) \\(3 \\cdot 10^{5}\\) \\(3 \\cdot 10^{5}\\) 0 \\(5 \\cdot 10^{-2}\\) \\(1 \\cdot 10^{-3}\\) \\(Q_{F_{x}}\\) \\(Q_{F_{y}}\\) \\(Q_{a_{y}}\\) \\(Q_{\\omega}\\) \\(Q_{\\Omega}\\) \\(26.03\\) \\(7.68\\) \\(8.93\\) \\(93.28\\) \\(77.86\\) \\(R_{F_{x}}\\) \\(R_{F_{y}}\\) \\(R_{a_{y}}\\) \\(R_{\\omega}\\) \\(R_{\\Omega}\\) 600 500 \\(0.785\\) \\(0.1\\) \\(4 \\cdot 10^{-2}\\) Table 6: Parameters for the S-SOSM observer with EKF enhancement A high value for the parameters \\(K_{x / y}\\) allows us to have a faster convergence to the actual value but it causes chattering in the force estimation. The Kalman filter sees the observer outputs as a noisy signal and it is able to clean the data avoiding the chattering. In this way, the observer gains can be high to favour a fast convergence rate.","title":"Kalman Filter Smoothing"},{"location":"data-analysis-DMT/Estimation%20Functions/E.Tire-Force-Estimation/#algorithms-performances","text":"To conclude the analysis regarding force estimation, a qualitative performance analysis must be done. In particular, the results will be shown in two simulated pure conditions: using a simulated double throttle step, the performance of the longitudinal force estimators are highlighted while, with a simulated constant steering angle tests, the performances of the axle lateral force observers are illustrated. The vertical load are reported in both situations to see how the load transfer performs in both cases. Firstly, the acceleration results are considered. In figure 13, the longitudinal force estimations are reported in relation with the simulated data. The first thing that can be noticed is that for the front wheels, in which the force is low, an oscillation is present in the force estimation. This is the remaining part of the chattering due to the high gain of the observer. However, when the force value grows, this chattering is negligible. As we can see, the results using the wheel spin dynamical equations is enough similar to the output of the SOSM observer, that is a good approximation of the actual force. However, especially using the real telemetry data, the unmodelled effects can be high and the simpler estimation can be not reliable. Moreover, the numerical derivation of the wheel spin can generate numerical noise if the signal is not properly filtered. The load transfer results (figure 14) seems a good approximation of the real tire load. Figure 13: Longitudinal force estimation results - Acceleration case Figure 14: Vertical force estimation results - Acceleration case In figure 15 the lateral axles forces for a constant steering test are reported. The results of both the estimator are sufficiently good. However, it can be seen that the SOSM observer has a smaller estimation error. In addition, the computation of the yaw moment, in the standard estimation, involves the numerical derivation of the yaw rate. This can generate a lot of numerical noise when the estimation is done over the real telemetry data. Figure 15: Longitudinal force estimation results - Acceleration case Also in the turning case, the vertical load is well estimated from relation ??. The estimation shows the greatest difference with respect to the actual force in the last part of the test. In this part, the vehicle is subjected to a very high lateral acceleration - that generate a high roll -. The possible cause of this mismatch can be the approximation done in the roll stiffness case. Nevertheless, the maximum error is acceptable for our analysis. Figure 16: Vertical force estimation results - Acceleration case","title":"Algorithms Performances"},{"location":"data-analysis-DMT/Estimation%20Functions/Home-Estimation/","text":"Estimation Functions Welcome to the Estimation Functions wiki! TABLE OF CONTENTS Introduction Longitudinal Velocity Estimators Lateral Velocity Estimator Tire Slips Estimation Tire Force Estimation","title":"Estimation Functions"},{"location":"data-analysis-DMT/Estimation%20Functions/Home-Estimation/#estimation-functions","text":"Welcome to the Estimation Functions wiki!","title":"Estimation Functions"},{"location":"data-analysis-DMT/Estimation%20Functions/Home-Estimation/#table-of-contents","text":"Introduction Longitudinal Velocity Estimators Lateral Velocity Estimator Tire Slips Estimation Tire Force Estimation","title":"TABLE OF CONTENTS"},{"location":"data-analysis-DMT/Experimental%20Measurement/ExperimentalMeasurement/","text":"Experimental Measurement Some preliminary data estimation procedures are reported in order to have a correct set of vehicle data to properly perform the state estimation algorithms needed to estimate the necessary vehicle states and especially the tires analysis. Centre of Mass Position One of the most important preliminary knowledge about the vehicle is the mass distribution. The estimation procedure consists of a series of weighing measure. The data from the weighers have been elaborated thanks to the static equilibrium to extract the centre of mass position of the spring components of the vehicle. The weighers have to be properly tared in order to have a reliable measure. The first weighing consists of a planar measure. Thanks to this experiment, the longitudinal position of the centre of mass can be evaluated by looking at the axle vertical load, measured by the weighers - reference to figure 1 -. Figure 1: Experimental scheme for \\(L_{R}\\) and \\(L_{F}\\) estimation \\[ \\left\\{\\begin{array}{l} M g=F_{z R}+F_{z F} \\\\ M=M_{s}+4 M_{u s} \\\\ F_{z F} L-M_{s} g L_{R}-2 M_{u s} g L=0 \\\\ L=L_{F}+L_{R} \\end{array}\\right. \\] The system presented in figure 1 can be mathematically described by the system of equation 1. \\(M\\) is the whole mass of the vehicle, \\(M_{s}\\) is the mass of the spring elements, \\(M_{u s}\\) is the mass of the unspring elements, \\(F_{z i}\\) are the forces measured by the weighers at the front and the rear, in Newton, and \\(L_{i}\\) are the distance of the CoM from the front and the rear axle. Solving this system of equations, the vehicle mass \\((M)\\) , the spring mass value \\(\\left(M_{s}\\right)\\) and the two length \\(L_{F}\\) and \\(L_{R}\\) can be found. \\[ \\left\\{\\begin{array}{l} M=\\frac{F_{z R}+F_{z F}}{g} \\\\ M_{s}=M-4 M_{u s} \\\\ L_{R}=\\frac{F_{z F} L-2 M_{u s} g L}{M_{s} g} \\\\ L_{F}=L-L_{R} \\end{array}\\right. \\] The second test consists of a tilted weighting of the vehicle. Now, the estimation procedure aims to solve the equilibrium of the torque in the projection of the centre of mass on the tilted plane - point \\(C\\) in figure 2-, where \\(\\theta\\) is the angle between the horizontal ground plane and the tilted plane. In order to make the experiment easier, the weight is measured on the rear axle only. The other axle force is computed knowing the vehicle mass from the previous experiment. The meaning of almost every abbreviation used in CG_estimation.nb is explained in the vehicle_data.m , except for \\(h_{rr}\\) : rear roll center height, \\(h_{rf}\\) : front roll center height and \\(De\\) : external diameter of the wheel with tire shoulder. Figure 2: Experimental scheme for \\(h_{G}\\) estimation \\[ \\left\\{\\begin{array}{l} F_{z F}+F_{z R}=M g \\\\ {\\left(F_{z R} L_{R}-F_{z F} L_{F}+2 M_{u s} g L_{F}-2 M_{u s} g L_{R}\\right) \\cos (\\theta)-M g h_{G 0} \\sin (\\theta)=0} \\end{array}\\right. \\] Solving the system of equations 3 , the centre of mass height \\(\\left(h_{G 0}\\right)\\) can be found. \\[ h_{G 0}=\\frac{\\left(F_{z R} L_{R}-\\left(M g-F_{z R}\\right) L_{F}+2 M_{u s} g\\left(L_{F}-L_{R}\\right)\\right) \\cos (\\theta)}{M g \\sin (\\theta)} \\] Knowing the roll height at the front and at the rear - \\(h_{R F}\\) and \\(h_{R R}\\) - from the suspension model, the height of the centre of mass with respect to the roll axis \\(\\left(h_{G s}\\right)\\) can be computed - with reference to figure ?? and to relation ?? -. \\[ h_{G s}=h_{G 0}-h_{R F}-\\left(\\frac{h_{R R}-h_{R F}}{L_{R}+L_{F}}\\right) L_{F} \\] The unspring masses is the sub-assembly of the vehicle that is not spring by the suspensions. It collects the wheels and a part of the suspension structure. The whole wheels assebly weigh \\(8 \\mathrm{Kg}\\) each. The known data, the experiment data and the results of the estimation procedure are reported in tables 1,2 and 3 Data Value Data Value \\(L\\) \\(1530 \\mathrm{~mm}\\) \\(M_{u s}\\) \\(8 \\mathrm{Kg}\\) \\(h_{R R}\\) \\(55 \\mathrm{~mm}\\) \\(\\theta\\) \\(20^{\\circ}\\) \\(h_{R F}\\) \\(24 \\mathrm{~mm}\\) Table 1: Vehicle knowing data Experiment \\(F_{z F R}(\\mathrm{Kg})\\) \\(F_{z F L}(\\mathrm{Kg})\\) \\(F_{z R R}(\\mathrm{Kg})\\) \\(F_{z R L}(\\mathrm{Kg})\\) 1 (Horizontal) \\(45.92\\) \\(45.09\\) \\(55.02\\) \\(56.45\\) 2 (Tilted) \\(33.404\\) \\(33.404\\) \\(68.24\\) \\(67.44\\) Table 2: Data from the experiments \\(M(\\mathrm{Kg})\\) \\(M_{s}(\\mathrm{Kg})\\) \\(L_{F}(\\mathrm{~mm})\\) \\(L_{R}(\\mathrm{~mm})\\) \\(h_{G 0}(\\mathrm{~mm})\\) \\(h_{G s}(\\mathrm{~mm})\\) 202.48 170.48 857 673 221 179 Table 3: Centre of mass estimated data Resistance Force Estimation Aerodynamic forces affect the vehicle performance changing the tire vertical load and introducing a resistance force. While the lift contribute of the aerodynamic force is difficult to measure or estimate using the set of sensors mounting in our vehicle, the aerodynamic drag - and the resistance force in general - is easier to be estimated. \\[ M a_{x G}=\\sum F_{x}+F_{r e s} \\] In equation 5 is reported the longitudinal dynamic equilibrium of the vehicle. If the wheels torques are equal to zero - the driver is not accelerating nor braking -, the tire longitudinal forces \\(F_{x}\\) are almost equal to zero and the resistance force \\(F_{r e s}=M a_{x G}\\) . The resistance force is velocity-dependent. Knowing that the theoretical drag force depends on the square of the longitudinal velocity, the resistance force can be fitted using a second-order polynomial in the longitudinal vehicle speed \\(u\\) . The fitted here resistance force is used in the Second-Order Sliding Mode observer. \\[ F_{\\text {res }}(u)=c_{0}+c_{1} u+c_{1} u^{2} \\] The test with which the fitting of this model is possible is a straight-line free-deceleration manoeuvre. Looking at the experimental results, \\(c_{1}\\) does not give a significant improvement in the fitting performance. For this reason, it is set equal to zero. In table 4 the fitting results are reported. \\(c_{0}(N)\\) \\(c_{1}(N s / m)\\) \\(c_{1}\\left(N s^{2} / m^{2}\\right)\\) 127 0 \\(1.44\\) Table 4: Resistance force fitting results Regarding table 4, where the coefficients from aerodynamic simulations are reported, it can be seen the drag coefficient \\(\\left(C_{A x}\\right)\\) has a value close to the value of \\(c_{2}\\) . Then, it can be assumed that the aerodynamic simulations give a reliable value of the aerodynamic coefficients. Wheel Spin Correction From the data, it is possible to notice that the rear wheels speed are not perfectly equal with each other and with respect to the front ones. In the case of zero applied torque, the equality condition should be verified. This offset grows with the vehicle velocity and can be due to an error in the rolling radius value. This effect has a strong and detrimental impact on slip computation. A fixed multiplication term is introduced to correct the angular velocity. Keeping the front wheels as a reference, the multiplication term can be fitted imposing the equality between the front wheels speed and the rear ones in the straight free-deceleration test. \\[ \\omega_{R j, c o r r}=k_{R j} \\omega_{R j}=\\omega_{F j} \\quad ; \\quad j=\\{R, L\\} \\] \\(k_{R R}\\) \\(k_{R L}\\) \\(1.0400\\) \\(1.0164\\) Table 5: Rear wheels correction terms Vertical Vehicle Moment of Inertia Estimation The vertical moment of inertia \\(\\left(I_{z z}\\right)\\) controls the yaw transient. In order to have a good estimation of the turning transient response of the vehicle model, this parameter has to be estimated. The estimated procedure follows a grey-box approach based on the linearized singletrack model. The model transfer function \\(G_{\\Omega}(s)=\\Omega(s) / \\delta(s)\\) depends on the parameter \\(I_{z z}\\) . To estimate the yaw moment of inertia, the best matching between the linear simulation of the yaw-rate and the measured one has to be evaluated. At the beginning, the linear single-track model has to be defined. The model states are the yaw-rate \\((\\Omega)\\) and the body-side slip angle \\((\\beta)\\) and the control is the steering angle \\((\\delta)\\) . The linearization is performed around a steady-state condition, hence, the longitudinal velocity is considered as constant \\(\\left(u_{0}\\right)\\) . In this case, the single-track equation of motion can be written as relation 8 . \\[ \\left\\{\\begin{array}{l} M\\left(\\dot{v}+\\Omega u_{0}\\right)=M u_{0}(\\beta+\\Omega)=F_{y F}+F_{y R}=Y \\\\ I_{z z} \\dot{\\Omega}=F_{y F} L_{F}-F_{y R} L_{R}+\\Delta F_{x R} W_{R}=N \\end{array}\\right. \\] Where \\(Y\\) is the total lateral force and \\(N\\) is the total yaw moment. Then, the equation of motion has to be linearized around the steady-state configuration in which \\(\\Omega=\\Omega_{0}, \\beta=\\beta_{0}\\) and \\(\\delta=\\delta_{0}\\) . The variations from the steady-state status are described by \\(\\Delta \\Omega, \\Delta \\beta\\) and \\(\\Delta \\delta\\) . With this notation, the equation of motion can be linearized and written as reported in relation 9 , \\[ \\left\\{\\begin{array}{l} \\dot{\\Delta \\beta}=Y_{\\beta} /\\left(m u_{0}\\right) \\Delta \\beta+\\left(Y_{\\Omega} /\\left(m u_{0}\\right)-1\\right) \\Delta \\Omega+Y_{\\delta} /\\left(m u_{0}\\right) \\Delta \\delta \\\\ \\dot{\\Delta \\Omega}=N_{\\beta} / I_{z z} \\Delta \\beta+N_{\\Omega} / I_{z z} \\Delta \\Omega+N_{\\delta} / I_{z z} \\Delta \\delta \\end{array}\\right. \\] \\(Y_{\\Omega}, N_{\\Omega}, Y_{\\beta}\\) and \\(N_{\\beta}\\) are called stability derivatives and are the derivatives of \\(Y\\) and \\(N\\) with respect to \\(\\Omega\\) and \\(\\beta . Y_{\\delta}, N_{\\delta}\\) are called control derivatives and are the derivatives of \\(Y\\) and \\(N\\) with respect to \\(\\delta\\) . Using the linear definition of the tire characteristic \\(\\left(F_{y i}=C_{a i} \\alpha_{i}\\right)\\) and the definition of the axle slips (relations ?? and ??), equation 9 can be written in matrix form, as shown in equation 10. \\[ \\left[\\begin{array}{c} \\dot{\\Delta \\beta} \\\\ \\dot{\\Delta \\Omega} \\end{array}\\right]=\\left[\\begin{array}{cc} -\\frac{C_{a F}+C_{a R}}{M u_{0}} & \\frac{C_{a R} L_{R}-C_{a F} L_{F}-M u_{0}^{2}}{M u_{0}^{2}} \\\\ \\frac{C_{a R} L_{R}-C_{a F} L_{F}}{I_{z z}} & -\\frac{C_{a F} L_{F}^{2}+C_{a R} L_{R}^{2}}{u_{0} I_{z z}} \\end{array}\\right]\\left[\\begin{array}{c} \\Delta \\beta \\\\ \\Delta \\Omega \\end{array}\\right]+\\left[\\begin{array}{c} \\frac{C_{a F}}{\\tau_{D} M u_{0}} \\\\ \\frac{C_{a F} L_{F}}{\\tau_{D} I_{z z}} \\end{array}\\right] \\Delta \\delta \\] where \\(\\tau_{D}\\) is the steering ratio, considered as fixed in this case. The axle cornering stiffness \\(\\left(C_{a F}\\right.\\) and \\(\\left.C_{a R}\\right)\\) are considered as fixed and can be fitted using the axle characteristic in the linear region. This assumption is valid if the lateral acceleration is low. \\(C_{a F}\\) \\(C_{a R}\\) \\(12418.38\\) \\(45441.63\\) Table 6: Axle cornering stiffness Figure 3: Linear axle model using cornering stiffness The data-test used for the estimation of the vertical moment of inertia consists of a random steer test at a constant speed. The vehicle speed \\(u_{0}\\) is the mean of the test vehicle speed during the test and the steering ratio \\(\\left(\\tau_{D}\\right)\\) is computed by a simple fitting between the steering angle at the wheels and the one at the hand-wheel. Once all the data are computed, the yaw moment of inertia can be estimated minimizing the difference between the linear simulation of the yaw rate and the measured one. The estimation results are reported in table 7 . \\[ \\begin{gathered} \\operatorname{minimize}_{I_{z z}}\\left(\\Omega_{\\text {sim }}-\\Omega\\right)^{2} \\\\ \\hline I_{z z}\\left(K g m^{2}\\right) \\\\ \\hline 72.75 \\\\ \\hline \\end{gathered} \\] Table 7: Yaw moment of inertia Having now all the necessary data, the analytical transfer function can be plotted with the estimated one from the data-test (figure 4). It must be considered that the linear system is a strong approximation of the vehicle behaviour. Besides, the singletrack model does not consider some important effects that modify the vehicle dynamics, as the load transfer. For this reason, the mismatch between the analytical and the experimental transfer function is justified. Figure 4: Analytical and experimental yaw-rate transfer function Revision History V1 23/12/2022 Updated values (missing values:Wheel Spin Correction, axle cornering stiffness and Moment of Inertia) Ignas Pavirzis","title":"Experimental Measurement"},{"location":"data-analysis-DMT/Experimental%20Measurement/ExperimentalMeasurement/#experimental-measurement","text":"Some preliminary data estimation procedures are reported in order to have a correct set of vehicle data to properly perform the state estimation algorithms needed to estimate the necessary vehicle states and especially the tires analysis.","title":"Experimental Measurement"},{"location":"data-analysis-DMT/Experimental%20Measurement/ExperimentalMeasurement/#centre-of-mass-position","text":"One of the most important preliminary knowledge about the vehicle is the mass distribution. The estimation procedure consists of a series of weighing measure. The data from the weighers have been elaborated thanks to the static equilibrium to extract the centre of mass position of the spring components of the vehicle. The weighers have to be properly tared in order to have a reliable measure. The first weighing consists of a planar measure. Thanks to this experiment, the longitudinal position of the centre of mass can be evaluated by looking at the axle vertical load, measured by the weighers - reference to figure 1 -. Figure 1: Experimental scheme for \\(L_{R}\\) and \\(L_{F}\\) estimation \\[ \\left\\{\\begin{array}{l} M g=F_{z R}+F_{z F} \\\\ M=M_{s}+4 M_{u s} \\\\ F_{z F} L-M_{s} g L_{R}-2 M_{u s} g L=0 \\\\ L=L_{F}+L_{R} \\end{array}\\right. \\] The system presented in figure 1 can be mathematically described by the system of equation 1. \\(M\\) is the whole mass of the vehicle, \\(M_{s}\\) is the mass of the spring elements, \\(M_{u s}\\) is the mass of the unspring elements, \\(F_{z i}\\) are the forces measured by the weighers at the front and the rear, in Newton, and \\(L_{i}\\) are the distance of the CoM from the front and the rear axle. Solving this system of equations, the vehicle mass \\((M)\\) , the spring mass value \\(\\left(M_{s}\\right)\\) and the two length \\(L_{F}\\) and \\(L_{R}\\) can be found. \\[ \\left\\{\\begin{array}{l} M=\\frac{F_{z R}+F_{z F}}{g} \\\\ M_{s}=M-4 M_{u s} \\\\ L_{R}=\\frac{F_{z F} L-2 M_{u s} g L}{M_{s} g} \\\\ L_{F}=L-L_{R} \\end{array}\\right. \\] The second test consists of a tilted weighting of the vehicle. Now, the estimation procedure aims to solve the equilibrium of the torque in the projection of the centre of mass on the tilted plane - point \\(C\\) in figure 2-, where \\(\\theta\\) is the angle between the horizontal ground plane and the tilted plane. In order to make the experiment easier, the weight is measured on the rear axle only. The other axle force is computed knowing the vehicle mass from the previous experiment. The meaning of almost every abbreviation used in CG_estimation.nb is explained in the vehicle_data.m , except for \\(h_{rr}\\) : rear roll center height, \\(h_{rf}\\) : front roll center height and \\(De\\) : external diameter of the wheel with tire shoulder. Figure 2: Experimental scheme for \\(h_{G}\\) estimation \\[ \\left\\{\\begin{array}{l} F_{z F}+F_{z R}=M g \\\\ {\\left(F_{z R} L_{R}-F_{z F} L_{F}+2 M_{u s} g L_{F}-2 M_{u s} g L_{R}\\right) \\cos (\\theta)-M g h_{G 0} \\sin (\\theta)=0} \\end{array}\\right. \\] Solving the system of equations 3 , the centre of mass height \\(\\left(h_{G 0}\\right)\\) can be found. \\[ h_{G 0}=\\frac{\\left(F_{z R} L_{R}-\\left(M g-F_{z R}\\right) L_{F}+2 M_{u s} g\\left(L_{F}-L_{R}\\right)\\right) \\cos (\\theta)}{M g \\sin (\\theta)} \\] Knowing the roll height at the front and at the rear - \\(h_{R F}\\) and \\(h_{R R}\\) - from the suspension model, the height of the centre of mass with respect to the roll axis \\(\\left(h_{G s}\\right)\\) can be computed - with reference to figure ?? and to relation ?? -. \\[ h_{G s}=h_{G 0}-h_{R F}-\\left(\\frac{h_{R R}-h_{R F}}{L_{R}+L_{F}}\\right) L_{F} \\] The unspring masses is the sub-assembly of the vehicle that is not spring by the suspensions. It collects the wheels and a part of the suspension structure. The whole wheels assebly weigh \\(8 \\mathrm{Kg}\\) each. The known data, the experiment data and the results of the estimation procedure are reported in tables 1,2 and 3 Data Value Data Value \\(L\\) \\(1530 \\mathrm{~mm}\\) \\(M_{u s}\\) \\(8 \\mathrm{Kg}\\) \\(h_{R R}\\) \\(55 \\mathrm{~mm}\\) \\(\\theta\\) \\(20^{\\circ}\\) \\(h_{R F}\\) \\(24 \\mathrm{~mm}\\) Table 1: Vehicle knowing data Experiment \\(F_{z F R}(\\mathrm{Kg})\\) \\(F_{z F L}(\\mathrm{Kg})\\) \\(F_{z R R}(\\mathrm{Kg})\\) \\(F_{z R L}(\\mathrm{Kg})\\) 1 (Horizontal) \\(45.92\\) \\(45.09\\) \\(55.02\\) \\(56.45\\) 2 (Tilted) \\(33.404\\) \\(33.404\\) \\(68.24\\) \\(67.44\\) Table 2: Data from the experiments \\(M(\\mathrm{Kg})\\) \\(M_{s}(\\mathrm{Kg})\\) \\(L_{F}(\\mathrm{~mm})\\) \\(L_{R}(\\mathrm{~mm})\\) \\(h_{G 0}(\\mathrm{~mm})\\) \\(h_{G s}(\\mathrm{~mm})\\) 202.48 170.48 857 673 221 179 Table 3: Centre of mass estimated data","title":"Centre of Mass Position"},{"location":"data-analysis-DMT/Experimental%20Measurement/ExperimentalMeasurement/#resistance-force-estimation","text":"Aerodynamic forces affect the vehicle performance changing the tire vertical load and introducing a resistance force. While the lift contribute of the aerodynamic force is difficult to measure or estimate using the set of sensors mounting in our vehicle, the aerodynamic drag - and the resistance force in general - is easier to be estimated. \\[ M a_{x G}=\\sum F_{x}+F_{r e s} \\] In equation 5 is reported the longitudinal dynamic equilibrium of the vehicle. If the wheels torques are equal to zero - the driver is not accelerating nor braking -, the tire longitudinal forces \\(F_{x}\\) are almost equal to zero and the resistance force \\(F_{r e s}=M a_{x G}\\) . The resistance force is velocity-dependent. Knowing that the theoretical drag force depends on the square of the longitudinal velocity, the resistance force can be fitted using a second-order polynomial in the longitudinal vehicle speed \\(u\\) . The fitted here resistance force is used in the Second-Order Sliding Mode observer. \\[ F_{\\text {res }}(u)=c_{0}+c_{1} u+c_{1} u^{2} \\] The test with which the fitting of this model is possible is a straight-line free-deceleration manoeuvre. Looking at the experimental results, \\(c_{1}\\) does not give a significant improvement in the fitting performance. For this reason, it is set equal to zero. In table 4 the fitting results are reported. \\(c_{0}(N)\\) \\(c_{1}(N s / m)\\) \\(c_{1}\\left(N s^{2} / m^{2}\\right)\\) 127 0 \\(1.44\\) Table 4: Resistance force fitting results Regarding table 4, where the coefficients from aerodynamic simulations are reported, it can be seen the drag coefficient \\(\\left(C_{A x}\\right)\\) has a value close to the value of \\(c_{2}\\) . Then, it can be assumed that the aerodynamic simulations give a reliable value of the aerodynamic coefficients.","title":"Resistance Force Estimation"},{"location":"data-analysis-DMT/Experimental%20Measurement/ExperimentalMeasurement/#wheel-spin-correction","text":"From the data, it is possible to notice that the rear wheels speed are not perfectly equal with each other and with respect to the front ones. In the case of zero applied torque, the equality condition should be verified. This offset grows with the vehicle velocity and can be due to an error in the rolling radius value. This effect has a strong and detrimental impact on slip computation. A fixed multiplication term is introduced to correct the angular velocity. Keeping the front wheels as a reference, the multiplication term can be fitted imposing the equality between the front wheels speed and the rear ones in the straight free-deceleration test. \\[ \\omega_{R j, c o r r}=k_{R j} \\omega_{R j}=\\omega_{F j} \\quad ; \\quad j=\\{R, L\\} \\] \\(k_{R R}\\) \\(k_{R L}\\) \\(1.0400\\) \\(1.0164\\) Table 5: Rear wheels correction terms","title":"Wheel Spin Correction"},{"location":"data-analysis-DMT/Experimental%20Measurement/ExperimentalMeasurement/#vertical-vehicle-moment-of-inertia-estimation","text":"The vertical moment of inertia \\(\\left(I_{z z}\\right)\\) controls the yaw transient. In order to have a good estimation of the turning transient response of the vehicle model, this parameter has to be estimated. The estimated procedure follows a grey-box approach based on the linearized singletrack model. The model transfer function \\(G_{\\Omega}(s)=\\Omega(s) / \\delta(s)\\) depends on the parameter \\(I_{z z}\\) . To estimate the yaw moment of inertia, the best matching between the linear simulation of the yaw-rate and the measured one has to be evaluated. At the beginning, the linear single-track model has to be defined. The model states are the yaw-rate \\((\\Omega)\\) and the body-side slip angle \\((\\beta)\\) and the control is the steering angle \\((\\delta)\\) . The linearization is performed around a steady-state condition, hence, the longitudinal velocity is considered as constant \\(\\left(u_{0}\\right)\\) . In this case, the single-track equation of motion can be written as relation 8 . \\[ \\left\\{\\begin{array}{l} M\\left(\\dot{v}+\\Omega u_{0}\\right)=M u_{0}(\\beta+\\Omega)=F_{y F}+F_{y R}=Y \\\\ I_{z z} \\dot{\\Omega}=F_{y F} L_{F}-F_{y R} L_{R}+\\Delta F_{x R} W_{R}=N \\end{array}\\right. \\] Where \\(Y\\) is the total lateral force and \\(N\\) is the total yaw moment. Then, the equation of motion has to be linearized around the steady-state configuration in which \\(\\Omega=\\Omega_{0}, \\beta=\\beta_{0}\\) and \\(\\delta=\\delta_{0}\\) . The variations from the steady-state status are described by \\(\\Delta \\Omega, \\Delta \\beta\\) and \\(\\Delta \\delta\\) . With this notation, the equation of motion can be linearized and written as reported in relation 9 , \\[ \\left\\{\\begin{array}{l} \\dot{\\Delta \\beta}=Y_{\\beta} /\\left(m u_{0}\\right) \\Delta \\beta+\\left(Y_{\\Omega} /\\left(m u_{0}\\right)-1\\right) \\Delta \\Omega+Y_{\\delta} /\\left(m u_{0}\\right) \\Delta \\delta \\\\ \\dot{\\Delta \\Omega}=N_{\\beta} / I_{z z} \\Delta \\beta+N_{\\Omega} / I_{z z} \\Delta \\Omega+N_{\\delta} / I_{z z} \\Delta \\delta \\end{array}\\right. \\] \\(Y_{\\Omega}, N_{\\Omega}, Y_{\\beta}\\) and \\(N_{\\beta}\\) are called stability derivatives and are the derivatives of \\(Y\\) and \\(N\\) with respect to \\(\\Omega\\) and \\(\\beta . Y_{\\delta}, N_{\\delta}\\) are called control derivatives and are the derivatives of \\(Y\\) and \\(N\\) with respect to \\(\\delta\\) . Using the linear definition of the tire characteristic \\(\\left(F_{y i}=C_{a i} \\alpha_{i}\\right)\\) and the definition of the axle slips (relations ?? and ??), equation 9 can be written in matrix form, as shown in equation 10. \\[ \\left[\\begin{array}{c} \\dot{\\Delta \\beta} \\\\ \\dot{\\Delta \\Omega} \\end{array}\\right]=\\left[\\begin{array}{cc} -\\frac{C_{a F}+C_{a R}}{M u_{0}} & \\frac{C_{a R} L_{R}-C_{a F} L_{F}-M u_{0}^{2}}{M u_{0}^{2}} \\\\ \\frac{C_{a R} L_{R}-C_{a F} L_{F}}{I_{z z}} & -\\frac{C_{a F} L_{F}^{2}+C_{a R} L_{R}^{2}}{u_{0} I_{z z}} \\end{array}\\right]\\left[\\begin{array}{c} \\Delta \\beta \\\\ \\Delta \\Omega \\end{array}\\right]+\\left[\\begin{array}{c} \\frac{C_{a F}}{\\tau_{D} M u_{0}} \\\\ \\frac{C_{a F} L_{F}}{\\tau_{D} I_{z z}} \\end{array}\\right] \\Delta \\delta \\] where \\(\\tau_{D}\\) is the steering ratio, considered as fixed in this case. The axle cornering stiffness \\(\\left(C_{a F}\\right.\\) and \\(\\left.C_{a R}\\right)\\) are considered as fixed and can be fitted using the axle characteristic in the linear region. This assumption is valid if the lateral acceleration is low. \\(C_{a F}\\) \\(C_{a R}\\) \\(12418.38\\) \\(45441.63\\) Table 6: Axle cornering stiffness Figure 3: Linear axle model using cornering stiffness The data-test used for the estimation of the vertical moment of inertia consists of a random steer test at a constant speed. The vehicle speed \\(u_{0}\\) is the mean of the test vehicle speed during the test and the steering ratio \\(\\left(\\tau_{D}\\right)\\) is computed by a simple fitting between the steering angle at the wheels and the one at the hand-wheel. Once all the data are computed, the yaw moment of inertia can be estimated minimizing the difference between the linear simulation of the yaw rate and the measured one. The estimation results are reported in table 7 . \\[ \\begin{gathered} \\operatorname{minimize}_{I_{z z}}\\left(\\Omega_{\\text {sim }}-\\Omega\\right)^{2} \\\\ \\hline I_{z z}\\left(K g m^{2}\\right) \\\\ \\hline 72.75 \\\\ \\hline \\end{gathered} \\] Table 7: Yaw moment of inertia Having now all the necessary data, the analytical transfer function can be plotted with the estimated one from the data-test (figure 4). It must be considered that the linear system is a strong approximation of the vehicle behaviour. Besides, the singletrack model does not consider some important effects that modify the vehicle dynamics, as the load transfer. For this reason, the mismatch between the analytical and the experimental transfer function is justified. Figure 4: Analytical and experimental yaw-rate transfer function","title":"Vertical Vehicle Moment of Inertia Estimation"},{"location":"data-analysis-DMT/Experimental%20Measurement/ExperimentalMeasurement/#revision-history","text":"V1 23/12/2022 Updated values (missing values:Wheel Spin Correction, axle cornering stiffness and Moment of Inertia) Ignas Pavirzis","title":"Revision History"},{"location":"data-analysis-DMT/Repo%20Usage/00-How-to-get-started/","text":"Get Started Software to download Visual Studio Code Matlab (version 2022a) Simulink GitBash (only for Windows) GitHub setup Make a Github account with your accademic email (you can link to the same account more emails, so you can add also your personal email address) and send to the CT your git username (if you don't have add it to the form of the recruiting). After being enabled by the CT you can access to the Git of the team in which there are the repositories of the DMT division. Furthermore if you have Windows you will need to download also Git bash . Then to properly set the SSH key to make your computer communicate correctly with the Github portal (both Mac and Windows) Follow these steps: 1) Open Git Bash for Windows or a terminal for Mac 2) check if there is already an existing SSH key with the command ls -al ~/.ssh This command lists the files in your .ssh directory, if they exist. By default, the filenames of supported public keys for GitHub are id_rsa.pub, id_ecdsa.pub, id_ed25519.pub. 3) If there are no existing key, you have to proceed by creating a new one. Paste the text below, substituting in your GitHub email address. ssh-keygen -t ed25519 -C \"your_email@example.com\" 4) When you're prompted to \"Enter a file in which to save the key\" press Enter. This accepts the default file location. 5) At the prompt, type a secure passphrase ( is better to use an empty passphrase ). Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again] 6) Ensure the ssh-agent is running or start it manually. eval \"$(ssh-agent -s)\" 7) Add your SSH private key to the ssh-agent. If you created your key with a different name, or if you are adding an existing key that has a different name, replace id_ed25519 in the command with the name of your private key file. ssh-add ~/.ssh/id_ed25519 8) Add the SSH key to your account on GitHub. For more information, see \"Adding a new SSH key to your GitHub account\" . If you encountered any problems, take a look at the Official Github documentation . Download a repo of the team: Go to the repo of the vehicle model in the Github of the team and click on the button \"Code\" and copy the link for the cloning that you have to paste in the Github desktop app In a Terminal for Mac or with Git Bash for Windows in the folder in which you want to download the repo (usually is useful to create a GitHub folder in which download all the repo): git clone --recurse-submodules git@github.com:eagletrt/data-analysis.git Matlab Setup First of all check that you have installed the correct version of matlab to avoid incompatibility problems when using the files. This first section is crucial for properly setting the Matlab environment so that it can execute the model correctly. These are the toolboxes that you need to install manually: Control System Toolbox Curve Fitting Toolbox Embedded Coder Fuzzy Logic Toolbox MATLAB Coder MinGW-w64 C/C++ Compiler ( only for Windows ) Optimization Toolbox Signal Processing Toolbox Simscape Simscape Electrical Simscape Multibody Simulink Simulink 3D Animation Simulink Coder Simulink Control Design Symbolic Math Toolbox System Identification Toolbox Clothoids (This latest toolbox and its documentation can be found at https://github.com/ebertolazzi/Clothoids/releases and can be used in place of the folder \u2018 Clothoids \u2019 present in the old vehicle model. We suggest to follow the installation instructions described on the link page given that the toolbox is constantly updated by professor Bertolazzi. During the installation phase, Matlab may require to install an additional package called \u2018 MATLAB Support for MinGW-w64 C/C++ Compiler \u2019. Run Matlab/Simulink Model Open Matlab (after the initial setup described above for first time users) Open the local folder where you have download the repository of the model from GitHub Now on Matlab left coloumn you can open the files and folders of the model, in particular the main.m file!","title":"Get Started"},{"location":"data-analysis-DMT/Repo%20Usage/00-How-to-get-started/#get-started","text":"","title":"Get Started"},{"location":"data-analysis-DMT/Repo%20Usage/00-How-to-get-started/#software-to-download","text":"Visual Studio Code Matlab (version 2022a) Simulink GitBash (only for Windows)","title":"Software to download"},{"location":"data-analysis-DMT/Repo%20Usage/00-How-to-get-started/#github-setup","text":"Make a Github account with your accademic email (you can link to the same account more emails, so you can add also your personal email address) and send to the CT your git username (if you don't have add it to the form of the recruiting). After being enabled by the CT you can access to the Git of the team in which there are the repositories of the DMT division. Furthermore if you have Windows you will need to download also Git bash . Then to properly set the SSH key to make your computer communicate correctly with the Github portal (both Mac and Windows) Follow these steps: 1) Open Git Bash for Windows or a terminal for Mac 2) check if there is already an existing SSH key with the command ls -al ~/.ssh This command lists the files in your .ssh directory, if they exist. By default, the filenames of supported public keys for GitHub are id_rsa.pub, id_ecdsa.pub, id_ed25519.pub. 3) If there are no existing key, you have to proceed by creating a new one. Paste the text below, substituting in your GitHub email address. ssh-keygen -t ed25519 -C \"your_email@example.com\" 4) When you're prompted to \"Enter a file in which to save the key\" press Enter. This accepts the default file location. 5) At the prompt, type a secure passphrase ( is better to use an empty passphrase ). Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again] 6) Ensure the ssh-agent is running or start it manually. eval \"$(ssh-agent -s)\" 7) Add your SSH private key to the ssh-agent. If you created your key with a different name, or if you are adding an existing key that has a different name, replace id_ed25519 in the command with the name of your private key file. ssh-add ~/.ssh/id_ed25519 8) Add the SSH key to your account on GitHub. For more information, see \"Adding a new SSH key to your GitHub account\" . If you encountered any problems, take a look at the Official Github documentation .","title":"GitHub setup"},{"location":"data-analysis-DMT/Repo%20Usage/00-How-to-get-started/#download-a-repo-of-the-team","text":"Go to the repo of the vehicle model in the Github of the team and click on the button \"Code\" and copy the link for the cloning that you have to paste in the Github desktop app In a Terminal for Mac or with Git Bash for Windows in the folder in which you want to download the repo (usually is useful to create a GitHub folder in which download all the repo): git clone --recurse-submodules git@github.com:eagletrt/data-analysis.git","title":"Download a repo of the team:"},{"location":"data-analysis-DMT/Repo%20Usage/00-How-to-get-started/#matlab-setup","text":"First of all check that you have installed the correct version of matlab to avoid incompatibility problems when using the files. This first section is crucial for properly setting the Matlab environment so that it can execute the model correctly. These are the toolboxes that you need to install manually: Control System Toolbox Curve Fitting Toolbox Embedded Coder Fuzzy Logic Toolbox MATLAB Coder MinGW-w64 C/C++ Compiler ( only for Windows ) Optimization Toolbox Signal Processing Toolbox Simscape Simscape Electrical Simscape Multibody Simulink Simulink 3D Animation Simulink Coder Simulink Control Design Symbolic Math Toolbox System Identification Toolbox Clothoids (This latest toolbox and its documentation can be found at https://github.com/ebertolazzi/Clothoids/releases and can be used in place of the folder \u2018 Clothoids \u2019 present in the old vehicle model. We suggest to follow the installation instructions described on the link page given that the toolbox is constantly updated by professor Bertolazzi. During the installation phase, Matlab may require to install an additional package called \u2018 MATLAB Support for MinGW-w64 C/C++ Compiler \u2019.","title":"Matlab Setup"},{"location":"data-analysis-DMT/Repo%20Usage/00-How-to-get-started/#run-matlabsimulink-model","text":"Open Matlab (after the initial setup described above for first time users) Open the local folder where you have download the repository of the model from GitHub Now on Matlab left coloumn you can open the files and folders of the model, in particular the main.m file!","title":"Run Matlab/Simulink Model"},{"location":"data-analysis-DMT/Repo%20Usage/01-Data-Extraction/","text":"1_Data Extraction The files related to this modality are in the folder 1_Data Extraction and Filtering This mod allow to import data from the telemetry of the car (files .csv) and convert them in file .mat, allowing us to use them also for simulations with our vehicle model. Before running the main.m file, you have to place the files from the telemetry in the folder File_Telemetry(csv) . Place them inside a folder called with the date of the test day and inside this folder name the single manuevre of the car with a understandable name. The file from the telemetry (.csv) are stored in the drive of the team on: /Teams/Racing Team/Track data: ( Click here for the direct link ) Example: File_Telemetry(csv)/2022_08_15/Acceleration Povo #1 Now you can run the main.m file choosing the 1st mode. THE PROCESS IS COMPLITELY AUTOMATIC AND IT'IS DESCRIBED BELOW: The selection of this mode runs the file csv_to_mat.m ; this files calls all the subscripts related to this mod. In the beginning it is shown an interactive menu in which you can choose the single telemetry folder you want to convert. Make sure to select the subfolder of the telemetry called: Parsed otherwise the script fails. For Example a path can be: Then the script runs automatically the function data_loading_csv.m which loads the .csv data and compute the sampling frequencies of each sensor After loading, there is the automatic filtering of the noise performed by the script filtTheData.m which applies a low pass filter. The frequecy of the low pass filter is chosen by using the mode 4 (Fourier Transform). The pedals and the steering wheel have an higher cutoff frequency because they are less affected by the noise, and so with higher cutoff frequencies we are able to reduce the distorsion applied by the filter. Then there is Data_estimator.m which extimates some features and parameters from the data of the sensors that can't be measured directly (slip, forces ecc...). This script uses the folder Estimation Function At the end there is the cutting procedure which plots the data and allows you to choose the start and end time you want. With the new procedure you can cut also more then a single piece of data from the .csv file! The procedure is ruled by an interactive menu which ask you every time if you want to cut another piece. To save a piece of data you must always cut!!!! N.B. Always cut head and tails of the data to avoid problems with the GPS!!! At the end of the script the data .csv already processed are automatically deleated by the script if you wanted. The .csv are heavy files so after the compete cutting procedure it is preferable to delete them. Do not delete the folder Test otherwise GitHub will automatically deleate the folder File_Telemetry(csv). To keep track of the data aquired compile the file Data Report.xlsx in the home folder The data elaborated are stored in their filter and unfiltered version in the folder File_Telemetry(mat)","title":"1_Data Extraction"},{"location":"data-analysis-DMT/Repo%20Usage/01-Data-Extraction/#1_data-extraction","text":"The files related to this modality are in the folder 1_Data Extraction and Filtering This mod allow to import data from the telemetry of the car (files .csv) and convert them in file .mat, allowing us to use them also for simulations with our vehicle model. Before running the main.m file, you have to place the files from the telemetry in the folder File_Telemetry(csv) . Place them inside a folder called with the date of the test day and inside this folder name the single manuevre of the car with a understandable name. The file from the telemetry (.csv) are stored in the drive of the team on: /Teams/Racing Team/Track data: ( Click here for the direct link ) Example: File_Telemetry(csv)/2022_08_15/Acceleration Povo #1 Now you can run the main.m file choosing the 1st mode. THE PROCESS IS COMPLITELY AUTOMATIC AND IT'IS DESCRIBED BELOW: The selection of this mode runs the file csv_to_mat.m ; this files calls all the subscripts related to this mod. In the beginning it is shown an interactive menu in which you can choose the single telemetry folder you want to convert. Make sure to select the subfolder of the telemetry called: Parsed otherwise the script fails. For Example a path can be: Then the script runs automatically the function data_loading_csv.m which loads the .csv data and compute the sampling frequencies of each sensor After loading, there is the automatic filtering of the noise performed by the script filtTheData.m which applies a low pass filter. The frequecy of the low pass filter is chosen by using the mode 4 (Fourier Transform). The pedals and the steering wheel have an higher cutoff frequency because they are less affected by the noise, and so with higher cutoff frequencies we are able to reduce the distorsion applied by the filter. Then there is Data_estimator.m which extimates some features and parameters from the data of the sensors that can't be measured directly (slip, forces ecc...). This script uses the folder Estimation Function At the end there is the cutting procedure which plots the data and allows you to choose the start and end time you want. With the new procedure you can cut also more then a single piece of data from the .csv file! The procedure is ruled by an interactive menu which ask you every time if you want to cut another piece. To save a piece of data you must always cut!!!! N.B. Always cut head and tails of the data to avoid problems with the GPS!!! At the end of the script the data .csv already processed are automatically deleated by the script if you wanted. The .csv are heavy files so after the compete cutting procedure it is preferable to delete them. Do not delete the folder Test otherwise GitHub will automatically deleate the folder File_Telemetry(csv). To keep track of the data aquired compile the file Data Report.xlsx in the home folder The data elaborated are stored in their filter and unfiltered version in the folder File_Telemetry(mat)","title":"1_Data Extraction"},{"location":"data-analysis-DMT/Repo%20Usage/02-Data-Analysis/","text":"2_Data Analysis The 2nd mode allow you to load a set of data .mat converted with 1st mode for plotting the main parameters before and after the filtering. With this mode you can choose with an interactive menu both the raw file .mat or the filtered one and automatically it will load also the other one for plotting both of them overlapped. The path where you can find the files that you have to load is similar to this one: And the file are similar to these one, always in couples _filt.mat and .mat","title":"2_Data Analysis"},{"location":"data-analysis-DMT/Repo%20Usage/02-Data-Analysis/#2_data-analysis","text":"The 2nd mode allow you to load a set of data .mat converted with 1st mode for plotting the main parameters before and after the filtering. With this mode you can choose with an interactive menu both the raw file .mat or the filtered one and automatically it will load also the other one for plotting both of them overlapped. The path where you can find the files that you have to load is similar to this one: And the file are similar to these one, always in couples _filt.mat and .mat","title":"2_Data Analysis"},{"location":"data-analysis-DMT/Repo%20Usage/03-Noise-estimation/","text":"3_Noise Estimation This mode is used to make an estimation of the noise on the data acquired by the different sensors on the car. First of all, you are asked from which folder to get the .mat data (NoiseMain.m file). N.B. You can load only subfolders of File_Telemetry(mat) like this one!!! The NoiseComputation.m load the data from the selected folder and compute the noise associated to the front & rear wheel encoder, accelerometer and gyroscope. The loading operation is performed in a cycle allowing you to load also other folders to analyze more data for the noise computation. The noise is evaluated as the difference between the original and the filtered signal. The value of the variance associated to each of these is stored in \"3_Noise Estimation/DataError\". (Make sure to delete all the file in this folder if you want to delete the estiamtion of the noise performed in old data sets) Finally NoiseMean.m calculates the mean of all these variances in order to obtain a statistical estimation of the actual noise interference. These final values are stored in \"3_Noise Estimation/Variance\" and then through the NoisePlot scripts we are able to make a comparison between the real noisy signal and the one obtained by adding random noise with the obtained variances to the filtered signals. Note that all the explained procedure is carried out only for the signals of the acceleration along x, those of the front/left encoders and the one coming from the gyroscope related to the yaw rate. This is due to the fact that only for these signals there is a noise generation block in the vehicle model on Simulink. Subsequent developments may foresee the use of some kind of noise models also for other sensors and signals. The file used in the vehicle model are in the folder \"3_Noise Estimation/Variance\"","title":"3_Noise Estimation"},{"location":"data-analysis-DMT/Repo%20Usage/03-Noise-estimation/#3_noise-estimation","text":"This mode is used to make an estimation of the noise on the data acquired by the different sensors on the car. First of all, you are asked from which folder to get the .mat data (NoiseMain.m file). N.B. You can load only subfolders of File_Telemetry(mat) like this one!!! The NoiseComputation.m load the data from the selected folder and compute the noise associated to the front & rear wheel encoder, accelerometer and gyroscope. The loading operation is performed in a cycle allowing you to load also other folders to analyze more data for the noise computation. The noise is evaluated as the difference between the original and the filtered signal. The value of the variance associated to each of these is stored in \"3_Noise Estimation/DataError\". (Make sure to delete all the file in this folder if you want to delete the estiamtion of the noise performed in old data sets) Finally NoiseMean.m calculates the mean of all these variances in order to obtain a statistical estimation of the actual noise interference. These final values are stored in \"3_Noise Estimation/Variance\" and then through the NoisePlot scripts we are able to make a comparison between the real noisy signal and the one obtained by adding random noise with the obtained variances to the filtered signals. Note that all the explained procedure is carried out only for the signals of the acceleration along x, those of the front/left encoders and the one coming from the gyroscope related to the yaw rate. This is due to the fact that only for these signals there is a noise generation block in the vehicle model on Simulink. Subsequent developments may foresee the use of some kind of noise models also for other sensors and signals. The file used in the vehicle model are in the folder \"3_Noise Estimation/Variance\"","title":"3_Noise Estimation"},{"location":"data-analysis-DMT/Repo%20Usage/04-Fourier-Transform/","text":"4_Fourier Transform The 4th mode perform the Fourier Transform and Frequency Domain Analysis With this mode you can choose with an interactive menu both the raw file .mat or the filtered one and automatically it will load also the other one for performing the fourier transform and relative plots. The Fourier Transform is performed to the non filtered data to see where is the true noise spectrum. This plots are useful to see the frequencies of the noise spectrum and are used to decide the more suitable cut off frequencies for the low pass filters used in \"1_Data Extraction and Filtering/Filt/filtTheData\". To decide the cutoff frequency you have to look to the plots and see where the noise is placed and choose a frenquency before the main concentration of noise. The pedals and the steering wheel have an higher cutoff frequency because they are less affected by the noise, and so with higher cutoff frequencies we are able to reduce the distorsion applied by the filter.","title":"4_Fourier Transform"},{"location":"data-analysis-DMT/Repo%20Usage/04-Fourier-Transform/#4_fourier-transform","text":"The 4th mode perform the Fourier Transform and Frequency Domain Analysis With this mode you can choose with an interactive menu both the raw file .mat or the filtered one and automatically it will load also the other one for performing the fourier transform and relative plots. The Fourier Transform is performed to the non filtered data to see where is the true noise spectrum. This plots are useful to see the frequencies of the noise spectrum and are used to decide the more suitable cut off frequencies for the low pass filters used in \"1_Data Extraction and Filtering/Filt/filtTheData\". To decide the cutoff frequency you have to look to the plots and see where the noise is placed and choose a frenquency before the main concentration of noise. The pedals and the steering wheel have an higher cutoff frequency because they are less affected by the noise, and so with higher cutoff frequencies we are able to reduce the distorsion applied by the filter.","title":"4_Fourier Transform"},{"location":"data-analysis-DMT/Repo%20Usage/05-Vehicle_Modules/","text":"Vehicle_Modules (folder) In this folder there are all the Matlab functions and/or data that are used in the vehicle model block in the Simulink file (see below), if you want to modify some parts of the vehicle modelling (such as tire behaviour, model of aerodynamic forces, model of contact forces, motor model, vehicle data, ecc.). vehicle_data.m In this file we have all the data of the car needed for the simulation . After every car change, they must be updated. Some values can be obtained only by doing some tests on the physical car. load... .m files In the loadControlData.m file we simply load the values from the vehicle_data.m file needed for the control. In the loadInitialConditions.m file we load the initial conditions. ... model.m files For the different parts of the vehicle, we have some models including the model of the tire. For the description of these models, you can refer to the pdf file \"10 Dof Vehicle Model Updating\". All these equations are exported from Maple\u2019s files. getSimualtionParams\u2026 see maneuvers description Git submodules The folder Vehicle_modules is common to all the repo of the DMT team. So we built a submodule in order to have all the files updated in all the repo. The submodule is an external small-repo in which is contained the folder Vehicle Modules and it is linked to all our repo. After having done some changes to this folder during your work on a big repository, you will need to open the terminal in the folder of the big-repo you were working on. For those working with Windows, you will need to open the terminal inside the folder of the big repository by right-clicking with the mouse inside the folder and selecting Git Bash to open it. Alternatively, you can open the folder inside Visual Studio Code and select Git Bash as terminal and work directly in there. Then it will be necessary to insert the type of operation you want to perform with this scrip (BOTH FOR MAC AND WINDOWS). If you want to upload the changes you will need to type ./submodule_script push Then after compliting the push operation the small-repo for the vehicle modules is up to date and automatically pulled also in the other big repo of the team DMT. Every day before starting with your work type in a terminal (MAC) or in GitBash windows to pull remote changes. ./submodule_script pull","title":"Vehicle_Modules (folder)"},{"location":"data-analysis-DMT/Repo%20Usage/05-Vehicle_Modules/#vehicle_modules-folder","text":"In this folder there are all the Matlab functions and/or data that are used in the vehicle model block in the Simulink file (see below), if you want to modify some parts of the vehicle modelling (such as tire behaviour, model of aerodynamic forces, model of contact forces, motor model, vehicle data, ecc.). vehicle_data.m In this file we have all the data of the car needed for the simulation . After every car change, they must be updated. Some values can be obtained only by doing some tests on the physical car. load... .m files In the loadControlData.m file we simply load the values from the vehicle_data.m file needed for the control. In the loadInitialConditions.m file we load the initial conditions. ... model.m files For the different parts of the vehicle, we have some models including the model of the tire. For the description of these models, you can refer to the pdf file \"10 Dof Vehicle Model Updating\". All these equations are exported from Maple\u2019s files. getSimualtionParams\u2026 see maneuvers description","title":"Vehicle_Modules (folder)"},{"location":"data-analysis-DMT/Repo%20Usage/05-Vehicle_Modules/#git-submodules","text":"The folder Vehicle_modules is common to all the repo of the DMT team. So we built a submodule in order to have all the files updated in all the repo. The submodule is an external small-repo in which is contained the folder Vehicle Modules and it is linked to all our repo. After having done some changes to this folder during your work on a big repository, you will need to open the terminal in the folder of the big-repo you were working on. For those working with Windows, you will need to open the terminal inside the folder of the big repository by right-clicking with the mouse inside the folder and selecting Git Bash to open it. Alternatively, you can open the folder inside Visual Studio Code and select Git Bash as terminal and work directly in there. Then it will be necessary to insert the type of operation you want to perform with this scrip (BOTH FOR MAC AND WINDOWS). If you want to upload the changes you will need to type ./submodule_script push Then after compliting the push operation the small-repo for the vehicle modules is up to date and automatically pulled also in the other big repo of the team DMT. Every day before starting with your work type in a terminal (MAC) or in GitBash windows to pull remote changes. ./submodule_script pull","title":"Git submodules"},{"location":"data-analysis-DMT/Repo%20Usage/06-Release-Notes/","text":"Release Notes In this section you will find the updates of the model 31/08/2022: Reconstruct the repository from scratch Work in progress Sistemare segnale di torque appena si ha il segnale di corrente inverter Frequenze filtri Estimation files e Controllare script handling curves Cambio ghiera encoder FR, controllare picchi sborati sensore sterzo","title":"Release Notes"},{"location":"data-analysis-DMT/Repo%20Usage/06-Release-Notes/#release-notes","text":"In this section you will find the updates of the model 31/08/2022: Reconstruct the repository from scratch","title":"Release Notes"},{"location":"data-analysis-DMT/Repo%20Usage/06-Release-Notes/#work-in-progress","text":"Sistemare segnale di torque appena si ha il segnale di corrente inverter Frequenze filtri Estimation files e Controllare script handling curves Cambio ghiera encoder FR, controllare picchi sborati sensore sterzo","title":"Work in progress"},{"location":"data-analysis-DMT/Repo%20Usage/Home/","text":"Data Analysis Welcome to the Data Analysis wiki! TABLE OF CONTENTS How to get started Data Extraction and Filtering Mod 1 inports the raw data (.csv) from the telemetry and perform a noise filtering and a cut for the extraction of the relevant part only. From the data acquired from the sensors are also estimated other indirect parameters, such as lateral and longitudinal slip and forces. The data are saved in .mat files Data Analysis (Plot) Mod 2 plots the data .mat elaborated with mode 1 Noise Estimation Mod 3 performs the comparison between the data .mat before and after the filtering aaplied with mod 1. It allows to estimate the main features of the noise of each sensor in order to replicate them in the vehicle model Fourier Transform Mod 4 allows to perform a fourier transform of the data .mat to understand the noise spectrum of each sensor and properly choose an adequate cut-off frequency for the low pass filters used in mod 1 Vehicle Modules Release Notes To work with this repo open and run the file main.m in which you can select the mod!!! The interactive menu for the mod selection is:","title":"Data Analysis"},{"location":"data-analysis-DMT/Repo%20Usage/Home/#data-analysis","text":"Welcome to the Data Analysis wiki!","title":"Data Analysis"},{"location":"data-analysis-DMT/Repo%20Usage/Home/#table-of-contents","text":"How to get started Data Extraction and Filtering Mod 1 inports the raw data (.csv) from the telemetry and perform a noise filtering and a cut for the extraction of the relevant part only. From the data acquired from the sensors are also estimated other indirect parameters, such as lateral and longitudinal slip and forces. The data are saved in .mat files Data Analysis (Plot) Mod 2 plots the data .mat elaborated with mode 1 Noise Estimation Mod 3 performs the comparison between the data .mat before and after the filtering aaplied with mod 1. It allows to estimate the main features of the noise of each sensor in order to replicate them in the vehicle model Fourier Transform Mod 4 allows to perform a fourier transform of the data .mat to understand the noise spectrum of each sensor and properly choose an adequate cut-off frequency for the low pass filters used in mod 1 Vehicle Modules Release Notes To work with this repo open and run the file main.m in which you can select the mod!!! The interactive menu for the mod selection is:","title":"TABLE OF CONTENTS"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/1_TyreModelFitting/","text":"Tyre Model Fitting The tire characteristic has a very strong impact on vehicle behaviour. For this reason, the vehicle model must include a precise tire model which fits the used tire attitude. Usually, the Pacejka model is used to describe the complete behaviour of the tire by means of a semi-empirical approach. Unfortunately, to extract all the Pacejka parameters - more than fifty -, some very expensive tests should be performed. Hence, to have a better data fitting vehicle model, some tests with the vehicle can be performed and the parameters of a simplified tire model can be fitted using the data from the tests. In this way, it is possible to have an approximation of the tire model that holds over certain assumptions. In other words, a simplified tire model can be used in order to have a less general but more data-fitting vehicle model. In this section, some simplified tire models are presented and discussed. Once the best model will be chosen, the fitting procedure is explained in detail, reporting the fitting results. For all the tire model include here, the effects of the self-aligning torque are neglected. This because we have no way to measure them during the tests and, for this reason, the model notation results useless for our work. Tire Model Definition Burkhardt Friction Model In the control algorithms, the Burkhardt model is usually used because it is simple and can be a good approximation of the real tire characteristic - ref. [19] -. This model uses an exponential function to approximate tire behaviour. \\[ \\mu(s, V)=\\left[C_{1}\\left(1-e^{-C_{2} s}\\right)-C_{3} s\\right] e^{-C_{4} s V} \\] Figure 5: Burkhardt model \\(\\kappa\\) is the total slip and \\(V\\) is the vehicle velocity. The coefficients \\(C_{i}\\) are the model coefficients and give the shape of the curve. In order to compute the tire force, the friction coefficient has to be multiplied by the vertical load. Finally, to split the force in its longitudinal and lateral component, the resultant force must be scaled with the normalized longitudinal or lateral slip \\(-\\lambda / \\kappa\\) or \\(\\alpha / \\kappa\\) -. The model has to be fitted in both longitudinal and lateral direction to find \\(\\mu_{x}(\\lambda, V)\\) and \\(\\mu_{y}(\\alpha, V)\\) . In the end, the tire model will be as follow. \\[ \\left\\{\\begin{array}{l} F_{x}=\\mu_{x}(\\lambda, V) F_{z} \\frac{\\lambda}{|\\kappa|} \\\\ F_{y}=\\mu_{y}(\\alpha, V) F_{z} \\frac{\\alpha}{|\\kappa|} \\end{array}\\right. \\] This model has few parameters to find in order to fit the model: 8 for both longitudinal and lateral case - \\(C_{i j}\\) with \\(i=\\{1,2,3,4\\}\\) and \\(j=\\{x, y\\}-\\) - However, the part of this curve in which the slip is close to 1 has a decreasing fashion. This is in contrast with the real tire behaviour in which, after a certain value of slip, the force tends to stabilize around a constant value. Besides, real tire behaviour can be linearized before the peak using a linear function. In this model, this property is not represented because of the exponential function. Semi-Empirical Tire Model In the thesis of Fern\u00e1ndez [8] a Semi-empirical brush model is presented and implemented in a 10 DoF vehicle model. This tire model partially solves the problems that the Burkhardt model has. Moreover, this model is built in order to have easyto-fit parameters, that can well approximate the real behaviour of the tire by means of a piecewise function. In this type of model, the combined behaviour is modelled by means of a circle. This is a strong simplification because the different friction coefficients depending on the force direction are neglected. \\[ \\psi=\\frac{C}{3 \\mu} \\kappa \\] The term \\(\\psi\\) indicates the working region of the tire: if \\(\\psi\\) is smaller than one, the tire is working in linear region, otherwise, the tire is working above the peak. Using this distinction, the following piecewise definition can be written. Figure 6: Semi-Empirical Brush model The parameter \\(F\\) , given by the equation 14. has to be multiply by the value of the slips to obtain the tire forces - longitudinal or lateral -. \\[ F_{x}=F \\lambda \\quad ; \\quad F_{y}=F \\alpha \\] The model parameters are \\(C\\) , that is the normalized thread stiffness, and \\(\\mu\\) and \\(\\mu_{v}\\) , which correspond to the static and kinetic friction coefficients between the road and the tire. The semi-empirical brush model has a good accuracy in normal driving conditions, where the tire behaviour is linear. Nevertheless, the piecewise definition of \\(F\\) could give some numerical problems when the tire works around the peak. The advantage of this model is that it has very few parameters to estimate in order to have the complete model definition. Magic Formula Tire Model Both the Burkardt and the Semi-empirical brush model has some problems which make them difficult to use in a simulation environment. For this reason a new tire model is defined to be simple and easy to fit but also able to incorporate all the most important features of the tire characteristic. This model can be seen as a simplified version of the Pacejka one - version 96 - in which some of the contributes are neglected - for example, the contribute related to the camber is not modeled -. The model is based on the Magic Formula theory that allows to model a very non linear effects using a fixed function, called magic formula, and scale the inputs and the outputs to fit the magic formula shape. In our case, the magic formula is defined in relation 16, \\[ Y=D \\sin [C \\arctan (B x)] \\] Figure 7: Example of Magic Formula In expression 16, the term \\(D\\) corresponds to the peak value, the term \\(B\\) gives the initial slope of the curve and the term \\(C\\) is a shaping factor for the non-linear part. The term \\(Y\\) can be substituted with the tire forces \\(F_{k}-k=\\{x, y\\}\\) - and the term \\(x\\) with the tire slip \\(s\\) , that can be longitudinal or lateral. \\[ F_{k}=\\mu_{k} F_{z} \\sin \\left[C_{k} \\arctan \\left(B_{k} s\\right)\\right] \\] For what concerns the tire, the term \\(D\\) is the product of the friction coefficient \\((\\mu)\\) and the vertical load \\(\\left(F_{z}\\right)-D=\\mu F_{z}\\) - and \\(\\mu\\) decreases linearly with \\(F_{z}\\) . This is an important feature that must be included in the model. Usually, the contribute connected to \\(F_{z}\\) is modelled refereeing to a nominal vertical load \\(F_{z 0}\\) . In this analysis, the nominal force is chosen equal to a quarter of the vehicle weight \\(-F_{z 0}=M g / 4-\\) . \\[ \\mu=p_{D 1}+p_{D 2} d F_{z}=p_{D 1}+p_{D 2}\\left(\\frac{F_{z}}{F_{z 0}}-1\\right) \\] Focusing on the longitudinal or cornering stiffness, i.e. the initial slope of the characteristic curve, the behaviour is different for the longitudinal and lateral case: the longitudinal stiffness - \\(K_{x k}\\) - has a linear and an exponential part, functions of the vertical force \\(F_{z}\\) \\[ K_{x k}=F_{z}\\left(p_{K x 1}+p_{k x 2} d F_{z}\\right) e^{-p_{K x 3} d f_{z}} \\] the lateral cornering stiffness - \\(K_{y a}\\) -, instead, is a trigonometric function of the vertical load and can be written as follow \\[ K_{y a}=F_{z 0} p_{K y 1} \\sin \\left(2 \\arctan \\left(\\frac{F_{z}}{p_{k y 2} F_{z 0}}\\right)\\right) \\] The tire stiffness can be found looking at the magic formula definition: linearizing the formula around the origin, the longitudinal or cornering stiffness can be written as equal to \\(K=B C D\\) . Using this last statement and considering the term \\(C\\) as a constant \\(C=p_{C 1}-, B\\) can be computed by inverting the linearized expression. \\[ B=\\frac{K}{C D} \\] Finally, in order to consider also the coupled behaviour, the tire adherence condition can be represented through an approximation of the ellipse of adherence. This approximation derives from the fact that the total tire force has the same direction as the total slip. For this reason, the total force can be scaled using the normalized tire slip to find the longitudinal and lateral forces. \\[ \\left\\{\\begin{array}{l} F_{x}=\\mu_{x} F_{z} \\sin \\left[C_{x} \\arctan \\left(B_{x} \\lambda\\right)\\right] \\frac{\\lambda}{|\\kappa|} \\\\ F_{y}=\\mu_{y} F_{z} \\sin \\left[C_{y} \\arctan \\left(B_{y} \\alpha\\right)\\right] \\frac{\\alpha}{|\\kappa|} \\end{array}\\right. \\] \\(\\kappa\\) is the total slip \\(-\\kappa=\\sqrt{\\lambda^{2}+\\alpha^{2}}-\\) . To sum up, the model parameters that have to be fitted are 11, 6 for the longitudinal and 5 for the lateral case - collected in table 8 -. This model represents a strong simplification with respect to the complete Pacejka one. However, it is a good compromise between model reliability and simplicity, making the parameters estimable using the experimental tests. Case \\(\\mu\\) \\(K\\) Others Longitudinal \\(p_{D x 1}, p_{D x 1}\\) \\(p_{K x 1}, p_{K x 2}, p_{K x 3}\\) \\(C_{x}\\) Lateral \\(p_{D y 1}, p_{D y 1}\\) \\(p_{K y 1}, p_{K y 2}\\) \\(C_{y}\\) Table 8: Magic Formula - coefficients to fit Longitudinal Model Fitting The longitudinal tire model fitting is performed in acceleration condition. This because the longitudinal velocity estimation gives a more accurate results, reflecting in a more reliable slip computation, and the tire force, computed using the motor torque, are estimated in a more accurate way. The longitudinal slips are computed using the sensor fusion longitudinal velocity \\(u_{S F}\\) and the forces are estimated using the SOSM technique. The manoeuvre used for the fitting are pure longitudinal tests - acceleration in our case -. Both the full-throttle and the double throttle-step are used. The fitting procedure is firstly tested using the simulated data, in this way the results should be similar to the Pacejka model implemented in the simulation environment. Then, the fitting is applied to the real telemetry data. Data Fitting from Synthetic Telemetry Data The fitting procedure is performed via grey-box approach. A longitudinal tire model is built with the model parameters free to vary. The model takes as inputs the longitudinal slip and the vertical tire load and returns the longitudinal force that is compared with the estimated force from the telemetry data post-processing. The best matching corresponds to the best fitting parameters. In order to govern the fitting and to have a physical validity of the fitted model, the parameters variation are bounded. For example, the peak value has to always decrease with the increasing of the vertical load hence, \\(p_{D 2}\\) has to be always negative. Figure 8: Fitting data and results for longitudinal tire model (Simulation case) In figure 8 the data from the simulation and the fitted model are reported. As can be seen from the figure, the characteristic peak has never reached from the data-tests. For this reason, the peak position and the characteristic profile above the peak are estimated with a high level of uncertainty. This is confirmed by plotting the fitted model with the full Pacejka model implemented in the simulation environment - figures 9 and 10 - Figure 9: Longitudinal tire model comparison Figure 10: Longitudinal stiffness and peak value comparison In order to correct the peak value, the model can be refitted by fixing \\(p_{D 1}\\) . However, to make this procedure possible, the actual value of the peak force must be known. In our case, \\(p_{D 1}\\) is set equal to \\(2.45\\) . The new fitting results are reported in figures 11 and 12 Figure 11: Longitudinal tire model comparison - fixing \\(p_{D 1}\\) Figure 12: Longitudinal stiffness and peak value comparison - fixing \\(p_{D 1}\\) From figure 11, it can be seen that the behaviour above the peak is not respected. This is due to an incorrect estimation of the parameter \\(p_{C 1}\\) , which is caused by the missing of useful data in that characteristic region. Never the less, the behaviour of the tire until the peak is well estimated. In table 9 the results of the two fitting procedures are reported. The static load \\(F_{z 0}\\) is set equal to \\(802 N\\) . Case \\(p_{D 1}\\) \\(p_{D 2}\\) \\(p_{K 1}\\) \\(p_{K 2}\\) \\(p_{K 3}\\) \\(p_{C 1}\\) First Fitting \\(1.852\\) \\(-0.7178\\) \\(59.0996\\) \\(-0.5021\\) \\(0.5996\\) \\(1.4751\\) Fixing \\(p_{D 1}\\) \\((2.45)\\) \\(-0.8206\\) \\(57.1712\\) \\(-1.3594\\) \\(0.635\\) \\(1.2065\\) Table 9: Longitudinal fitting results (Simulation case) Data Fitting from Real Telemetry Data Also, using the real telemetry data the fitting technique follows the same grey-box approach followed using the synthetic data. Now, no-prior knowledge is given about the tire model hence we have to trust the fitting results. In figure 13 the fitting results are illustrated. As can be seen, the peak is never reached. For this reason, the peak value is probably underestimated. In table 10 the result of the fitting procedure is reported. \\(p_{D 1}\\) \\(p_{D 2}\\) \\(p_{K 1}\\) \\(p_{K 2}\\) \\(p_{K 3}\\) \\(p_{C 1}\\) \\(1.0688\\) \\(-0.4473\\) \\(42.1562\\) \\(-0.4934\\) \\(0.3216\\) \\(1.2042\\) Table 10: Longitudinal fitting results Figure 13: Fitting data and results for longitudinal tire model Figure 14: Cornering stiffness and peak value Lateral Data Fitting The lateral data fitting is a bit more challenging because the tyre forces are not available. However, the lateral slips and the vertical loads are given for all four wheels. Hence, the approach presented by Guiggiani [10] can be employed. The total front or rear lateral force is the sum of the left and right lateral forces that are a function of the same parameters and of the lateral slips and the vertical loads of the tires - relation 23 -. Using this definition of the total axle lateral force, the parameters can be fitted for the front and for the rear axle, taking as input the vertical load and the lateral slip of the wheels and computing the matching with the axle force. \\[ \\begin{aligned} F_{y i} & =F_{y i R}\\left(\\alpha_{i R}, F_{z i R}\\right)+F_{y i L}\\left(\\alpha_{i L}, F_{z i L}\\right) \\\\ & =F_{z i R} \\mu_{y i} \\sin \\left[C_{y} \\arctan \\left(B_{y} \\alpha_{i R}\\right)\\right]+F_{z i L} \\mu_{y i} \\sin \\left[C_{y} \\arctan \\left(B_{y} \\alpha_{i L}\\right)\\right] \\end{aligned} \\] where \\(i=\\{F, R\\}\\) . Also, in this case, both the fitting with synthetic and real telemetry data are presented. For the slip computation, the lateral velocity is computed using the Luemberger observer and the lateral forces by means of the SOSM. In the simulation, the performed tests are constant steering angle manoeuvre increasing speed while the real telemetry data are extracted from the steering pads. Data Fitting from Synthetic Telemetry Data In principle, the front and rear tire can have slightly different behaviour. For this reason, the fitting is performed separately for the front and the rear. The complete model is fitted using the data. The results are reported in figures 15,16 and 17 Figure 15: Lateral axle fitting results Figure 16: Lateral tire model comparison Figure 17: Cornering stiffness and peak value comparison From the above figures, it can be noticed that the cornering stiffness does not follow the behaviour dictated by the complete Pacejka model. In order to solve this problem, both axles can be used for the fitting since, in simulation, the tire behaviour is almost the same - except for the camber effects - Figures 18, 19 and 20 illustrates the fitting results in this case. Figure 18: Lateral axle fitting results - using both axles Figure 19: Lateral tire model comparison - using both axles Figure 20: Cornering stiffness and peak value comparison - using both axles In this case, the peak value of the lateral force is well recognizable from the saturation of the synthetic tests data. However, as can be seen in figure 20, the cornering stiffness behaviour is not well reproduced. The working region is probably too narrow in term of vertical load to fit this aspect of the tyre characteristic. Nevertheless, around the tire working region, the fitting results can still be a good approximation of the real tire behaviour. Case \\(p_{D 1}\\) \\(p_{D 2}\\) \\(p_{K 1}\\) \\(p_{K 2}\\) \\(p_{C 1}\\) First fit. (F) \\(2.9013\\) \\(-0.1418\\) \\(34.9586\\) \\(1.7937\\) \\(1.1720\\) First fit. (R) \\(2.4433\\) \\(-0.3292\\) \\(45.1309\\) \\(2.2526\\) \\(1.1694\\) Fit both axles \\(2.4658\\) \\(-0.1958\\) \\(45.8322\\) \\(2.5119\\) \\(1.1784\\) Table 11: Lateral fitting results (Simulation case) Data Fitting from Real Telemetry Data The real telemetry data are extracted in hapless condition: the front wheels was a bit deflated with respect to the rear ones. This aspect changes completely the vehicle turning behaviour. For this reason, the front and the rear tire model have to be fitted separately in order to handle this undesirable effect. The fitting outputs are reported in the below figures. Figure 21: Lateral axle fitting results From the telemetry data, it can be seen that, especially for the front axle, the linear tire region is poor of data. This is due to the unobservability of the Luemberger observer at a low yaw-rate: if the yaw-rate is small, the lateral force assumes small values and the tyre works in the linear region. Despite this, the lateral slip estimation is wrong and the fitting can not be performed. For this reason, the data are cut and only the data above a certain yaw rate are considered. Figure 22: Cornering stiffness and peak value Referring to figure 22, the different behaviour of the front and rear wheels is, for sure, caused by the different tire pressure. From this figure, the rear cornering stiffness has a behaviour with a shape close to the complete Pacejka one. For this reason, it is reasonable to assume that the cornering stiffness fitting returns a reliable behaviour. The same can be said for the peak value since the saturation limit of the characteristic is well distinguishable looking ad the data-test. Axle \\(p_{D 1}\\) \\(p_{D 2}\\) \\(p_{K 1}\\) \\(p_{K 2}\\) \\(p_{C 1}\\) Front \\(1.2404\\) \\(-0.0455\\) \\(109.503\\) \\(19.992\\) \\(1.851\\) Rear \\(1.3488\\) \\(-0.2491\\) \\(55.3888\\) \\(1.0032\\) \\(1.0017\\) Table 12: Lateral fitting results Tire Combined Behaviour The pure longitudinal and lateral models have to be fused to have the effective longitudinal and lateral tire forces in combined condition. The friction condition must satisfy the ellipse of adherence constraint. In relation 22, a commonly used approximation of the ellipse of adherence is presented. In this section, this approach is compared with the full Pacejka formulation highlighting the main differences. However, it is important to remind that the models that we report here is built for two different types of tire. The full Pacejka formulation models the Hoosier 18x6-10 while, the tires mounted during the tests are LeCont 6x16-10. For this analysis, the model fitted on the rear wheels is chosen to evaluate the performances of the combined behaviour. This because it has more similar characteristics with respect to the full Pacejka formulation and it is not affected by modelling errors due to wrong inflating conditions. Figure 23: Tire combined behaviour In figure 23, the combined tire behaviour is represented showing the evolution of longitudinal and lateral force in combined conditions under the effects of different level of slip. The first thing that can be noticed is that the complete tire model (on the right) shows that at a high value of longitudinal force, the lateral force can still reach a large value, and vice-versa. In the simplified fitted model (on the left), instead, the longitudinal force tends to quickly decrease when a lateral contribute is introduced. This effect gives a square-like shape with the vertices on the pure conditions - figure 24-. Besides, an underestimation of the longitudinal peak, in the fitting case, can generate dangerous behaviour in the combined formulation making the ellipse of adherence more stretched in the lateral direction. Figure 24: Fitted tire combined behaviour - approximation Figure 25: Effects of longitudinal slip on the lateral force Figure 26: Effects of lateral slip on the longitudinal force The effects of the combined condition can be also evaluated by looking at the effects of the longitudinal slip on the lateral force - figure 25 - or of the lateral slip on the longitudinal force - figure 26 - Moreover, from these figures, it can be seen that the combined conditions can affect also the initial slope of the curves and their peak value. These effects are not completely considered in the simplified model that can suffer of these simplifications. Nevertheless, this combined model offers a sufficiently good approximation of the real tire behaviour keeping the equations simple. Besides, a combination of the characteristic of this type does not need a dedicated fitting procedure, that can be done for the pure behaviour only.","title":"Tyre Model Fitting"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/1_TyreModelFitting/#tyre-model-fitting","text":"The tire characteristic has a very strong impact on vehicle behaviour. For this reason, the vehicle model must include a precise tire model which fits the used tire attitude. Usually, the Pacejka model is used to describe the complete behaviour of the tire by means of a semi-empirical approach. Unfortunately, to extract all the Pacejka parameters - more than fifty -, some very expensive tests should be performed. Hence, to have a better data fitting vehicle model, some tests with the vehicle can be performed and the parameters of a simplified tire model can be fitted using the data from the tests. In this way, it is possible to have an approximation of the tire model that holds over certain assumptions. In other words, a simplified tire model can be used in order to have a less general but more data-fitting vehicle model. In this section, some simplified tire models are presented and discussed. Once the best model will be chosen, the fitting procedure is explained in detail, reporting the fitting results. For all the tire model include here, the effects of the self-aligning torque are neglected. This because we have no way to measure them during the tests and, for this reason, the model notation results useless for our work.","title":"Tyre Model Fitting"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/1_TyreModelFitting/#tire-model-definition","text":"","title":"Tire Model Definition"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/1_TyreModelFitting/#burkhardt-friction-model","text":"In the control algorithms, the Burkhardt model is usually used because it is simple and can be a good approximation of the real tire characteristic - ref. [19] -. This model uses an exponential function to approximate tire behaviour. \\[ \\mu(s, V)=\\left[C_{1}\\left(1-e^{-C_{2} s}\\right)-C_{3} s\\right] e^{-C_{4} s V} \\] Figure 5: Burkhardt model \\(\\kappa\\) is the total slip and \\(V\\) is the vehicle velocity. The coefficients \\(C_{i}\\) are the model coefficients and give the shape of the curve. In order to compute the tire force, the friction coefficient has to be multiplied by the vertical load. Finally, to split the force in its longitudinal and lateral component, the resultant force must be scaled with the normalized longitudinal or lateral slip \\(-\\lambda / \\kappa\\) or \\(\\alpha / \\kappa\\) -. The model has to be fitted in both longitudinal and lateral direction to find \\(\\mu_{x}(\\lambda, V)\\) and \\(\\mu_{y}(\\alpha, V)\\) . In the end, the tire model will be as follow. \\[ \\left\\{\\begin{array}{l} F_{x}=\\mu_{x}(\\lambda, V) F_{z} \\frac{\\lambda}{|\\kappa|} \\\\ F_{y}=\\mu_{y}(\\alpha, V) F_{z} \\frac{\\alpha}{|\\kappa|} \\end{array}\\right. \\] This model has few parameters to find in order to fit the model: 8 for both longitudinal and lateral case - \\(C_{i j}\\) with \\(i=\\{1,2,3,4\\}\\) and \\(j=\\{x, y\\}-\\) - However, the part of this curve in which the slip is close to 1 has a decreasing fashion. This is in contrast with the real tire behaviour in which, after a certain value of slip, the force tends to stabilize around a constant value. Besides, real tire behaviour can be linearized before the peak using a linear function. In this model, this property is not represented because of the exponential function.","title":"Burkhardt Friction Model"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/1_TyreModelFitting/#semi-empirical-tire-model","text":"In the thesis of Fern\u00e1ndez [8] a Semi-empirical brush model is presented and implemented in a 10 DoF vehicle model. This tire model partially solves the problems that the Burkhardt model has. Moreover, this model is built in order to have easyto-fit parameters, that can well approximate the real behaviour of the tire by means of a piecewise function. In this type of model, the combined behaviour is modelled by means of a circle. This is a strong simplification because the different friction coefficients depending on the force direction are neglected. \\[ \\psi=\\frac{C}{3 \\mu} \\kappa \\] The term \\(\\psi\\) indicates the working region of the tire: if \\(\\psi\\) is smaller than one, the tire is working in linear region, otherwise, the tire is working above the peak. Using this distinction, the following piecewise definition can be written. Figure 6: Semi-Empirical Brush model The parameter \\(F\\) , given by the equation 14. has to be multiply by the value of the slips to obtain the tire forces - longitudinal or lateral -. \\[ F_{x}=F \\lambda \\quad ; \\quad F_{y}=F \\alpha \\] The model parameters are \\(C\\) , that is the normalized thread stiffness, and \\(\\mu\\) and \\(\\mu_{v}\\) , which correspond to the static and kinetic friction coefficients between the road and the tire. The semi-empirical brush model has a good accuracy in normal driving conditions, where the tire behaviour is linear. Nevertheless, the piecewise definition of \\(F\\) could give some numerical problems when the tire works around the peak. The advantage of this model is that it has very few parameters to estimate in order to have the complete model definition.","title":"Semi-Empirical Tire Model"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/1_TyreModelFitting/#magic-formula-tire-model","text":"Both the Burkardt and the Semi-empirical brush model has some problems which make them difficult to use in a simulation environment. For this reason a new tire model is defined to be simple and easy to fit but also able to incorporate all the most important features of the tire characteristic. This model can be seen as a simplified version of the Pacejka one - version 96 - in which some of the contributes are neglected - for example, the contribute related to the camber is not modeled -. The model is based on the Magic Formula theory that allows to model a very non linear effects using a fixed function, called magic formula, and scale the inputs and the outputs to fit the magic formula shape. In our case, the magic formula is defined in relation 16, \\[ Y=D \\sin [C \\arctan (B x)] \\] Figure 7: Example of Magic Formula In expression 16, the term \\(D\\) corresponds to the peak value, the term \\(B\\) gives the initial slope of the curve and the term \\(C\\) is a shaping factor for the non-linear part. The term \\(Y\\) can be substituted with the tire forces \\(F_{k}-k=\\{x, y\\}\\) - and the term \\(x\\) with the tire slip \\(s\\) , that can be longitudinal or lateral. \\[ F_{k}=\\mu_{k} F_{z} \\sin \\left[C_{k} \\arctan \\left(B_{k} s\\right)\\right] \\] For what concerns the tire, the term \\(D\\) is the product of the friction coefficient \\((\\mu)\\) and the vertical load \\(\\left(F_{z}\\right)-D=\\mu F_{z}\\) - and \\(\\mu\\) decreases linearly with \\(F_{z}\\) . This is an important feature that must be included in the model. Usually, the contribute connected to \\(F_{z}\\) is modelled refereeing to a nominal vertical load \\(F_{z 0}\\) . In this analysis, the nominal force is chosen equal to a quarter of the vehicle weight \\(-F_{z 0}=M g / 4-\\) . \\[ \\mu=p_{D 1}+p_{D 2} d F_{z}=p_{D 1}+p_{D 2}\\left(\\frac{F_{z}}{F_{z 0}}-1\\right) \\] Focusing on the longitudinal or cornering stiffness, i.e. the initial slope of the characteristic curve, the behaviour is different for the longitudinal and lateral case: the longitudinal stiffness - \\(K_{x k}\\) - has a linear and an exponential part, functions of the vertical force \\(F_{z}\\) \\[ K_{x k}=F_{z}\\left(p_{K x 1}+p_{k x 2} d F_{z}\\right) e^{-p_{K x 3} d f_{z}} \\] the lateral cornering stiffness - \\(K_{y a}\\) -, instead, is a trigonometric function of the vertical load and can be written as follow \\[ K_{y a}=F_{z 0} p_{K y 1} \\sin \\left(2 \\arctan \\left(\\frac{F_{z}}{p_{k y 2} F_{z 0}}\\right)\\right) \\] The tire stiffness can be found looking at the magic formula definition: linearizing the formula around the origin, the longitudinal or cornering stiffness can be written as equal to \\(K=B C D\\) . Using this last statement and considering the term \\(C\\) as a constant \\(C=p_{C 1}-, B\\) can be computed by inverting the linearized expression. \\[ B=\\frac{K}{C D} \\] Finally, in order to consider also the coupled behaviour, the tire adherence condition can be represented through an approximation of the ellipse of adherence. This approximation derives from the fact that the total tire force has the same direction as the total slip. For this reason, the total force can be scaled using the normalized tire slip to find the longitudinal and lateral forces. \\[ \\left\\{\\begin{array}{l} F_{x}=\\mu_{x} F_{z} \\sin \\left[C_{x} \\arctan \\left(B_{x} \\lambda\\right)\\right] \\frac{\\lambda}{|\\kappa|} \\\\ F_{y}=\\mu_{y} F_{z} \\sin \\left[C_{y} \\arctan \\left(B_{y} \\alpha\\right)\\right] \\frac{\\alpha}{|\\kappa|} \\end{array}\\right. \\] \\(\\kappa\\) is the total slip \\(-\\kappa=\\sqrt{\\lambda^{2}+\\alpha^{2}}-\\) . To sum up, the model parameters that have to be fitted are 11, 6 for the longitudinal and 5 for the lateral case - collected in table 8 -. This model represents a strong simplification with respect to the complete Pacejka one. However, it is a good compromise between model reliability and simplicity, making the parameters estimable using the experimental tests. Case \\(\\mu\\) \\(K\\) Others Longitudinal \\(p_{D x 1}, p_{D x 1}\\) \\(p_{K x 1}, p_{K x 2}, p_{K x 3}\\) \\(C_{x}\\) Lateral \\(p_{D y 1}, p_{D y 1}\\) \\(p_{K y 1}, p_{K y 2}\\) \\(C_{y}\\) Table 8: Magic Formula - coefficients to fit","title":"Magic Formula Tire Model"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/1_TyreModelFitting/#longitudinal-model-fitting","text":"The longitudinal tire model fitting is performed in acceleration condition. This because the longitudinal velocity estimation gives a more accurate results, reflecting in a more reliable slip computation, and the tire force, computed using the motor torque, are estimated in a more accurate way. The longitudinal slips are computed using the sensor fusion longitudinal velocity \\(u_{S F}\\) and the forces are estimated using the SOSM technique. The manoeuvre used for the fitting are pure longitudinal tests - acceleration in our case -. Both the full-throttle and the double throttle-step are used. The fitting procedure is firstly tested using the simulated data, in this way the results should be similar to the Pacejka model implemented in the simulation environment. Then, the fitting is applied to the real telemetry data.","title":"Longitudinal Model Fitting"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/1_TyreModelFitting/#data-fitting-from-synthetic-telemetry-data","text":"The fitting procedure is performed via grey-box approach. A longitudinal tire model is built with the model parameters free to vary. The model takes as inputs the longitudinal slip and the vertical tire load and returns the longitudinal force that is compared with the estimated force from the telemetry data post-processing. The best matching corresponds to the best fitting parameters. In order to govern the fitting and to have a physical validity of the fitted model, the parameters variation are bounded. For example, the peak value has to always decrease with the increasing of the vertical load hence, \\(p_{D 2}\\) has to be always negative. Figure 8: Fitting data and results for longitudinal tire model (Simulation case) In figure 8 the data from the simulation and the fitted model are reported. As can be seen from the figure, the characteristic peak has never reached from the data-tests. For this reason, the peak position and the characteristic profile above the peak are estimated with a high level of uncertainty. This is confirmed by plotting the fitted model with the full Pacejka model implemented in the simulation environment - figures 9 and 10 - Figure 9: Longitudinal tire model comparison Figure 10: Longitudinal stiffness and peak value comparison In order to correct the peak value, the model can be refitted by fixing \\(p_{D 1}\\) . However, to make this procedure possible, the actual value of the peak force must be known. In our case, \\(p_{D 1}\\) is set equal to \\(2.45\\) . The new fitting results are reported in figures 11 and 12 Figure 11: Longitudinal tire model comparison - fixing \\(p_{D 1}\\) Figure 12: Longitudinal stiffness and peak value comparison - fixing \\(p_{D 1}\\) From figure 11, it can be seen that the behaviour above the peak is not respected. This is due to an incorrect estimation of the parameter \\(p_{C 1}\\) , which is caused by the missing of useful data in that characteristic region. Never the less, the behaviour of the tire until the peak is well estimated. In table 9 the results of the two fitting procedures are reported. The static load \\(F_{z 0}\\) is set equal to \\(802 N\\) . Case \\(p_{D 1}\\) \\(p_{D 2}\\) \\(p_{K 1}\\) \\(p_{K 2}\\) \\(p_{K 3}\\) \\(p_{C 1}\\) First Fitting \\(1.852\\) \\(-0.7178\\) \\(59.0996\\) \\(-0.5021\\) \\(0.5996\\) \\(1.4751\\) Fixing \\(p_{D 1}\\) \\((2.45)\\) \\(-0.8206\\) \\(57.1712\\) \\(-1.3594\\) \\(0.635\\) \\(1.2065\\) Table 9: Longitudinal fitting results (Simulation case)","title":"Data Fitting from Synthetic Telemetry Data"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/1_TyreModelFitting/#data-fitting-from-real-telemetry-data","text":"Also, using the real telemetry data the fitting technique follows the same grey-box approach followed using the synthetic data. Now, no-prior knowledge is given about the tire model hence we have to trust the fitting results. In figure 13 the fitting results are illustrated. As can be seen, the peak is never reached. For this reason, the peak value is probably underestimated. In table 10 the result of the fitting procedure is reported. \\(p_{D 1}\\) \\(p_{D 2}\\) \\(p_{K 1}\\) \\(p_{K 2}\\) \\(p_{K 3}\\) \\(p_{C 1}\\) \\(1.0688\\) \\(-0.4473\\) \\(42.1562\\) \\(-0.4934\\) \\(0.3216\\) \\(1.2042\\) Table 10: Longitudinal fitting results Figure 13: Fitting data and results for longitudinal tire model Figure 14: Cornering stiffness and peak value","title":"Data Fitting from Real Telemetry Data"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/1_TyreModelFitting/#lateral-data-fitting","text":"The lateral data fitting is a bit more challenging because the tyre forces are not available. However, the lateral slips and the vertical loads are given for all four wheels. Hence, the approach presented by Guiggiani [10] can be employed. The total front or rear lateral force is the sum of the left and right lateral forces that are a function of the same parameters and of the lateral slips and the vertical loads of the tires - relation 23 -. Using this definition of the total axle lateral force, the parameters can be fitted for the front and for the rear axle, taking as input the vertical load and the lateral slip of the wheels and computing the matching with the axle force. \\[ \\begin{aligned} F_{y i} & =F_{y i R}\\left(\\alpha_{i R}, F_{z i R}\\right)+F_{y i L}\\left(\\alpha_{i L}, F_{z i L}\\right) \\\\ & =F_{z i R} \\mu_{y i} \\sin \\left[C_{y} \\arctan \\left(B_{y} \\alpha_{i R}\\right)\\right]+F_{z i L} \\mu_{y i} \\sin \\left[C_{y} \\arctan \\left(B_{y} \\alpha_{i L}\\right)\\right] \\end{aligned} \\] where \\(i=\\{F, R\\}\\) . Also, in this case, both the fitting with synthetic and real telemetry data are presented. For the slip computation, the lateral velocity is computed using the Luemberger observer and the lateral forces by means of the SOSM. In the simulation, the performed tests are constant steering angle manoeuvre increasing speed while the real telemetry data are extracted from the steering pads.","title":"Lateral Data Fitting"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/1_TyreModelFitting/#data-fitting-from-synthetic-telemetry-data_1","text":"In principle, the front and rear tire can have slightly different behaviour. For this reason, the fitting is performed separately for the front and the rear. The complete model is fitted using the data. The results are reported in figures 15,16 and 17 Figure 15: Lateral axle fitting results Figure 16: Lateral tire model comparison Figure 17: Cornering stiffness and peak value comparison From the above figures, it can be noticed that the cornering stiffness does not follow the behaviour dictated by the complete Pacejka model. In order to solve this problem, both axles can be used for the fitting since, in simulation, the tire behaviour is almost the same - except for the camber effects - Figures 18, 19 and 20 illustrates the fitting results in this case. Figure 18: Lateral axle fitting results - using both axles Figure 19: Lateral tire model comparison - using both axles Figure 20: Cornering stiffness and peak value comparison - using both axles In this case, the peak value of the lateral force is well recognizable from the saturation of the synthetic tests data. However, as can be seen in figure 20, the cornering stiffness behaviour is not well reproduced. The working region is probably too narrow in term of vertical load to fit this aspect of the tyre characteristic. Nevertheless, around the tire working region, the fitting results can still be a good approximation of the real tire behaviour. Case \\(p_{D 1}\\) \\(p_{D 2}\\) \\(p_{K 1}\\) \\(p_{K 2}\\) \\(p_{C 1}\\) First fit. (F) \\(2.9013\\) \\(-0.1418\\) \\(34.9586\\) \\(1.7937\\) \\(1.1720\\) First fit. (R) \\(2.4433\\) \\(-0.3292\\) \\(45.1309\\) \\(2.2526\\) \\(1.1694\\) Fit both axles \\(2.4658\\) \\(-0.1958\\) \\(45.8322\\) \\(2.5119\\) \\(1.1784\\) Table 11: Lateral fitting results (Simulation case)","title":"Data Fitting from Synthetic Telemetry Data"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/1_TyreModelFitting/#data-fitting-from-real-telemetry-data_1","text":"The real telemetry data are extracted in hapless condition: the front wheels was a bit deflated with respect to the rear ones. This aspect changes completely the vehicle turning behaviour. For this reason, the front and the rear tire model have to be fitted separately in order to handle this undesirable effect. The fitting outputs are reported in the below figures. Figure 21: Lateral axle fitting results From the telemetry data, it can be seen that, especially for the front axle, the linear tire region is poor of data. This is due to the unobservability of the Luemberger observer at a low yaw-rate: if the yaw-rate is small, the lateral force assumes small values and the tyre works in the linear region. Despite this, the lateral slip estimation is wrong and the fitting can not be performed. For this reason, the data are cut and only the data above a certain yaw rate are considered. Figure 22: Cornering stiffness and peak value Referring to figure 22, the different behaviour of the front and rear wheels is, for sure, caused by the different tire pressure. From this figure, the rear cornering stiffness has a behaviour with a shape close to the complete Pacejka one. For this reason, it is reasonable to assume that the cornering stiffness fitting returns a reliable behaviour. The same can be said for the peak value since the saturation limit of the characteristic is well distinguishable looking ad the data-test. Axle \\(p_{D 1}\\) \\(p_{D 2}\\) \\(p_{K 1}\\) \\(p_{K 2}\\) \\(p_{C 1}\\) Front \\(1.2404\\) \\(-0.0455\\) \\(109.503\\) \\(19.992\\) \\(1.851\\) Rear \\(1.3488\\) \\(-0.2491\\) \\(55.3888\\) \\(1.0032\\) \\(1.0017\\) Table 12: Lateral fitting results","title":"Data Fitting from Real Telemetry Data"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/1_TyreModelFitting/#tire-combined-behaviour","text":"The pure longitudinal and lateral models have to be fused to have the effective longitudinal and lateral tire forces in combined condition. The friction condition must satisfy the ellipse of adherence constraint. In relation 22, a commonly used approximation of the ellipse of adherence is presented. In this section, this approach is compared with the full Pacejka formulation highlighting the main differences. However, it is important to remind that the models that we report here is built for two different types of tire. The full Pacejka formulation models the Hoosier 18x6-10 while, the tires mounted during the tests are LeCont 6x16-10. For this analysis, the model fitted on the rear wheels is chosen to evaluate the performances of the combined behaviour. This because it has more similar characteristics with respect to the full Pacejka formulation and it is not affected by modelling errors due to wrong inflating conditions. Figure 23: Tire combined behaviour In figure 23, the combined tire behaviour is represented showing the evolution of longitudinal and lateral force in combined conditions under the effects of different level of slip. The first thing that can be noticed is that the complete tire model (on the right) shows that at a high value of longitudinal force, the lateral force can still reach a large value, and vice-versa. In the simplified fitted model (on the left), instead, the longitudinal force tends to quickly decrease when a lateral contribute is introduced. This effect gives a square-like shape with the vertices on the pure conditions - figure 24-. Besides, an underestimation of the longitudinal peak, in the fitting case, can generate dangerous behaviour in the combined formulation making the ellipse of adherence more stretched in the lateral direction. Figure 24: Fitted tire combined behaviour - approximation Figure 25: Effects of longitudinal slip on the lateral force Figure 26: Effects of lateral slip on the longitudinal force The effects of the combined condition can be also evaluated by looking at the effects of the longitudinal slip on the lateral force - figure 25 - or of the lateral slip on the longitudinal force - figure 26 - Moreover, from these figures, it can be seen that the combined conditions can affect also the initial slope of the curves and their peak value. These effects are not completely considered in the simplified model that can suffer of these simplifications. Nevertheless, this combined model offers a sufficiently good approximation of the real tire behaviour keeping the equations simple. Besides, a combination of the characteristic of this type does not need a dedicated fitting procedure, that can be done for the pure behaviour only.","title":"Tire Combined Behaviour"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/2_ModelValidation/","text":"Model Validation and Model Prediction In this chapter, the vehicle model validation is concluded and the performances in term of prediction are evaluated. Alternatively to the 10 degrees of freedom model, a second model is evaluated. It is a simplification of the first one, in which the internal dynamics is neglected. This simplification decreases the number of degrees of freedom from 10 to 7 . However, before talking about the prediction performances, an analysis of the fitting results can be done to check the validity of the fitted model. Fitting Model Results As already said, the longitudinal fitting could under-estimate the peak value of the curve and this can cause a more quick achievement of the tire limit, in particular in combined conditions. Besides, if we refer to the fitting from simulation data, it can be noticed that the peaks in the longitudinal and lateral case have similar values - tables 9 and 11- - This is because the peak value is related to the static friction constraint. If we look at the fitting results using the real telemetry data, the peak in the longitudinal case has a smaller value with respect to the lateral one, but the difference between them is not so large - tables 10 and 12 -. This can suggest a small fitting error. For what concerns the lateral fitting, the results are probably easier to be evaluated. The lower front tire inflation advises a lower grip at the front with a resultant understeering vehicle. This behaviour is confirmed by the value of the cornering stiffness (table6), which has a higher value at the rear. Using values of the cornering stiffnesses, the Under-steering gradient \\(\\left(K_{u s}\\right)\\) can be computed (relation 24 ). \\[ K_{u s}=\\frac{M}{L}\\left(\\frac{L_{R}}{C_{a F}}-\\frac{L_{F}}{C_{a R}}\\right) \\simeq 6.910^{-3} \\frac{\\mathrm{rad} s^{2}}{\\mathrm{~m}}=0.39 \\frac{\\circ \\mathrm{s}^{2}}{\\mathrm{~m}} \\] If \\(K_{u s}\\) is greater than zero - as in our case -, the vehicle is under-steering; if it is negative, the vehicle is over-steering; if it is equal to zero, the vehicle is neutral. Another way to evaluate the turning behaviour of the vehicle is the handling diagram. It is a diagram that represents the difference between the front and the rear lateral slip - \\(\\alpha_{F}-\\alpha_{R}-\\) , in a steady-state condition, versus the lateral acceleration. Using the axle lateral slip definition - relations ?? and ?? -, the lateral slip difference can be written as equal to the difference between the actual steering angle at the wheels \\((\\delta)\\) and the kinematic one \\(\\left(\\delta_{\\text {kine }}=\\rho L\\right)\\) , where \\(\\rho\\) is the trajectory curvature \\(-\\rho=\\Omega / u-\\) . With this definition of the handling diagram, it is easier to understand the meaning of the under-steering gradient related to the vehicle behaviour. The under-steering gradient is, indeed, the slope of the handling diagram in its linear region - \\((\\delta-\\rho L)_{l i n}=K_{u s} a_{y G}\\) -. If \\(K_{u s}\\) is greater than zero, it means that, for positive turning \\(\\left.{ }^{1}\\right]\\) the handling diagram assumes positive values. Since the handling diagram can be written as \\(\\delta-\\rho L\\) , it means that, in the examined conditions, the driver is steering more than the neutral steering angle \\(\\left(\\delta_{\\text {kine }}\\right)\\) and it confirms that the vehicle is under-steering. In figure 27, the experimental handling diagram is plotted using both definitiont2? It can be seen that they are perfectly overlapped. Besides, the approximation of the curve using \\(K_{u s}\\) is plotted to check the correctness of the under-steering gradient computation. In figure 28, the fitted lateral tire model is plotted to graphically see the different initial slope between the front and rear characteristic, caused by the different inflation. \\({ }^{1}\\) With positive turning, we define turning manoeuvre in which the steering angle is positive and, for the used convention, the lateral acceleration and the yaw-rate are greater than zero \\({ }^{2}\\) The handling diagram is plotted using the same telemetry data used in the lateral fitting case \\((\\) chapter 1 ) Figure 27: Handling Diagram Figure 28: Lateral fitted tire model In conclusion, the tire model defined and fitted in the previous chapter is implemented in both simulation environments. In order to evaluate the turning reliability of the models, a ramp steer test is simulated to plot the simulated handling diagram - figure 29 -. From this plot, it can be seen that the simulated and the real turning behaviour is quite similar in the linear region. Nevertheless, when the handling limit is reached, the simulated and the real plots have different behaviours. This is due to the simulation condition: in the real tests, an expert driver keeps the vehicle at its limit, in a condition closest to the steady-state one. In the simulation, instead, the vehicle handling limit is not recognized and the model inputs follow the initially defined ones. In this condition, the vehicle behaviour is not more in steady-state, violating the han-dling diagram definition, and the plot can result different from the actual one. Moreover, the simulated ramp-steer tests are performed at constant speed. In order to keep the velocity constant, under the effects of the resistance force, the rear wheel torque must be greater than zero. This means that the rear longitudinal tire forces are not null. The large lateral force at the handling limit, coupled with the longitudinal force, that becomes high in that part of the test, generates a strong combined behaviour. With reference to figure 23, the combined behaviour of the new fitted tire model is more narrow and the strong combined constraints are underestimated. This combination of events favours a quick increasing of the rear lateral slip, with respect to the front one. This means that the resulting handling diagram moves towards negative values. However, the handling limit position in the simulation case corresponds to the real one. Figure 29: Handling Diagram with simulation results In order to extract a more similar handling diagram to the experimental data, an iterative design of a suitable manoeuvre is performed. The constant speed constraint is no more strict: in this way, the strong combined behaviour at the handling limit can be reduced. Nevertheless, manoeuvres at the handling limit are difficult to be performed, especially in open-loop. In figure 30, the handling diagram obtained with the new tests are plotted (curves \"v2\"). If on one hand, we achieve a good result for the 7 DoF model, on the other, in the 10 DoF case we are not able to find the correct input law for the open-loop simulation. Despite these results, both new diagrams move upward, differently to the case before. Figure 30: Handling Diagram with simulation results - v2 Model Prediction Performance Let us now evaluate the validated model performances in term of prediction. All the estimated parameters are corrected in the vehicle data structure. Also, the new tire model is implemented in both simulation environments, as for the handling diagram plotting. In order to evaluate the model reliability, a branch of the track-drive test is used. The models take as inputs the steering angle and the velocity profile and simulate the vehicle in open-loop. For this reason, the results that we obtain can easily diverge from real vehicle behaviour. Nevertheless, a suitable branch is chosen to have sufficient information to evaluate the model adequacy. The steering angle profile is reported in figure 31 while the target velocity will be reported in figures 32 and 33. Figure 31: Steering angle from the telemetry test Firstly, the planar vehicle motion is compared between real data and simulation figures 32 and 32 -. These figures report the quasi-coordinates 3 , the body-side slip angle and the centre of mass accelerations in longitudinal and lateral directions. Figure 32: Planar motion simulation results - 7DoF model \\({ }^{3}\\) Quasi-coordinates are defined as the longitudinal and lateral speed \\((u\\) and \\(v)\\) and the yaw-rate \\((\\Omega)\\) . The quasi-coordinates help us in the definition of the first-order dynamical equation of the vehicle model Figure 33: Planar motion simulation results - 10DoF model In the plot related to the 7 degrees of freedom model, it can be seen that the longitudinal velocity \\((u)\\) is well followed in the first part of the test while the speed profile is worse followed in the last part, where the longitudinal controller probably fails. This does not happen in the 10 DoF model, where the speed profile is perfectly followed by the vehicle. In both cases, the yaw-rate \\((\\Omega)\\) is well estimated from the model while, the lateral acceleration \\(\\left(a_{y G}\\right)\\) is a bit under-estimated with respect to the measured one, especially in the 7 DoF case. For what concerns the lateral velocity \\((v)\\) and the body-side slip angle \\((\\beta)\\) , the poor performances of the state observer are highlighted. For this reason, without precise knowledge about these states during the real tests, a valid comparison can not be done. Generally, the longitudinal acceleration is well estimated except for some peaks, where the lower longitudinal tire characteristic affects the maximum traction. Secondly, the longitudinal tire quantities are reported - figures 34 and 35 -. In the upper part of the figures, the longitudinal slips are plotted. In the bottom part, instead, the tire longitudinal forces are shown. In both cases, the simulation results are compared with the estimated quantities. Figure 34: Longitudinal slips and forces simulation results - 7DoF model Figure 35: Longitudinal slips and forces simulation results - 10DoF model During the test, no significant braking is performed. For this reason, the front tire forces and slips are small. Focusing on the rear ones, it can be noticed that the tire forces and slips are well predicted by the model, except for some peaks due to the same reason explained before. Besides, it can be seen that the rear-left wheel slip from real telemetry data differs from the simulated one. However, it can be caused by a small error in the longitudinal velocity. Nevertheless, the main evolution contribute is maintained. The simulated longitudinal forces are, in both figures, greater than the ones from the real tests. This because the vehicle input is the speed and a longitudinal controller computes the necessary wheels torques to follow the given velocity profile. Therefore, the longitudinal controller outputs can be slightly different from the actual one. In addition, some small unmodelled longitudinal effects can generate that small force offset. In the 7 DoF case, around 7 seconds from the test beginning, the longitudinal tire forces in the rear wheels seems to be null. This may mean that the rear axle has lifted in that part of the test. However, if we zoom in that specific part of the graph, we can see that the longitudinal forces assume small values but they are not equal to zero. This because, in that graph region, the longitudinal controller is nor accelerating or braking and the resultant tire force is small. Finally, let us report the lateral slips and forces for both simulation environments figure 36 and 37.-. Since lateral forces for each tire are not available in the set of real telemetry data, the axle lateral force is computed and plotted also in the simulation case. As shown in the following figures, the tire lateral slips are wrong estimated at the beginning of the turning test, i.e. where the lateral forces start to be greater than zero. This is due to the performances of the Luemberger observer with which the lateral velocity is computed. However, probably when the yaw-rate becomes high enough, namely when the lateral forces are higher, the estimation error decreases and the main behaviour of the slips from simulated data can be recognized in the slips from real telemetry data. This is true in particular for the front axle where the slips assume higher values with respect to the rear ones. For what concerns the forces, instead, the estimation is better for the rear axle in both cases \\(-7\\) and 10 degrees of freedom model -. However, the lateral force estimation is sufficiently good to be considered as a good state prediction. Figure 36: Lateral slips and forces simulation results - 7DoF model Figure 37: Lateral slips and forces simulation results - 10DoF model In conclusion, both the validated vehicle models generate a sufficiently good level of accuracy also using a so simplified tire model. Hence, the model validation procedure performed in this work generates a good level of model adequacy. This means that the magic formula tire model presented in the previous chapter can be used in a simulation environment to evaluate the vehicle behaviour but also in a control framework to estimate the vehicle states in a sufficiently good way. Besides, with reference to the tire combined behaviour represented in figure 23, the state estimation is conservative since the constraint of the simplified tire model in combined conditions tends to be in-scripted in the real ellipse of adherence.","title":"Model Validation and Model Prediction"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/2_ModelValidation/#model-validation-and-model-prediction","text":"In this chapter, the vehicle model validation is concluded and the performances in term of prediction are evaluated. Alternatively to the 10 degrees of freedom model, a second model is evaluated. It is a simplification of the first one, in which the internal dynamics is neglected. This simplification decreases the number of degrees of freedom from 10 to 7 . However, before talking about the prediction performances, an analysis of the fitting results can be done to check the validity of the fitted model.","title":"Model Validation and Model Prediction"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/2_ModelValidation/#fitting-model-results","text":"As already said, the longitudinal fitting could under-estimate the peak value of the curve and this can cause a more quick achievement of the tire limit, in particular in combined conditions. Besides, if we refer to the fitting from simulation data, it can be noticed that the peaks in the longitudinal and lateral case have similar values - tables 9 and 11- - This is because the peak value is related to the static friction constraint. If we look at the fitting results using the real telemetry data, the peak in the longitudinal case has a smaller value with respect to the lateral one, but the difference between them is not so large - tables 10 and 12 -. This can suggest a small fitting error. For what concerns the lateral fitting, the results are probably easier to be evaluated. The lower front tire inflation advises a lower grip at the front with a resultant understeering vehicle. This behaviour is confirmed by the value of the cornering stiffness (table6), which has a higher value at the rear. Using values of the cornering stiffnesses, the Under-steering gradient \\(\\left(K_{u s}\\right)\\) can be computed (relation 24 ). \\[ K_{u s}=\\frac{M}{L}\\left(\\frac{L_{R}}{C_{a F}}-\\frac{L_{F}}{C_{a R}}\\right) \\simeq 6.910^{-3} \\frac{\\mathrm{rad} s^{2}}{\\mathrm{~m}}=0.39 \\frac{\\circ \\mathrm{s}^{2}}{\\mathrm{~m}} \\] If \\(K_{u s}\\) is greater than zero - as in our case -, the vehicle is under-steering; if it is negative, the vehicle is over-steering; if it is equal to zero, the vehicle is neutral. Another way to evaluate the turning behaviour of the vehicle is the handling diagram. It is a diagram that represents the difference between the front and the rear lateral slip - \\(\\alpha_{F}-\\alpha_{R}-\\) , in a steady-state condition, versus the lateral acceleration. Using the axle lateral slip definition - relations ?? and ?? -, the lateral slip difference can be written as equal to the difference between the actual steering angle at the wheels \\((\\delta)\\) and the kinematic one \\(\\left(\\delta_{\\text {kine }}=\\rho L\\right)\\) , where \\(\\rho\\) is the trajectory curvature \\(-\\rho=\\Omega / u-\\) . With this definition of the handling diagram, it is easier to understand the meaning of the under-steering gradient related to the vehicle behaviour. The under-steering gradient is, indeed, the slope of the handling diagram in its linear region - \\((\\delta-\\rho L)_{l i n}=K_{u s} a_{y G}\\) -. If \\(K_{u s}\\) is greater than zero, it means that, for positive turning \\(\\left.{ }^{1}\\right]\\) the handling diagram assumes positive values. Since the handling diagram can be written as \\(\\delta-\\rho L\\) , it means that, in the examined conditions, the driver is steering more than the neutral steering angle \\(\\left(\\delta_{\\text {kine }}\\right)\\) and it confirms that the vehicle is under-steering. In figure 27, the experimental handling diagram is plotted using both definitiont2? It can be seen that they are perfectly overlapped. Besides, the approximation of the curve using \\(K_{u s}\\) is plotted to check the correctness of the under-steering gradient computation. In figure 28, the fitted lateral tire model is plotted to graphically see the different initial slope between the front and rear characteristic, caused by the different inflation. \\({ }^{1}\\) With positive turning, we define turning manoeuvre in which the steering angle is positive and, for the used convention, the lateral acceleration and the yaw-rate are greater than zero \\({ }^{2}\\) The handling diagram is plotted using the same telemetry data used in the lateral fitting case \\((\\) chapter 1 ) Figure 27: Handling Diagram Figure 28: Lateral fitted tire model In conclusion, the tire model defined and fitted in the previous chapter is implemented in both simulation environments. In order to evaluate the turning reliability of the models, a ramp steer test is simulated to plot the simulated handling diagram - figure 29 -. From this plot, it can be seen that the simulated and the real turning behaviour is quite similar in the linear region. Nevertheless, when the handling limit is reached, the simulated and the real plots have different behaviours. This is due to the simulation condition: in the real tests, an expert driver keeps the vehicle at its limit, in a condition closest to the steady-state one. In the simulation, instead, the vehicle handling limit is not recognized and the model inputs follow the initially defined ones. In this condition, the vehicle behaviour is not more in steady-state, violating the han-dling diagram definition, and the plot can result different from the actual one. Moreover, the simulated ramp-steer tests are performed at constant speed. In order to keep the velocity constant, under the effects of the resistance force, the rear wheel torque must be greater than zero. This means that the rear longitudinal tire forces are not null. The large lateral force at the handling limit, coupled with the longitudinal force, that becomes high in that part of the test, generates a strong combined behaviour. With reference to figure 23, the combined behaviour of the new fitted tire model is more narrow and the strong combined constraints are underestimated. This combination of events favours a quick increasing of the rear lateral slip, with respect to the front one. This means that the resulting handling diagram moves towards negative values. However, the handling limit position in the simulation case corresponds to the real one. Figure 29: Handling Diagram with simulation results In order to extract a more similar handling diagram to the experimental data, an iterative design of a suitable manoeuvre is performed. The constant speed constraint is no more strict: in this way, the strong combined behaviour at the handling limit can be reduced. Nevertheless, manoeuvres at the handling limit are difficult to be performed, especially in open-loop. In figure 30, the handling diagram obtained with the new tests are plotted (curves \"v2\"). If on one hand, we achieve a good result for the 7 DoF model, on the other, in the 10 DoF case we are not able to find the correct input law for the open-loop simulation. Despite these results, both new diagrams move upward, differently to the case before. Figure 30: Handling Diagram with simulation results - v2","title":"Fitting Model Results"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/2_ModelValidation/#model-prediction-performance","text":"Let us now evaluate the validated model performances in term of prediction. All the estimated parameters are corrected in the vehicle data structure. Also, the new tire model is implemented in both simulation environments, as for the handling diagram plotting. In order to evaluate the model reliability, a branch of the track-drive test is used. The models take as inputs the steering angle and the velocity profile and simulate the vehicle in open-loop. For this reason, the results that we obtain can easily diverge from real vehicle behaviour. Nevertheless, a suitable branch is chosen to have sufficient information to evaluate the model adequacy. The steering angle profile is reported in figure 31 while the target velocity will be reported in figures 32 and 33. Figure 31: Steering angle from the telemetry test Firstly, the planar vehicle motion is compared between real data and simulation figures 32 and 32 -. These figures report the quasi-coordinates 3 , the body-side slip angle and the centre of mass accelerations in longitudinal and lateral directions. Figure 32: Planar motion simulation results - 7DoF model \\({ }^{3}\\) Quasi-coordinates are defined as the longitudinal and lateral speed \\((u\\) and \\(v)\\) and the yaw-rate \\((\\Omega)\\) . The quasi-coordinates help us in the definition of the first-order dynamical equation of the vehicle model Figure 33: Planar motion simulation results - 10DoF model In the plot related to the 7 degrees of freedom model, it can be seen that the longitudinal velocity \\((u)\\) is well followed in the first part of the test while the speed profile is worse followed in the last part, where the longitudinal controller probably fails. This does not happen in the 10 DoF model, where the speed profile is perfectly followed by the vehicle. In both cases, the yaw-rate \\((\\Omega)\\) is well estimated from the model while, the lateral acceleration \\(\\left(a_{y G}\\right)\\) is a bit under-estimated with respect to the measured one, especially in the 7 DoF case. For what concerns the lateral velocity \\((v)\\) and the body-side slip angle \\((\\beta)\\) , the poor performances of the state observer are highlighted. For this reason, without precise knowledge about these states during the real tests, a valid comparison can not be done. Generally, the longitudinal acceleration is well estimated except for some peaks, where the lower longitudinal tire characteristic affects the maximum traction. Secondly, the longitudinal tire quantities are reported - figures 34 and 35 -. In the upper part of the figures, the longitudinal slips are plotted. In the bottom part, instead, the tire longitudinal forces are shown. In both cases, the simulation results are compared with the estimated quantities. Figure 34: Longitudinal slips and forces simulation results - 7DoF model Figure 35: Longitudinal slips and forces simulation results - 10DoF model During the test, no significant braking is performed. For this reason, the front tire forces and slips are small. Focusing on the rear ones, it can be noticed that the tire forces and slips are well predicted by the model, except for some peaks due to the same reason explained before. Besides, it can be seen that the rear-left wheel slip from real telemetry data differs from the simulated one. However, it can be caused by a small error in the longitudinal velocity. Nevertheless, the main evolution contribute is maintained. The simulated longitudinal forces are, in both figures, greater than the ones from the real tests. This because the vehicle input is the speed and a longitudinal controller computes the necessary wheels torques to follow the given velocity profile. Therefore, the longitudinal controller outputs can be slightly different from the actual one. In addition, some small unmodelled longitudinal effects can generate that small force offset. In the 7 DoF case, around 7 seconds from the test beginning, the longitudinal tire forces in the rear wheels seems to be null. This may mean that the rear axle has lifted in that part of the test. However, if we zoom in that specific part of the graph, we can see that the longitudinal forces assume small values but they are not equal to zero. This because, in that graph region, the longitudinal controller is nor accelerating or braking and the resultant tire force is small. Finally, let us report the lateral slips and forces for both simulation environments figure 36 and 37.-. Since lateral forces for each tire are not available in the set of real telemetry data, the axle lateral force is computed and plotted also in the simulation case. As shown in the following figures, the tire lateral slips are wrong estimated at the beginning of the turning test, i.e. where the lateral forces start to be greater than zero. This is due to the performances of the Luemberger observer with which the lateral velocity is computed. However, probably when the yaw-rate becomes high enough, namely when the lateral forces are higher, the estimation error decreases and the main behaviour of the slips from simulated data can be recognized in the slips from real telemetry data. This is true in particular for the front axle where the slips assume higher values with respect to the rear ones. For what concerns the forces, instead, the estimation is better for the rear axle in both cases \\(-7\\) and 10 degrees of freedom model -. However, the lateral force estimation is sufficiently good to be considered as a good state prediction. Figure 36: Lateral slips and forces simulation results - 7DoF model Figure 37: Lateral slips and forces simulation results - 10DoF model In conclusion, both the validated vehicle models generate a sufficiently good level of accuracy also using a so simplified tire model. Hence, the model validation procedure performed in this work generates a good level of model adequacy. This means that the magic formula tire model presented in the previous chapter can be used in a simulation environment to evaluate the vehicle behaviour but also in a control framework to estimate the vehicle states in a sufficiently good way. Besides, with reference to the tire combined behaviour represented in figure 23, the state estimation is conservative since the constraint of the simplified tire model in combined conditions tends to be in-scripted in the real ellipse of adherence.","title":"Model Prediction Performance"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/3_Conclusion/","text":"Conclusions and Future Works In this paper, a model validation procedure is presented for a high fidelity vehicle model. In this section, we want to conclude highlighting the main aspects of the work, suggesting possible enhancement and future works in order to improve the obtained results. In the estimation stage, we noticed that the lateral velocity estimators have low accuracy, especially when the yaw-rate is small. The obtained results can be valid only for steady-state analysis where the estimation can be considered as reliable. For a more accurate analysis, we suggest using a lateral velocity observer based on a single-track vehicle model. Some examples are reported in [7] and in [21]. These observers need precise knowledge about the vehicle property but the estimation results can be better if the vehicle knowledge is available. From the procedure explained in this paper, the preliminary data knowledge can be acquired. Hence, the estimation using these more reliable estimators can be performed. Another crucial aspect is the set of available sensors. Our analysis works only using the sensors mounted in our vehicle: encoders, IMU and wheels torques sensors. However, a more robust analysis can be performed using an absolute reference from the GPS. Besides, during the tests, we realized that the front-left encoder was broken. Therefore, the front-left wheel spin was estimated using the right one, the yaw-rate and the steering angle. The velocity estimation obtained in this way is for sure worse than the case in which both encoders work. This, combined with the front tire inflation problem, suggest repeating the tests with a larger set of sensors and with the correct tire pressure for all the wheels. In our case, this repetitions was impossible because of the COVID-19 pandemic. For what concerns the model fitting, the main problem that we encountered was the longitudinal peak estimation. In order to fit the peak behaviour, corresponding to the static friction constraint, some out-of-track experiments can be designed to fit the linear behaviour of the tire friction limit depending on the tire vertical load. In the presented tire model, the self-aligning torque is neglected. This because, in the vehicle, we did not have a sensor that was able to measure them. However, if the set of sensors will be enlarged and a measure of the self-aligning torque will be available, the tire model can be completed with also this aspect of the tire characteristic. The measure of the self-aligning torques can be done trough strain-gauges on the steering arms. A precise model of the suspension structure must be available to convert the sensor measurements into the needed data. Moreover, a wider set of strain-gauges, placed in strategic positions, can estimate the full set of tire forces. However, the knowledge about the vehicle suspension structure must be very detailed. Moreover, if the suspension arms are in composite material, the stretch measure can be difficult. Looking, now, at the analysis done in chapter 3, both validated models give a sufficiently good estimation of the real vehicle behaviour, also in open-loop simulation. This means that both can be used to predict the vehicle states for control strategy and algorithms testing. In particular, the 10 degrees of freedom model presented in chapter ??, with the corrected parameters and the new tire model, gives more information about the vehicle states. Nevertheless, the most important feature of that model is the presence of the model of the internal kinematics which can be used also for the computation of the camber at the wheels as a function of the vehicle roll. Since the simplified tire model neglects the camber contribute, this feature can be removed encouraging the usage of the 7 DoF model. However, as it can be seen in figures 32 and 33 , the prediction of the lateral acceleration is better using the more complex model. Hence, the 10 DoF vehicle model has a higher level of accuracy and, for this reason, it can be used for algorithm testing off-line. In this way, the computation cost is no more a problem. The 7 DoF model is simpler but still computationally expensive. Therefore, the on-line execution of the model as a state estimator/predictor can be challenging, in particular in an optimal control framework. The tire model applied to simpler vehicle models - for example to a single-track vehicle model - can be a good compromise to have a reliable model description for the control field. To sum up, we can argue that this work may be the basis for the control framework of a self-driving racing vehicle. Using the validated model, the control algorithms will be tested. Moreover, with the tire fitted model, the knowledge about the adhesion limit achievement is known and can be used for the driving-at-the-limit vehicle control.","title":"Conclusions and Future Works"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/3_Conclusion/#conclusions-and-future-works","text":"In this paper, a model validation procedure is presented for a high fidelity vehicle model. In this section, we want to conclude highlighting the main aspects of the work, suggesting possible enhancement and future works in order to improve the obtained results. In the estimation stage, we noticed that the lateral velocity estimators have low accuracy, especially when the yaw-rate is small. The obtained results can be valid only for steady-state analysis where the estimation can be considered as reliable. For a more accurate analysis, we suggest using a lateral velocity observer based on a single-track vehicle model. Some examples are reported in [7] and in [21]. These observers need precise knowledge about the vehicle property but the estimation results can be better if the vehicle knowledge is available. From the procedure explained in this paper, the preliminary data knowledge can be acquired. Hence, the estimation using these more reliable estimators can be performed. Another crucial aspect is the set of available sensors. Our analysis works only using the sensors mounted in our vehicle: encoders, IMU and wheels torques sensors. However, a more robust analysis can be performed using an absolute reference from the GPS. Besides, during the tests, we realized that the front-left encoder was broken. Therefore, the front-left wheel spin was estimated using the right one, the yaw-rate and the steering angle. The velocity estimation obtained in this way is for sure worse than the case in which both encoders work. This, combined with the front tire inflation problem, suggest repeating the tests with a larger set of sensors and with the correct tire pressure for all the wheels. In our case, this repetitions was impossible because of the COVID-19 pandemic. For what concerns the model fitting, the main problem that we encountered was the longitudinal peak estimation. In order to fit the peak behaviour, corresponding to the static friction constraint, some out-of-track experiments can be designed to fit the linear behaviour of the tire friction limit depending on the tire vertical load. In the presented tire model, the self-aligning torque is neglected. This because, in the vehicle, we did not have a sensor that was able to measure them. However, if the set of sensors will be enlarged and a measure of the self-aligning torque will be available, the tire model can be completed with also this aspect of the tire characteristic. The measure of the self-aligning torques can be done trough strain-gauges on the steering arms. A precise model of the suspension structure must be available to convert the sensor measurements into the needed data. Moreover, a wider set of strain-gauges, placed in strategic positions, can estimate the full set of tire forces. However, the knowledge about the vehicle suspension structure must be very detailed. Moreover, if the suspension arms are in composite material, the stretch measure can be difficult. Looking, now, at the analysis done in chapter 3, both validated models give a sufficiently good estimation of the real vehicle behaviour, also in open-loop simulation. This means that both can be used to predict the vehicle states for control strategy and algorithms testing. In particular, the 10 degrees of freedom model presented in chapter ??, with the corrected parameters and the new tire model, gives more information about the vehicle states. Nevertheless, the most important feature of that model is the presence of the model of the internal kinematics which can be used also for the computation of the camber at the wheels as a function of the vehicle roll. Since the simplified tire model neglects the camber contribute, this feature can be removed encouraging the usage of the 7 DoF model. However, as it can be seen in figures 32 and 33 , the prediction of the lateral acceleration is better using the more complex model. Hence, the 10 DoF vehicle model has a higher level of accuracy and, for this reason, it can be used for algorithm testing off-line. In this way, the computation cost is no more a problem. The 7 DoF model is simpler but still computationally expensive. Therefore, the on-line execution of the model as a state estimator/predictor can be challenging, in particular in an optimal control framework. The tire model applied to simpler vehicle models - for example to a single-track vehicle model - can be a good compromise to have a reliable model description for the control field. To sum up, we can argue that this work may be the basis for the control framework of a self-driving racing vehicle. Using the validated model, the control algorithms will be tested. Moreover, with the tire fitted model, the knowledge about the adhesion limit achievement is known and can be used for the driving-at-the-limit vehicle control.","title":"Conclusions and Future Works"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/Home_Validation/","text":"Tyre Fitting & Model Validation This report mainly presents a tire model that can be fitted using suitable vehicle tests. The final target is the validation of the 10 Degrees of Freedom (DoF) vehicle model presented by Piccinini [16]. See also: Fitting Hoosier Data 2018 Tyre Model Fitting Model Validation and Model Prediction Conclusion References [1] Acosta, M., Kanarachos, S. - Tire lateral force estimation and grip potential identification using Neural Networks, Extended Kalman Filter, and Recursive Least Squares. Neural Comput \\& Applic 30, 3445-3465 (2018). https://doi.org/10.1007/s00521-017-2932-9 [2] Acosta M., Kanarachos S. and Fitzpatrick M. E., \"Robust Virtual Sensing for Vehicle Agile Manoeuvring: A Tyre-Model-Less Approach,\" in IEEE Transactions on Vehicular Technology, vol. 67, no. 3, pp. 1894-1908, March 2018, doi: 10.1109/TVT.2017.2767942. [3] \u00c5kesson B. M., J\u00f8rgensen J. B., Poulsen N. K., J\u00f8rgensen S. B., A tool for kalman filter tuning, Editor(s): Valentin Ple\u015fu, Paul \u015eerban Agachi, Computer Aided Chemical Engineering, Elsevier, Volume 24, 2007, ISBN 9780444531575, https://doi.org/10.1016/S1570-7946(07)80166-0. [4] Alatorre A. G., Charara A. and Victorino A., \"Sideslip estimation algorithm comparison between Euler angles and quaternion approaches with black box vehicle model,\" 2018 IEEE 15th International Workshop on Advanced Motion Control (AMC), Tokyo, 2018, pp. 553-559, doi: 10.1109/AMC.2019.8371153. [5] Da Lio M., Bortoluzzi D. \\& Rosati Papini G. P. (2020) Modelling longitudinal vehicle dynamics with neural networks, Vehicle System Dynamics, 58:11, 1675-1693, DOI: \\(10.1080 / 00423114.2019 .1638947\\) [6] De Pascali L., Biral F., Cocetti M., Zaccarian L. and Tarbouriech S., \"A kinematic observer with adaptive dead-zone for vehicles lateral velocity estimation,\" 2018 IEEE 15th International Workshop on Advanced Motion Control (AMC), Tokyo, 2018, pp. 511-516, doi: 10.1109/AMC.2019.8371146. [7] Farrelly J. and Wellstead P., \"Estimation of vehicle lateral velocity,\" Proceeding of the 1996 IEEE International Conference on Control Applications IEEE International Conference on Control Applications held together with IEEE International Symposium on Intelligent Contro, Dearborn, MI, USA, 1996, pp. 552-557, doi: 10.1109/CCA.1996.558920. [8] Fern\u00e1ndez J. G. (2012) - A Vehicle Dynamics Model for Driving Simulators Chalmers University of Technology [9] Gelen A. G. and Atasoy A., \"A New Method for Kalman Filter Tuning,\" 2018 International Conference on Artificial Intelligence and Data Processing (IDAP), Malatya, Turkey, 2018, pp. 1-6, doi: 10.1109/IDAP.2018.8620863. [10] Guiggiani M. (2014) \"The science of vehicle dynamics\", Springer Netherlands, pp: 137-144 [11] James S. S., Anderson S. R. and Da Lio M., \"Longitudinal Vehicle Dynamics: A Comparison of Physical and Data-Driven Models Under Large-Scale RealWorld Driving Conditions,\" in IEEE Access, vol. 8, pp. 73714-73729, 2020, doi: 10.1109/ACCESS.2020.2988592. [12] Larcher M. (2019) - Development of a 14 Degrees of Freedom Vehicle Model for Realtime Simulations in 3D Environment - Universit\u00e0 di Trento [13] Lot R. and Da Lio M. \"A symbolic approach for automatic generation of the equations of motion of multibody systems\", 2004, Multibody System Dynamics, 12(2): \\(147-172\\) [14] Oshaman Y., Shaviv I. \"Optimal tuning of a Kalman Filter using Genetic Algorithm\" Technion - Israel Institute of Technology (2000), doi: https://doi.org/10.2514/6.2000-4558 [15] Panzani G., Corno M., Savaresi S.M., \"Longitudinal Velocity Estimation in SingleTrack Vehicles\", IFAC Proceedings Volumes, Volume 45, Issue 16, 2012, Pages 17011706, https://doi.org/10.3182/20120711-3-BE-2027.00164. [16] Piccinini M. (2019) - Path Planning and Control of Self Driving Vehicles at the Limit of Handling - Universit\u00e0 di Trento - Ch: 2 [17] Regolin E., Alatorre A., Zambelli M., Victorino A., Charara A. and Ferrara A., \"A Sliding-Mode Virtual Sensor for Wheel Forces Estimation With Accuracy Enhancement via EKF,\" in IEEE Transactions on Vehicular Technology, vol. 68, no. 4, pp. 3457-3471, April 2019, doi: 10.1109/TVT.2019.2903598. [18] Ryu J., Nardi F., \\& Moshchuk N. \"Vehicle Sideslip Angle Estimation and Experimental Validation.\" Proceedings of the ASME 2013 International Mechanical Engineering Congress and Exposition. Volume 4A: Dynamics, Vibration and Control. San Diego, California, USA. November 15-21, 2013. V04AT04A052. ASME. https://doi.org/10.1115/IMECE2013-64466 [19] Ru\u017einskas A., Sivilevi\u010dius H., \"Magic Formula Tyre Model Application for a Tyre-Ice Interaction\", Procedia Engineering, Volume 187, 2017, https://doi.org/10.1016/j.proeng.2017.04.383. [20] Studer C. (2009) \"Numerics of Unilateral Contacts and Friction - Modeling and Numerical Time Integration in Non-Smooth Dynamics\", Springer-Verlag Berlin Heidelberg, pp. 59-127 [21] Viehweger M., Vaseur C., van Aalst S., Acosta M., Regolin E., Alatorre A., Desmet W., Naets F., Ivanov V., Ferrara A. \\& Victorino A. (2020) Vehicle state and tyre force estimation: demonstrations and guidelines, Vehicle System Dynamics, DOI: \\(10.1080 / 00423114.2020 .1714672\\) [22] Enciclopedia Treccani - https://www.treccani.it/enciclopedia/metodo-montecarlo/ [23] Enciclopedia Treccani - https://www.treccani.it/enciclopedia/gradi-di-liberta/ Revision History V.1.0. (09/2020) - Inital Release (Matteo Tomasi)","title":"Tyre Fitting & Model Validation"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/Home_Validation/#tyre-fitting-model-validation","text":"This report mainly presents a tire model that can be fitted using suitable vehicle tests. The final target is the validation of the 10 Degrees of Freedom (DoF) vehicle model presented by Piccinini [16]. See also: Fitting Hoosier Data 2018 Tyre Model Fitting Model Validation and Model Prediction Conclusion","title":"Tyre Fitting &amp; Model Validation"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/Home_Validation/#references","text":"[1] Acosta, M., Kanarachos, S. - Tire lateral force estimation and grip potential identification using Neural Networks, Extended Kalman Filter, and Recursive Least Squares. Neural Comput \\& Applic 30, 3445-3465 (2018). https://doi.org/10.1007/s00521-017-2932-9 [2] Acosta M., Kanarachos S. and Fitzpatrick M. E., \"Robust Virtual Sensing for Vehicle Agile Manoeuvring: A Tyre-Model-Less Approach,\" in IEEE Transactions on Vehicular Technology, vol. 67, no. 3, pp. 1894-1908, March 2018, doi: 10.1109/TVT.2017.2767942. [3] \u00c5kesson B. M., J\u00f8rgensen J. B., Poulsen N. K., J\u00f8rgensen S. B., A tool for kalman filter tuning, Editor(s): Valentin Ple\u015fu, Paul \u015eerban Agachi, Computer Aided Chemical Engineering, Elsevier, Volume 24, 2007, ISBN 9780444531575, https://doi.org/10.1016/S1570-7946(07)80166-0. [4] Alatorre A. G., Charara A. and Victorino A., \"Sideslip estimation algorithm comparison between Euler angles and quaternion approaches with black box vehicle model,\" 2018 IEEE 15th International Workshop on Advanced Motion Control (AMC), Tokyo, 2018, pp. 553-559, doi: 10.1109/AMC.2019.8371153. [5] Da Lio M., Bortoluzzi D. \\& Rosati Papini G. P. (2020) Modelling longitudinal vehicle dynamics with neural networks, Vehicle System Dynamics, 58:11, 1675-1693, DOI: \\(10.1080 / 00423114.2019 .1638947\\) [6] De Pascali L., Biral F., Cocetti M., Zaccarian L. and Tarbouriech S., \"A kinematic observer with adaptive dead-zone for vehicles lateral velocity estimation,\" 2018 IEEE 15th International Workshop on Advanced Motion Control (AMC), Tokyo, 2018, pp. 511-516, doi: 10.1109/AMC.2019.8371146. [7] Farrelly J. and Wellstead P., \"Estimation of vehicle lateral velocity,\" Proceeding of the 1996 IEEE International Conference on Control Applications IEEE International Conference on Control Applications held together with IEEE International Symposium on Intelligent Contro, Dearborn, MI, USA, 1996, pp. 552-557, doi: 10.1109/CCA.1996.558920. [8] Fern\u00e1ndez J. G. (2012) - A Vehicle Dynamics Model for Driving Simulators Chalmers University of Technology [9] Gelen A. G. and Atasoy A., \"A New Method for Kalman Filter Tuning,\" 2018 International Conference on Artificial Intelligence and Data Processing (IDAP), Malatya, Turkey, 2018, pp. 1-6, doi: 10.1109/IDAP.2018.8620863. [10] Guiggiani M. (2014) \"The science of vehicle dynamics\", Springer Netherlands, pp: 137-144 [11] James S. S., Anderson S. R. and Da Lio M., \"Longitudinal Vehicle Dynamics: A Comparison of Physical and Data-Driven Models Under Large-Scale RealWorld Driving Conditions,\" in IEEE Access, vol. 8, pp. 73714-73729, 2020, doi: 10.1109/ACCESS.2020.2988592. [12] Larcher M. (2019) - Development of a 14 Degrees of Freedom Vehicle Model for Realtime Simulations in 3D Environment - Universit\u00e0 di Trento [13] Lot R. and Da Lio M. \"A symbolic approach for automatic generation of the equations of motion of multibody systems\", 2004, Multibody System Dynamics, 12(2): \\(147-172\\) [14] Oshaman Y., Shaviv I. \"Optimal tuning of a Kalman Filter using Genetic Algorithm\" Technion - Israel Institute of Technology (2000), doi: https://doi.org/10.2514/6.2000-4558 [15] Panzani G., Corno M., Savaresi S.M., \"Longitudinal Velocity Estimation in SingleTrack Vehicles\", IFAC Proceedings Volumes, Volume 45, Issue 16, 2012, Pages 17011706, https://doi.org/10.3182/20120711-3-BE-2027.00164. [16] Piccinini M. (2019) - Path Planning and Control of Self Driving Vehicles at the Limit of Handling - Universit\u00e0 di Trento - Ch: 2 [17] Regolin E., Alatorre A., Zambelli M., Victorino A., Charara A. and Ferrara A., \"A Sliding-Mode Virtual Sensor for Wheel Forces Estimation With Accuracy Enhancement via EKF,\" in IEEE Transactions on Vehicular Technology, vol. 68, no. 4, pp. 3457-3471, April 2019, doi: 10.1109/TVT.2019.2903598. [18] Ryu J., Nardi F., \\& Moshchuk N. \"Vehicle Sideslip Angle Estimation and Experimental Validation.\" Proceedings of the ASME 2013 International Mechanical Engineering Congress and Exposition. Volume 4A: Dynamics, Vibration and Control. San Diego, California, USA. November 15-21, 2013. V04AT04A052. ASME. https://doi.org/10.1115/IMECE2013-64466 [19] Ru\u017einskas A., Sivilevi\u010dius H., \"Magic Formula Tyre Model Application for a Tyre-Ice Interaction\", Procedia Engineering, Volume 187, 2017, https://doi.org/10.1016/j.proeng.2017.04.383. [20] Studer C. (2009) \"Numerics of Unilateral Contacts and Friction - Modeling and Numerical Time Integration in Non-Smooth Dynamics\", Springer-Verlag Berlin Heidelberg, pp. 59-127 [21] Viehweger M., Vaseur C., van Aalst S., Acosta M., Regolin E., Alatorre A., Desmet W., Naets F., Ivanov V., Ferrara A. \\& Victorino A. (2020) Vehicle state and tyre force estimation: demonstrations and guidelines, Vehicle System Dynamics, DOI: \\(10.1080 / 00423114.2020 .1714672\\) [22] Enciclopedia Treccani - https://www.treccani.it/enciclopedia/metodo-montecarlo/ [23] Enciclopedia Treccani - https://www.treccani.it/enciclopedia/gradi-di-liberta/","title":"References"},{"location":"data-analysis-DMT/Tire%20Fitting%20and%20Validation/Home_Validation/#revision-history","text":"V.1.0. (09/2020) - Inital Release (Matteo Tomasi)","title":"Revision History"},{"location":"fenice-arb-DMT/Home/","text":"Fenice Anti Roll Bar Welcome to the Fenice Anti Roll Bar wiki! TABLE OF CONTENTS","title":"Fenice Anti Roll Bar"},{"location":"fenice-arb-DMT/Home/#fenice-anti-roll-bar","text":"Welcome to the Fenice Anti Roll Bar wiki!","title":"Fenice Anti Roll Bar"},{"location":"fenice-arb-DMT/Home/#table-of-contents","text":"","title":"TABLE OF CONTENTS"},{"location":"fenice-bms-hv-sw/","text":"High-Voltage Battery Management System Battery management is a collection of operations that ensures the safety and efficiency of the battery pack. A basic battery management system should constantly measure cell temperatures and voltages along with the total pack current output and check that each of those values is within specification.\\ If anomalies are detected, the battery should be disconnected immediately via the AIRs. A good battery management system is also able to keep the battery in good operating conditions, with the goal of maintaining the expected efficiency of the powertrain. The need of collecting a lot of data from all over the pack has dictated a scattered architecture for the BMS: it uses multiple data acquisition boards (cellboards) and a single control board (mainboard).","title":"High-Voltage Battery Management System"},{"location":"fenice-bms-hv-sw/#high-voltage-battery-management-system","text":"Battery management is a collection of operations that ensures the safety and efficiency of the battery pack. A basic battery management system should constantly measure cell temperatures and voltages along with the total pack current output and check that each of those values is within specification.\\ If anomalies are detected, the battery should be disconnected immediately via the AIRs. A good battery management system is also able to keep the battery in good operating conditions, with the goal of maintaining the expected efficiency of the powertrain. The need of collecting a lot of data from all over the pack has dictated a scattered architecture for the BMS: it uses multiple data acquisition boards (cellboards) and a single control board (mainboard).","title":"High-Voltage Battery Management System"},{"location":"fenice-bms-hv-sw/bootloader/openblt/","text":"OpenBlt Table of Contents Intro Building and flashing the bootloader Building the firmware Flashing the firmware Intro Both cellboards' and mainboard's bootloaders are derived from OpenBlt sources .\\ Actually Core sources and Target specific sources have been copied in the BLT folder. The whole bootloader configuration happens in the blt_conf.h header file, exception made for the flashLayout[] variable found in flash.c , where the flash layout is specified. Building and flashing the bootloader Building and flashing theese bootloaders is straightforward.\\ Being STM32CubeMX projects, you just need the STM32-for-VSCode extension, build and flash. Done. Building the firmware There are 2 main modifications that you need to do on the firmware side, in order to operate with the openblt bootloader . Modify the linker file ( .ld file in the root directory) and shift the program in the flash.\\ This can be done by changing the FLASH (rx) (line 63) according to what has been specified in the previously mentioned flash.c file (eg. ORIGIN = 0x8004000 ). Remember to reduce the flash size too (eg. LENGHT = 496K ). Convert the .bin build file to .srec format .\\ This can be achieved with this tool: arkku/srec . Example: bin2srec - a 0x8004000 ( or anithing specified by the linker file ) - i % . bin - o % . srec Flashing the firmware Both telemetry's and steering wheel's Raspberries have been configured in order to flash by CAN . All you need to do is follow these steps: Copy the .srec file in the /home/pi/can_flashing/fw folder Call the /home/script/can_flashing/scripts/flash_* script, to flash the mainboard ( flash_mainboard ) or a specific cellboard ( flash_cellboard<n> ). > You can also flash all the cellboards together with the flash_cellboard_all script. NB: Those scripts just take care of rebooting the target board with a specific CAN message and then calls the bootcommander tool. Because of the way the scripts have been written (demmerda e velocemente) the mainboard's firmware must be called fenice-bms.srec and the cellboard's one must be called cellboard.srec .","title":"OpenBlt"},{"location":"fenice-bms-hv-sw/bootloader/openblt/#openblt","text":"","title":"OpenBlt"},{"location":"fenice-bms-hv-sw/bootloader/openblt/#table-of-contents","text":"Intro Building and flashing the bootloader Building the firmware Flashing the firmware","title":"Table of Contents"},{"location":"fenice-bms-hv-sw/bootloader/openblt/#intro","text":"Both cellboards' and mainboard's bootloaders are derived from OpenBlt sources .\\ Actually Core sources and Target specific sources have been copied in the BLT folder. The whole bootloader configuration happens in the blt_conf.h header file, exception made for the flashLayout[] variable found in flash.c , where the flash layout is specified.","title":"Intro"},{"location":"fenice-bms-hv-sw/bootloader/openblt/#building-and-flashing-the-bootloader","text":"Building and flashing theese bootloaders is straightforward.\\ Being STM32CubeMX projects, you just need the STM32-for-VSCode extension, build and flash. Done.","title":"Building and flashing the bootloader"},{"location":"fenice-bms-hv-sw/bootloader/openblt/#building-the-firmware","text":"There are 2 main modifications that you need to do on the firmware side, in order to operate with the openblt bootloader . Modify the linker file ( .ld file in the root directory) and shift the program in the flash.\\ This can be done by changing the FLASH (rx) (line 63) according to what has been specified in the previously mentioned flash.c file (eg. ORIGIN = 0x8004000 ). Remember to reduce the flash size too (eg. LENGHT = 496K ). Convert the .bin build file to .srec format .\\ This can be achieved with this tool: arkku/srec . Example: bin2srec - a 0x8004000 ( or anithing specified by the linker file ) - i % . bin - o % . srec","title":"Building the firmware"},{"location":"fenice-bms-hv-sw/bootloader/openblt/#flashing-the-firmware","text":"Both telemetry's and steering wheel's Raspberries have been configured in order to flash by CAN . All you need to do is follow these steps: Copy the .srec file in the /home/pi/can_flashing/fw folder Call the /home/script/can_flashing/scripts/flash_* script, to flash the mainboard ( flash_mainboard ) or a specific cellboard ( flash_cellboard<n> ). > You can also flash all the cellboards together with the flash_cellboard_all script. NB: Those scripts just take care of rebooting the target board with a specific CAN message and then calls the bootcommander tool. Because of the way the scripts have been written (demmerda e velocemente) the mainboard's firmware must be called fenice-bms.srec and the cellboard's one must be called cellboard.srec .","title":"Flashing the firmware"},{"location":"fenice-bms-hv-sw/mainboard/","text":"Mainboard The Mainboard is the central control unit of the BMS .\\ It contains a microcontroller that handles two CAN-bus lines for internal and external communications, peripherals such as insulated ADCs , EEPROMs , serial ports, an SD-card and more.\\ The mainboard is responsible for the actuation of the AIRs and contains the shutdown and pre-charge circuits .\\ It also communicates voltages, temperatures, currents, battery status, warnings and errors to the rest of the car via CAN-bus. An integrated serial command-line interface and internal logging are included to help with troubleshooting. The logic of the mainboard is handled by a couple of FSM (Finite States Machines) . The FSM library is used to manage every state machine of the BMS . Subsystems There are several subsystems to the mainboard's firmware: bal : contains functions of the cell balancing algorithm. bal_fsm : contains the balancing algorithm's FSM. bms_fsm : the BMS' FSM handles the main state machine of the board and it's responsible for the management of the tractive system's activation and deactivation. cli_bms : all the CLI commands are defined here. config : generic interface that handles all sorts of configurations. current : current measurement functions. energy : energy measurement and State-of-Charge estimation logic. feedback : mainboard's feedbacks handler functions and variables. pack : battery pack hardware control's interface. soc : State-of-Charge estimation functions (at the moment it doesn't work) . timebase : controls all repeating actions of the firmware.","title":"Mainboard"},{"location":"fenice-bms-hv-sw/mainboard/#mainboard","text":"The Mainboard is the central control unit of the BMS .\\ It contains a microcontroller that handles two CAN-bus lines for internal and external communications, peripherals such as insulated ADCs , EEPROMs , serial ports, an SD-card and more.\\ The mainboard is responsible for the actuation of the AIRs and contains the shutdown and pre-charge circuits .\\ It also communicates voltages, temperatures, currents, battery status, warnings and errors to the rest of the car via CAN-bus. An integrated serial command-line interface and internal logging are included to help with troubleshooting. The logic of the mainboard is handled by a couple of FSM (Finite States Machines) . The FSM library is used to manage every state machine of the BMS .","title":"Mainboard"},{"location":"fenice-bms-hv-sw/mainboard/#subsystems","text":"There are several subsystems to the mainboard's firmware: bal : contains functions of the cell balancing algorithm. bal_fsm : contains the balancing algorithm's FSM. bms_fsm : the BMS' FSM handles the main state machine of the board and it's responsible for the management of the tractive system's activation and deactivation. cli_bms : all the CLI commands are defined here. config : generic interface that handles all sorts of configurations. current : current measurement functions. energy : energy measurement and State-of-Charge estimation logic. feedback : mainboard's feedbacks handler functions and variables. pack : battery pack hardware control's interface. soc : State-of-Charge estimation functions (at the moment it doesn't work) . timebase : controls all repeating actions of the firmware.","title":"Subsystems"},{"location":"fenice-bms-hv-sw/mainboard/io/","text":"I/O There are many peripherals and devices connected to the mainboard. Every component that interfaces with the mainboard's microcontroller is listed here: CAN-buses (CAN):\\ a CAN-bus to communicate with the car and an internal isolated bus for handling the cellboards. adc124021 ADC (SPI):\\ used to measure pack's and bus' voltages, also used to measure the pack's current using a shunt resistor. DAHB S/160 Hall-effect sensor (ADC):\\ used to measure pack's current. It's less precise than the shunt, included for historical reasons. The unit contains two sensors with different gains to have a broader current range. AIR and pre-charge controls :\\ three output pins control the actuation of the AIRs (if the shutdown circuit is not latched in the off state) and the pre-charge circuit. Circuit feedbacks (MUX/ADC):\\ 16 multiplexed analog signals coming from the mainboard's circuit. It's used to diagnose the circuit and to verify its correct state compared to the BMS state. Some of those feedbacks are not multiplexed to let them generate of interrupts. IMD Status (PWM):\\ the IMD has an output PWM signal that reports its internal state. M95256 EEPROM (SPI):\\ used to store runtime variables and data, such as State-of-Charge information, balancing threshold and more. SD-card (SPI):\\ an SD-card has been included on the mainboard, in order to use it as storage for extended logs. User console (UART):\\ a serial interface has been reserved as an user interface to read/write data and execute commands. The cli library is used as an interface. GPIOs :\\ 9 GPIO pins for external stuff.","title":"I/O"},{"location":"fenice-bms-hv-sw/mainboard/io/#io","text":"There are many peripherals and devices connected to the mainboard. Every component that interfaces with the mainboard's microcontroller is listed here: CAN-buses (CAN):\\ a CAN-bus to communicate with the car and an internal isolated bus for handling the cellboards. adc124021 ADC (SPI):\\ used to measure pack's and bus' voltages, also used to measure the pack's current using a shunt resistor. DAHB S/160 Hall-effect sensor (ADC):\\ used to measure pack's current. It's less precise than the shunt, included for historical reasons. The unit contains two sensors with different gains to have a broader current range. AIR and pre-charge controls :\\ three output pins control the actuation of the AIRs (if the shutdown circuit is not latched in the off state) and the pre-charge circuit. Circuit feedbacks (MUX/ADC):\\ 16 multiplexed analog signals coming from the mainboard's circuit. It's used to diagnose the circuit and to verify its correct state compared to the BMS state. Some of those feedbacks are not multiplexed to let them generate of interrupts. IMD Status (PWM):\\ the IMD has an output PWM signal that reports its internal state. M95256 EEPROM (SPI):\\ used to store runtime variables and data, such as State-of-Charge information, balancing threshold and more. SD-card (SPI):\\ an SD-card has been included on the mainboard, in order to use it as storage for extended logs. User console (UART):\\ a serial interface has been reserved as an user interface to read/write data and execute commands. The cli library is used as an interface. GPIOs :\\ 9 GPIO pins for external stuff.","title":"I/O"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/","text":"Cell Balancing The cell balancing operation is mostly done on the cellboards. However, the mainboard has to compute all the cells that need to be discharged. To synchronize cellboards and the mainboard an FSM is defined: stateDiagram-v2 direction LR [*] --> OFF OFF --> CMP OFF --> OFF CMP --> DSC CMP --> OFF DSC --> COOL DSC --> OFF DSC --> DSC COOL --> CMP COOL--> OFF COOL --> COOL - Off (OFF) The dormant state of the balancing algorithm. - Compute (CMP) Compute phase. This is where the cell selection algorithm is run. If no cells need to be discharged the FSM returns back to the Off state. The compute phase can be triggered manually via the CLI. The algorithm is split in two phases: Imbalance computation The imbalance is the voltage difference between a given cell and the minimum-voltage cell. In this phase an imbalance array that contains the imbalances of every cell is created. In this case the imbalance is centered around the minimum-voltage plus a threshold, that is the maximum imbalance permitted in the pack. \\(imbalance[i] = \\max(0, voltages[i] \u2212(min\\_voltage + threshold))\\) Cell selection The cell selection algorithm is very simple: if the imbalance is greater than 0, the cell is selected for discharge - Discharge (DSC) After compute the mainboard sends the list of cells to be discharged to the cellboards that start the actual discharge for a set amount of time. The discharge time depends on configuration but it's in the range from 30 to 120s. - Cooldown (COOL) Cooldown. A small period (5-10s) where voltages are","title":"Cell Balancing"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#cell-balancing","text":"The cell balancing operation is mostly done on the cellboards. However, the mainboard has to compute all the cells that need to be discharged. To synchronize cellboards and the mainboard an FSM is defined: stateDiagram-v2 direction LR [*] --> OFF OFF --> CMP OFF --> OFF CMP --> DSC CMP --> OFF DSC --> COOL DSC --> OFF DSC --> DSC COOL --> CMP COOL--> OFF COOL --> COOL","title":"Cell Balancing"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#-off-off","text":"The dormant state of the balancing algorithm.","title":"- Off (OFF)"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#-compute-cmp","text":"Compute phase. This is where the cell selection algorithm is run. If no cells need to be discharged the FSM returns back to the Off state. The compute phase can be triggered manually via the CLI. The algorithm is split in two phases:","title":"- Compute (CMP)"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#imbalance-computation","text":"The imbalance is the voltage difference between a given cell and the minimum-voltage cell. In this phase an imbalance array that contains the imbalances of every cell is created. In this case the imbalance is centered around the minimum-voltage plus a threshold, that is the maximum imbalance permitted in the pack. \\(imbalance[i] = \\max(0, voltages[i] \u2212(min\\_voltage + threshold))\\)","title":"Imbalance computation"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#cell-selection","text":"The cell selection algorithm is very simple: if the imbalance is greater than 0, the cell is selected for discharge","title":"Cell selection"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#-discharge-dsc","text":"After compute the mainboard sends the list of cells to be discharged to the cellboards that start the actual discharge for a set amount of time. The discharge time depends on configuration but it's in the range from 30 to 120s.","title":"- Discharge (DSC)"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#-cooldown-cool","text":"Cooldown. A small period (5-10s) where voltages are","title":"- Cooldown (COOL)"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/","text":"Command Line Interface The command line interface of the Mainboard is based on the cli library. It serves as the main interface with the BMS. The CLI is clocked at 115200 baud and uses local echo Warning The CLI runs on UART1, thus it is not compatible with STM32 Nucleo boards that normally use UART2 as the USB serial console. As the name implies, the CLI is based around commands, in a style inspired by Unix consoles. Pressing ? followed by Enter will give a list of legal commands. Commands volt The volt command returns the main voltages of the battery pack. Example bus.......0.00 V internal..388.8 V average...3.60 V max.......3.70 V min.......3.50 V delta.....0.20 V Parameters all : prints all cell voltages (plus some usefull information about balancing). temp Similarly to the volt command, temp will return the main temperatures of the pack. Parameters all : Prints all battery temperatures. status Returns a summary of the general status of the BMS. errors This command will return a list containing each active errors and its details ts Controls the Tractive System actuation. Parameters on : generates a TS_ON event on the BMS FSM . off : triggers TS_OFF event on the aforementioned FSM. bal Suite of commands that handle the balancing process. Parameters on : Triggers an event that enables the BAL FSM . off : Triggers an event that disables balancing. thr : Returns the currently set threshold. thr <millivolts> : Sets the threshold to the value of <millivolts> . Please be gentle with it: it can break bad if you input strange stuff test <board> <cell0 cell1 ... cellN> : starts a balancing cycle in the board on the specified cells soc Return state of charge information Parameters reset : resets the 'last charge' energy meter. current Shows current measurement for all the available sensors. Parameters zero : zeroes the Hall-effect sensors. dmesg Toggles the debug output. This can be quite verbose if enabled. reset Resets the microcontroller. Analogue to pressing the reset button on board. imd Show imd details feedbacks Show feedbacks status watch Repeatedly run a command Parameters <interval ms> <cmd> cell_distr Lets you change the cellboard arrangment into the pork Parameters ``: Show current cellboard distribution <cell0> ... <cellN> : Update cellboard distribution fans Control the pork fans Parameters off : shut down fans <0-100> : sets fans power pack Control low level ts hardware Warning This can lead to dangerous behaviours when the tractive system is connected, be carefull Parameters airn <on/off> : controls the air negative airp <on/off> : controls the air positive precharge <on/off> : controls the precharge relay Easter eggs? Of course","title":"Command Line Interface"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#command-line-interface","text":"The command line interface of the Mainboard is based on the cli library. It serves as the main interface with the BMS. The CLI is clocked at 115200 baud and uses local echo Warning The CLI runs on UART1, thus it is not compatible with STM32 Nucleo boards that normally use UART2 as the USB serial console. As the name implies, the CLI is based around commands, in a style inspired by Unix consoles. Pressing ? followed by Enter will give a list of legal commands.","title":"Command Line Interface"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#commands","text":"","title":"Commands"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#volt","text":"The volt command returns the main voltages of the battery pack. Example bus.......0.00 V internal..388.8 V average...3.60 V max.......3.70 V min.......3.50 V delta.....0.20 V","title":"volt"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters","text":"all : prints all cell voltages (plus some usefull information about balancing).","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#temp","text":"Similarly to the volt command, temp will return the main temperatures of the pack.","title":"temp"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_1","text":"all : Prints all battery temperatures.","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#status","text":"Returns a summary of the general status of the BMS.","title":"status"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#errors","text":"This command will return a list containing each active errors and its details","title":"errors"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#ts","text":"Controls the Tractive System actuation.","title":"ts"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_2","text":"on : generates a TS_ON event on the BMS FSM . off : triggers TS_OFF event on the aforementioned FSM.","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#bal","text":"Suite of commands that handle the balancing process.","title":"bal"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_3","text":"on : Triggers an event that enables the BAL FSM . off : Triggers an event that disables balancing. thr : Returns the currently set threshold. thr <millivolts> : Sets the threshold to the value of <millivolts> . Please be gentle with it: it can break bad if you input strange stuff test <board> <cell0 cell1 ... cellN> : starts a balancing cycle in the board on the specified cells","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#soc","text":"Return state of charge information","title":"soc"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_4","text":"reset : resets the 'last charge' energy meter.","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#current","text":"Shows current measurement for all the available sensors.","title":"current"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_5","text":"zero : zeroes the Hall-effect sensors.","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#dmesg","text":"Toggles the debug output. This can be quite verbose if enabled.","title":"dmesg"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#reset","text":"Resets the microcontroller. Analogue to pressing the reset button on board.","title":"reset"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#imd","text":"Show imd details","title":"imd"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#feedbacks","text":"Show feedbacks status","title":"feedbacks"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#watch","text":"Repeatedly run a command","title":"watch"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_6","text":"<interval ms> <cmd>","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#cell_distr","text":"Lets you change the cellboard arrangment into the pork","title":"cell_distr"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_7","text":"``: Show current cellboard distribution <cell0> ... <cellN> : Update cellboard distribution","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#fans","text":"Control the pork fans","title":"fans"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_8","text":"off : shut down fans <0-100> : sets fans power","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#pack","text":"Control low level ts hardware Warning This can lead to dangerous behaviours when the tractive system is connected, be carefull","title":"pack"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_9","text":"airn <on/off> : controls the air negative airp <on/off> : controls the air positive precharge <on/off> : controls the precharge relay","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#easter-eggs","text":"Of course","title":"Easter eggs?"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/","text":"Main State Machine The BMS fsm handles the main state machine of the board. It is responsible for the management of the tractive system activation and deactivation. States stateDiagram-v2 direction LR [*] --> Idle Idle --> AirnClose Idle --> Error AirnClose --> Idle AirnClose --> AirnStatus AirnClose --> Error AirnStatus --> Precharge AirnStatus --> Idle AirnStatus --> Error Precharge --> On Precharge --> Idle Precharge --> Error On --> Idle On --> Error Error --> Idle - Idle When the TS is off and no fatal errors are present, the BMS is in the Idle state. - AirnClose When the procedure of activation of the Tractive System is requested. Additional feedbacks are checked in order to close the AIR negative. - AirnStatus Checks if the activation of the AIR negative is ok. - Precharge The Precharge procedure is done to turn on the Tractive System. It involves the actuation of the precharge relay and the monitoring of the bus voltage. The bus voltage is periodically confronted with the internal voltage and when they are within 7% of each other the positive AIR is closed and the precharge relay is opened, ending the precharge procedure. The FSM then transitions to the TS_On state. If the bus voltage doesn't rise fast enough, the precharge fails and the FSM goes back to Idle. - TS_On In this state the high-voltage bus external to the battery is powered. This is the state in which the car can run, or the battery can be charged. When the TS_OFF event occurs, the FSM transitions back to Idle, opening both AIRs at the same time. - Error If a fatal error is active the BMS is in this state. TS activation requests are ignored. If every fatal error expires, then the BMS returns to Idle and can accept TS on commands again.","title":"Main State Machine"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#main-state-machine","text":"The BMS fsm handles the main state machine of the board. It is responsible for the management of the tractive system activation and deactivation.","title":"Main State Machine"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#states","text":"stateDiagram-v2 direction LR [*] --> Idle Idle --> AirnClose Idle --> Error AirnClose --> Idle AirnClose --> AirnStatus AirnClose --> Error AirnStatus --> Precharge AirnStatus --> Idle AirnStatus --> Error Precharge --> On Precharge --> Idle Precharge --> Error On --> Idle On --> Error Error --> Idle","title":"States"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#-idle","text":"When the TS is off and no fatal errors are present, the BMS is in the Idle state.","title":"- Idle"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#-airnclose","text":"When the procedure of activation of the Tractive System is requested. Additional feedbacks are checked in order to close the AIR negative.","title":"- AirnClose"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#-airnstatus","text":"Checks if the activation of the AIR negative is ok.","title":"- AirnStatus"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#-precharge","text":"The Precharge procedure is done to turn on the Tractive System. It involves the actuation of the precharge relay and the monitoring of the bus voltage. The bus voltage is periodically confronted with the internal voltage and when they are within 7% of each other the positive AIR is closed and the precharge relay is opened, ending the precharge procedure. The FSM then transitions to the TS_On state. If the bus voltage doesn't rise fast enough, the precharge fails and the FSM goes back to Idle.","title":"- Precharge"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#-ts_on","text":"In this state the high-voltage bus external to the battery is powered. This is the state in which the car can run, or the battery can be charged. When the TS_OFF event occurs, the FSM transitions back to Idle, opening both AIRs at the same time.","title":"- TS_On"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#-error","text":"If a fatal error is active the BMS is in this state. TS activation requests are ignored. If every fatal error expires, then the BMS returns to Idle and can accept TS on commands again.","title":"- Error"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/config/","text":"Config The config subsystem is a generic configuration manager that handles the storage and retrieval of vairables from an on-board EEPROM, model m95256. The config struct contains all the needed data: struct config { uint32_t version ; uint16_t address ; bool dirty ; size_t size ; void * data ; }; version stores a version string that is used during to verify that the read data is right. By changing the version string the data gets automatically overwritten with default values. The config struct is rendered opaque by the use of the config_t type. This avoids direct access to config 's content.","title":"Config"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/config/#config","text":"The config subsystem is a generic configuration manager that handles the storage and retrieval of vairables from an on-board EEPROM, model m95256. The config struct contains all the needed data: struct config { uint32_t version ; uint16_t address ; bool dirty ; size_t size ; void * data ; }; version stores a version string that is used during to verify that the read data is right. By changing the version string the data gets automatically overwritten with default values. The config struct is rendered opaque by the use of the config_t type. This avoids direct access to config 's content.","title":"Config"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/current/","text":"Current Current measurements involves 2 different sensors, the shunt resistor, measured through the isolated ADC and the 2-channel analog Hall sensor, sampled through internal ADCs. Current zeroing All the 3 measures involve offsets, which are calculated in those situations where the current is 0 (when both AIRs and precharge relay are open). Shunt resistor The value coming from the ADC is converted with this formula: (volt - shunt_offset) / (1e-4f * 500) Hall Sensor High channel The analog signal is read by adc2 in DMA mode in a 128 items array. When the current need to be retrieved, those values are averaged. The value is converted with this formula: (499.f / 300.f / 6.67e-3f) * (volt - high_channel_offset) Low channel The analog signal is read by adc3 in DMA mode in a 128 items array. When the current need to be retrieved, those values are averaged. The value is converted with this formula: (499.f / 300.f / 40e-3f) * (volt - low_channel_offset)","title":"Current"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/current/#current","text":"Current measurements involves 2 different sensors, the shunt resistor, measured through the isolated ADC and the 2-channel analog Hall sensor, sampled through internal ADCs.","title":"Current"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/current/#current-zeroing","text":"All the 3 measures involve offsets, which are calculated in those situations where the current is 0 (when both AIRs and precharge relay are open).","title":"Current zeroing"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/current/#shunt-resistor","text":"The value coming from the ADC is converted with this formula: (volt - shunt_offset) / (1e-4f * 500)","title":"Shunt resistor"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/current/#hall-sensor","text":"","title":"Hall Sensor"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/current/#high-channel","text":"The analog signal is read by adc2 in DMA mode in a 128 items array. When the current need to be retrieved, those values are averaged. The value is converted with this formula: (499.f / 300.f / 6.67e-3f) * (volt - high_channel_offset)","title":"High channel"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/current/#low-channel","text":"The analog signal is read by adc3 in DMA mode in a 128 items array. When the current need to be retrieved, those values are averaged. The value is converted with this formula: (499.f / 300.f / 40e-3f) * (volt - low_channel_offset)","title":"Low channel"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/feedback/","text":"Feedback Feedback system is a self check of the car state, used in the bms_fsm . It consists of 19 signals by which is possible to verify the correct behaviour of the fsm and react to changes on the shutdown. 16 of them are multiplexed and 3 are not, in order to react quicker to them. All theese signals are read with an internal ADC (adc1) in order to better interprete their logic state (actually if <2.5V is low, >9.5 is high and everything in between is unsafe)","title":"Feedback"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/feedback/#feedback","text":"Feedback system is a self check of the car state, used in the bms_fsm . It consists of 19 signals by which is possible to verify the correct behaviour of the fsm and react to changes on the shutdown. 16 of them are multiplexed and 3 are not, in order to react quicker to them. All theese signals are read with an internal ADC (adc1) in order to better interprete their logic state (actually if <2.5V is low, >9.5 is high and everything in between is unsafe)","title":"Feedback"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/timebase/","text":"Timebase It sets a timer to tick every 10ms, then sets the respective flag whenever a interval is matched. By calling it's routine function from the main loop is possible to execute the needed code at fixed intervals. Specifically is used to read voltages, current and temperatures, to send periodic can messages and to control fans.","title":"Timebase"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/timebase/#timebase","text":"It sets a timer to tick every 10ms, then sets the respective flag whenever a interval is matched. By calling it's routine function from the main loop is possible to execute the needed code at fixed intervals. Specifically is used to read voltages, current and temperatures, to send periodic can messages and to control fans.","title":"Timebase"},{"location":"fenice-bms-lv/","text":"Low Voltage Battery Management System The aim of the LV-BMS is to provide the necessary voltage supply to makes all low voltages components working, such as: DAS , Steering wheel , Telemetry boards, lights on board, pumps and radiators. Inside its case a (3S1P 4S1P ) LiPo Battery is present, which, when it's completely charged has a capacity of 16.5 Ah and a voltage of 12.45 V . Because of some components need fixed voltages of 12V and 24V, on the PCB are also present two DCDC converter (boost), which can deliver those voltages even with an input of 9V. The main job of the LV-BMS is to turn on or off the LVMS switch, in order to give or not power to the board. Monitoring the voltages and the temperature of the cells, the temperatures of the DCDCs converters, the battery overcurrent and other more parameters, the board can decide autonomously whether open or close the relay connected to the LVMS switch. Another important feature of the board it's the cooling routine, which consists in the pumps and radiator piloting to keep the inverters and the motors in a specific range of temperatures. The currently working branch of the repo is: dev-baremetal . All the main functions are mostly in the directory Lib Important It's advised to check BMS LV State Machine before reading other chapters. Tip Taking a look to the hardware never hurts \ud83e\udd70","title":"Low Voltage Battery Management System"},{"location":"fenice-bms-lv/#low-voltage-battery-management-system","text":"The aim of the LV-BMS is to provide the necessary voltage supply to makes all low voltages components working, such as: DAS , Steering wheel , Telemetry boards, lights on board, pumps and radiators. Inside its case a (3S1P 4S1P ) LiPo Battery is present, which, when it's completely charged has a capacity of 16.5 Ah and a voltage of 12.45 V . Because of some components need fixed voltages of 12V and 24V, on the PCB are also present two DCDC converter (boost), which can deliver those voltages even with an input of 9V. The main job of the LV-BMS is to turn on or off the LVMS switch, in order to give or not power to the board. Monitoring the voltages and the temperature of the cells, the temperatures of the DCDCs converters, the battery overcurrent and other more parameters, the board can decide autonomously whether open or close the relay connected to the LVMS switch. Another important feature of the board it's the cooling routine, which consists in the pumps and radiator piloting to keep the inverters and the motors in a specific range of temperatures. The currently working branch of the repo is: dev-baremetal . All the main functions are mostly in the directory Lib Important It's advised to check BMS LV State Machine before reading other chapters. Tip Taking a look to the hardware never hurts \ud83e\udd70","title":"Low Voltage Battery Management System"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/","text":"Command Line Interface The command line interface of the LV-BMS is based on the cli.h library and is used to communicate via UART peripheral. Parameters: baudrate at 115200 bit/s Pressing ? followed by Enter or just Enter return the command list Command - volts - radiator - pumps - temps - feedbacks - dmesg - reset - can - inv - cooling - errors - ? Commands volts Prints all cell voltages Parameters: status : append to the output also voltage status Possible outputs of voltage status: VOLT OK VOLT UNDER VOLTAGE VOLT OVER VOLTAGE VOLT ERROR Typical output without status parameter Example Cell 1 : 4.142 V Cell 2 : 4.159 V Cell 3 : 4.159 V Total voltage on board : 12.460 V radiator Used to set manually the duty cycle of a radiator, if cooling routine it's disabled, or just to see the status of the radiators and the internal fan inside the case. Parameters: L / R / B / info : select whether to set Left, Right, Both radiator value or just obtain the info about them duty_cycle / off : select a duty cycle from 0 to 1.0 (1.0 corresponds to 100%, and off to 0%) Typical output with info parameter Example Radiators status : Left Duty Cycle : 0.35 Right Duty Cycle : 0.35 Is right on : 1 Is left on : 1 Automatic mode : true Internal fan dt : 12.32 % Note Automatic mode tells to the user if the radiators and the internal fan values are set by the inverter temperatures, so they are spinning under the BMS control, or it they are piloted by the steering wheel pumps Used to set manually the pumps power, if cooling routine it's disabled, or just to see the status of the pumps. Parameters: info / p / v : choose whether to see the status of the pumps or set a specific value Note p stands for proportional and it would be followed by a value from 0 to 1.0, in fact the value is multiplied with MAX_OPAMP_OUT v stands for volt and it would be followed by a value from 0 to MAX_OPAMP_OUT , in fact the value represents the analog voltage level at the opamp output value : proportional or analog value choosen if the first parameter choosen is p or v Typical output with info parameter Example Pumps status Pumps L : 1.00 [ 4.95 V ] R : 1.00 [ 4.95 V ] Automatic mode : false Note When displayed, the first value of the pumps represents the proportionality with the output (1.0 = Max power ), and the second one enclosed in the square brackets is the analog value. Note Automatic mode tells to the user if the pumps value are set by the inverter temperatures, so they are under the BMS control, or it they are piloted by the steering wheel temps Returns the values of the various ADC sensors Example ADC sensors : Current : 2100.950623 [ mA ] Batt1 : 21.113552 [ \u00b0 C ] Batt2 : 20.952381 [ \u00b0 C ] DCDC 12 V : 21.032967 [ \u00b0 C ] DCDC 24 V : 20.952381 [ \u00b0 C ] feedbacks Returns the values of the MCP23017 chip, which holds all of the feedbacks signals Example FB_RELAY : 0 [ GPA0 ] FB_INVERTERS : 0 [ GPA1 ] GPIOA VAL : 0 [ GPA2 ] // useless feedback, held for consistency FB_24 : 0 [ GPA3 ] FB_PUMPS : 0 [ GPA4 ] FB_SHUTDOWN : 0 [ GPA5 ] FB_RADIATORS : 0 [ GPA6 ] FB_FAN : 0 [ GPA7 ] FB_MAIN : 1 [ GPB0 ] FB_PCBS : 0 [ GPB1 ] FB_12 : 0 [ GPB2 ] dmesg Use it if you want to show a debug message reset Invokes HAL_NVIC_SystemReset() and reset the MCU can Trigger some can messages, just for debug: Parameters: volts / cooling / total / current / temp : to send the relative can msg inv Optionally close or open the relays connected to the inverters and prints RFE and FRG values (relays values). With no parameters it just print the status of the pins. Parameters: on / off : close or open the inverter relays Example [ RFE ] : 1 [ FRG ] : 1 cooling Returns the cooling info (fancy way to do radiator info + pumps info ) Example Radiators status : Left Duty Cycle : 0.35 Right Duty Cycle : 0.35 Is right on : 1 Is left on : 1 Radiator automatic mode : true Internal fan dt : 12.51 % Pumps status Pumps L : 1.00 [ 4.95 V ] R : 1.00 [ 4.95 V ] Pumps automatic mode : false errors Returns the error count and, for every set error, the relative id with Example total 5 id ......... .20 ( dcdc12 off ) timestamp ... T + 2286 ( 169801 ms ago ) offset ..... .0 state ....... warning timeout delta 2147313845 id ......... .16 ( radiator ) timestamp ... T + 2298 ( 169789 ms ago ) offset ..... .1 state ....... warning timeout delta 2147313857 id ......... .17 ( fan ) timestamp ... T + 2298 ( 169789 ms ago ) offset ..... .0 state ....... warning timeout delta 2147313857 id ......... .21 ( dcdc24 off ) timestamp ... T + 2298 ( 169789 ms ago ) offset ..... .0 state ....... warning timeout delta 2147313857 id ......... .12 ( open relay ) timestamp ... T + 2299 ( 169788 ms ago ) offset ..... .0 state ....... warning timeout delta 2147313858","title":"Command Line Interface"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#command-line-interface","text":"The command line interface of the LV-BMS is based on the cli.h library and is used to communicate via UART peripheral. Parameters: baudrate at 115200 bit/s Pressing ? followed by Enter or just Enter return the command list Command - volts - radiator - pumps - temps - feedbacks - dmesg - reset - can - inv - cooling - errors - ?","title":"Command Line Interface"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#commands","text":"","title":"Commands"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#volts","text":"Prints all cell voltages","title":"volts"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#parameters","text":"status : append to the output also voltage status Possible outputs of voltage status: VOLT OK VOLT UNDER VOLTAGE VOLT OVER VOLTAGE VOLT ERROR Typical output without status parameter Example Cell 1 : 4.142 V Cell 2 : 4.159 V Cell 3 : 4.159 V Total voltage on board : 12.460 V","title":"Parameters:"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#radiator","text":"Used to set manually the duty cycle of a radiator, if cooling routine it's disabled, or just to see the status of the radiators and the internal fan inside the case.","title":"radiator"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#parameters_1","text":"L / R / B / info : select whether to set Left, Right, Both radiator value or just obtain the info about them duty_cycle / off : select a duty cycle from 0 to 1.0 (1.0 corresponds to 100%, and off to 0%) Typical output with info parameter Example Radiators status : Left Duty Cycle : 0.35 Right Duty Cycle : 0.35 Is right on : 1 Is left on : 1 Automatic mode : true Internal fan dt : 12.32 % Note Automatic mode tells to the user if the radiators and the internal fan values are set by the inverter temperatures, so they are spinning under the BMS control, or it they are piloted by the steering wheel","title":"Parameters:"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#pumps","text":"Used to set manually the pumps power, if cooling routine it's disabled, or just to see the status of the pumps.","title":"pumps"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#parameters_2","text":"info / p / v : choose whether to see the status of the pumps or set a specific value Note p stands for proportional and it would be followed by a value from 0 to 1.0, in fact the value is multiplied with MAX_OPAMP_OUT v stands for volt and it would be followed by a value from 0 to MAX_OPAMP_OUT , in fact the value represents the analog voltage level at the opamp output value : proportional or analog value choosen if the first parameter choosen is p or v Typical output with info parameter Example Pumps status Pumps L : 1.00 [ 4.95 V ] R : 1.00 [ 4.95 V ] Automatic mode : false Note When displayed, the first value of the pumps represents the proportionality with the output (1.0 = Max power ), and the second one enclosed in the square brackets is the analog value. Note Automatic mode tells to the user if the pumps value are set by the inverter temperatures, so they are under the BMS control, or it they are piloted by the steering wheel","title":"Parameters:"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#temps","text":"Returns the values of the various ADC sensors Example ADC sensors : Current : 2100.950623 [ mA ] Batt1 : 21.113552 [ \u00b0 C ] Batt2 : 20.952381 [ \u00b0 C ] DCDC 12 V : 21.032967 [ \u00b0 C ] DCDC 24 V : 20.952381 [ \u00b0 C ]","title":"temps"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#feedbacks","text":"Returns the values of the MCP23017 chip, which holds all of the feedbacks signals Example FB_RELAY : 0 [ GPA0 ] FB_INVERTERS : 0 [ GPA1 ] GPIOA VAL : 0 [ GPA2 ] // useless feedback, held for consistency FB_24 : 0 [ GPA3 ] FB_PUMPS : 0 [ GPA4 ] FB_SHUTDOWN : 0 [ GPA5 ] FB_RADIATORS : 0 [ GPA6 ] FB_FAN : 0 [ GPA7 ] FB_MAIN : 1 [ GPB0 ] FB_PCBS : 0 [ GPB1 ] FB_12 : 0 [ GPB2 ]","title":"feedbacks"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#dmesg","text":"Use it if you want to show a debug message","title":"dmesg"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#reset","text":"Invokes HAL_NVIC_SystemReset() and reset the MCU","title":"reset"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#can","text":"Trigger some can messages, just for debug:","title":"can"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#parameters_3","text":"volts / cooling / total / current / temp : to send the relative can msg","title":"Parameters:"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#inv","text":"Optionally close or open the relays connected to the inverters and prints RFE and FRG values (relays values). With no parameters it just print the status of the pins.","title":"inv"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#parameters_4","text":"on / off : close or open the inverter relays Example [ RFE ] : 1 [ FRG ] : 1","title":"Parameters:"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#cooling","text":"Returns the cooling info (fancy way to do radiator info + pumps info ) Example Radiators status : Left Duty Cycle : 0.35 Right Duty Cycle : 0.35 Is right on : 1 Is left on : 1 Radiator automatic mode : true Internal fan dt : 12.51 % Pumps status Pumps L : 1.00 [ 4.95 V ] R : 1.00 [ 4.95 V ] Pumps automatic mode : false","title":"cooling"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#errors","text":"Returns the error count and, for every set error, the relative id with Example total 5 id ......... .20 ( dcdc12 off ) timestamp ... T + 2286 ( 169801 ms ago ) offset ..... .0 state ....... warning timeout delta 2147313845 id ......... .16 ( radiator ) timestamp ... T + 2298 ( 169789 ms ago ) offset ..... .1 state ....... warning timeout delta 2147313857 id ......... .17 ( fan ) timestamp ... T + 2298 ( 169789 ms ago ) offset ..... .0 state ....... warning timeout delta 2147313857 id ......... .21 ( dcdc24 off ) timestamp ... T + 2298 ( 169789 ms ago ) offset ..... .0 state ....... warning timeout delta 2147313857 id ......... .12 ( open relay ) timestamp ... T + 2299 ( 169788 ms ago ) offset ..... .0 state ....... warning timeout delta 2147313858","title":"errors"},{"location":"fenice-bms-lv/Main%20functions/Cooling/","text":"Cooling One of the main purpouse of the LV-BMS is to control the cooling circuit of the car (composed of radiators and pumps). The operation is performed by changing the duty cycle of the radiators and the pumps power based on the average mean of the two inverter temperatures. The fan inside the case has to cool down the DCDCs, so its speed follows the average mean of them temperatures. Cooling routine It's a function wich takes as input the average mean of the two inverters temperature and set the speed of radiators and the power of the pumps based on a simple curve: \\(y=mx+q\\) Radiators The m factor as follows: \\(m = \\frac{(MAX\\_RADIATOR\\_DT-MIN\\_RADIATOR\\_DT)}{(MAX\\_INVERTER\\_TEMP-MIN\\_INVERTER\\_TEMP)}\\) Where: MAX_RADIATOR_DT is the max duty cycle allowed for the radiator MIN_RADIATOR_DT is the min duty cycle allowed for the radiator MAX_INVERTER_TEMP is the inverter temperature associated with the MAX_RADIATOR_DT value (basically when the radiators need to go to max speed and cool as much as possible) MIN_INVERTER_TEMP is the inverter min temperature associated with MIN_RADIATOR_DT value (basically when radiators need to start cooling at them min duty cycle) The q factor as follows: \\(q = (MIN\\_RADIATOR\\_DT-(MIN\\_INVERTER\\_TEMP*m))\\) Given: Costant Value MAX_RADIATOR_DT 0.9 MIX_RADIATOR_DT 0.8 MAX_INVERTER_TEMP 60 MIN_INVERTER_TEMP 40 We can obtain: Inverter temperature \u00b0C Radiator Duty Cycle 0 -0.3 10 -0.1 20 0.1 30 0.3 40 0.5 50 0.7 60 0.9 Note Negative value are carried to zero via sw Pumps The m factor as follows: \\(m = \\frac{(MAX\\_OPAMP\\_OUT-MIN\\_OPAMP\\_OUT)}{(MAX\\_INVERTER\\_TEMP-MIN\\_INVERTER\\_TEMP)}\\) Where: MAX_OPAMP_OUT is the max allowed output voltage given by the opamp wich feeds the pumps MAX_OPAMP_OUT is the min allowed output voltage given by the opamp wich feeds the pumps MAX_INVERTER_TEMP is the inverter temperature associated with the MAX_OPAMP_OUT value (basically when the pumps need to go to max power and cool as much as possible) MIN_INVERTER_TEMP is the inverter min temperature associated with MIN_OPAMP_OUT value (basically when pumps need to start cooling at them min power value) The q factor as follows: \\(q = MIN\\_OPAMP\\_OUT-(MIN\\_INVERTER\\_TEMP*m)\\) Given: Costant Value MAX_OPAMP_OUT 4.95 MIN_OPAMP_OUT 0 MAX_INVERTER_TEMP 60 MIN_INVERTER_TEMP 40 We can obtain: Inverter temperature \u00b0C Analog Pumps value 0 -9.9 10 -7.425 20 -4.95 30 -2.475 40 0 50 2.475 60 4.95 Note Negative value are carried to zero via sw","title":"Cooling"},{"location":"fenice-bms-lv/Main%20functions/Cooling/#cooling","text":"One of the main purpouse of the LV-BMS is to control the cooling circuit of the car (composed of radiators and pumps). The operation is performed by changing the duty cycle of the radiators and the pumps power based on the average mean of the two inverter temperatures. The fan inside the case has to cool down the DCDCs, so its speed follows the average mean of them temperatures.","title":"Cooling"},{"location":"fenice-bms-lv/Main%20functions/Cooling/#cooling-routine","text":"It's a function wich takes as input the average mean of the two inverters temperature and set the speed of radiators and the power of the pumps based on a simple curve: \\(y=mx+q\\)","title":"Cooling routine"},{"location":"fenice-bms-lv/Main%20functions/Cooling/#radiators","text":"The m factor as follows: \\(m = \\frac{(MAX\\_RADIATOR\\_DT-MIN\\_RADIATOR\\_DT)}{(MAX\\_INVERTER\\_TEMP-MIN\\_INVERTER\\_TEMP)}\\) Where: MAX_RADIATOR_DT is the max duty cycle allowed for the radiator MIN_RADIATOR_DT is the min duty cycle allowed for the radiator MAX_INVERTER_TEMP is the inverter temperature associated with the MAX_RADIATOR_DT value (basically when the radiators need to go to max speed and cool as much as possible) MIN_INVERTER_TEMP is the inverter min temperature associated with MIN_RADIATOR_DT value (basically when radiators need to start cooling at them min duty cycle) The q factor as follows: \\(q = (MIN\\_RADIATOR\\_DT-(MIN\\_INVERTER\\_TEMP*m))\\) Given: Costant Value MAX_RADIATOR_DT 0.9 MIX_RADIATOR_DT 0.8 MAX_INVERTER_TEMP 60 MIN_INVERTER_TEMP 40 We can obtain: Inverter temperature \u00b0C Radiator Duty Cycle 0 -0.3 10 -0.1 20 0.1 30 0.3 40 0.5 50 0.7 60 0.9 Note Negative value are carried to zero via sw","title":"Radiators"},{"location":"fenice-bms-lv/Main%20functions/Cooling/#pumps","text":"The m factor as follows: \\(m = \\frac{(MAX\\_OPAMP\\_OUT-MIN\\_OPAMP\\_OUT)}{(MAX\\_INVERTER\\_TEMP-MIN\\_INVERTER\\_TEMP)}\\) Where: MAX_OPAMP_OUT is the max allowed output voltage given by the opamp wich feeds the pumps MAX_OPAMP_OUT is the min allowed output voltage given by the opamp wich feeds the pumps MAX_INVERTER_TEMP is the inverter temperature associated with the MAX_OPAMP_OUT value (basically when the pumps need to go to max power and cool as much as possible) MIN_INVERTER_TEMP is the inverter min temperature associated with MIN_OPAMP_OUT value (basically when pumps need to start cooling at them min power value) The q factor as follows: \\(q = MIN\\_OPAMP\\_OUT-(MIN\\_INVERTER\\_TEMP*m)\\) Given: Costant Value MAX_OPAMP_OUT 4.95 MIN_OPAMP_OUT 0 MAX_INVERTER_TEMP 60 MIN_INVERTER_TEMP 40 We can obtain: Inverter temperature \u00b0C Analog Pumps value 0 -9.9 10 -7.425 20 -4.95 30 -2.475 40 0 50 2.475 60 4.95 Note Negative value are carried to zero via sw","title":"Pumps"},{"location":"fenice-bms-lv/Main%20functions/Errors/","text":"Errors All errors are managed by a specific library written by: Simone Ruffini & Matteo Bonora . Here's a list of all possible errors the LV-BMSs can handle. Every error it's reported with its specific ID and TIMEOUT . ID Error name TIMEOUT 0 ERROR_CELL_UNDERVOLTAGE 400 1 ERROR_CELL_OVERVOLTAGE 400 2 ERROR_OPEN_WIRE 400 3 ERROR_CAN 500 4 ERROR_SPI 500 5 ERROR_OVER_CURRENT 400 6 ERROR_DCDC12_UNDER_TEMPERATURE 1000 7 ERROR_DCDC12_OVER_TEMPERATURE 1000 8 ERROR_DCDC24_UNDER_TEMPERATURE 1000 9 ERROR_DCDC24_OVER_TEMPERATURE 1000 10 ERROR_CELL_UNDER_TEMPERATURE 1000 11 ERROR_CELL_OVER_TEMPERATURE 1000 12 ERROR_RELAY SOFT 13 ERROR_LTC6810 500 14 ERROR_VOLTAGES_NOT_READY 500 15 ERROR_MCP23017 1000 16 ERROR_RADIATOR SOFT 17 ERROR_FAN SOFT 18 ERROR_PUMP SOFT 19 ERROR_ADC_INIT 1000 20 ERROR_DCDC12 SOFT 21 ERROR_DCDC24 SOFT Note SOFT means that the error won't be fatal in any case. Every error its represented as a node of a linked list, and it can hold multiple sub-errors, for example to handle the errors for the LV Accumulator // Declaration of the llist_node llist_node error_list_ref_low_voltages [ LV_CELLS_COUNT ] = { NULL }; // A single error inside the node can be set or reset using the offset An error can be set with: error_set ( ERROR_NAME , offset , starting_time ); and unset with: error_reset ( ERROR_NAME , offset ); If a set error reaches its TIMEOUT it become fatal and turn the LV-BMS into the error state .","title":"Errors"},{"location":"fenice-bms-lv/Main%20functions/Errors/#errors","text":"All errors are managed by a specific library written by: Simone Ruffini & Matteo Bonora . Here's a list of all possible errors the LV-BMSs can handle. Every error it's reported with its specific ID and TIMEOUT . ID Error name TIMEOUT 0 ERROR_CELL_UNDERVOLTAGE 400 1 ERROR_CELL_OVERVOLTAGE 400 2 ERROR_OPEN_WIRE 400 3 ERROR_CAN 500 4 ERROR_SPI 500 5 ERROR_OVER_CURRENT 400 6 ERROR_DCDC12_UNDER_TEMPERATURE 1000 7 ERROR_DCDC12_OVER_TEMPERATURE 1000 8 ERROR_DCDC24_UNDER_TEMPERATURE 1000 9 ERROR_DCDC24_OVER_TEMPERATURE 1000 10 ERROR_CELL_UNDER_TEMPERATURE 1000 11 ERROR_CELL_OVER_TEMPERATURE 1000 12 ERROR_RELAY SOFT 13 ERROR_LTC6810 500 14 ERROR_VOLTAGES_NOT_READY 500 15 ERROR_MCP23017 1000 16 ERROR_RADIATOR SOFT 17 ERROR_FAN SOFT 18 ERROR_PUMP SOFT 19 ERROR_ADC_INIT 1000 20 ERROR_DCDC12 SOFT 21 ERROR_DCDC24 SOFT Note SOFT means that the error won't be fatal in any case. Every error its represented as a node of a linked list, and it can hold multiple sub-errors, for example to handle the errors for the LV Accumulator // Declaration of the llist_node llist_node error_list_ref_low_voltages [ LV_CELLS_COUNT ] = { NULL }; // A single error inside the node can be set or reset using the offset An error can be set with: error_set ( ERROR_NAME , offset , starting_time ); and unset with: error_reset ( ERROR_NAME , offset ); If a set error reaches its TIMEOUT it become fatal and turn the LV-BMS into the error state .","title":"Errors"},{"location":"fenice-bms-lv/Main%20functions/Feedbacks%20signals/","text":"Feedbacks signals The IC MCP23017 is a GPIO Expander , which uses I2C bus to monitor the status of some feedbacks on the board. List of the feedbacks on board: FB_Main : indicate if LVMS is closed FB_12 : indicate if there are 12V on the DCDC12V output FB_PCBS : depends on FB_12 FB_Relay : indicate if the relay is closed or not FB_24 : indicate if there are 24V on the DCDC24V output FB_Inverters : depends on FB_24 FB_PUMPS : depends on FB_24 FB_SHUTDOWN : depends on FB_12 FB_RADIATORS : depends on FB_12 FB_FAN : depends on FB_12 Warning With the latest configuration of the board FB_Main is always 1 Note Latest configuration = BMS wiring inside its case Faq You can obtain a specific Feedback value using a specific functions declared in main.h Example //Check if there are 12V on board, needed to supply other boards bool feedback_state = FDBK_12V_PCBS_get_state ();","title":"Feedbacks signals"},{"location":"fenice-bms-lv/Main%20functions/Feedbacks%20signals/#feedbacks-signals","text":"The IC MCP23017 is a GPIO Expander , which uses I2C bus to monitor the status of some feedbacks on the board. List of the feedbacks on board: FB_Main : indicate if LVMS is closed FB_12 : indicate if there are 12V on the DCDC12V output FB_PCBS : depends on FB_12 FB_Relay : indicate if the relay is closed or not FB_24 : indicate if there are 24V on the DCDC24V output FB_Inverters : depends on FB_24 FB_PUMPS : depends on FB_24 FB_SHUTDOWN : depends on FB_12 FB_RADIATORS : depends on FB_12 FB_FAN : depends on FB_12 Warning With the latest configuration of the board FB_Main is always 1 Note Latest configuration = BMS wiring inside its case Faq You can obtain a specific Feedback value using a specific functions declared in main.h Example //Check if there are 12V on board, needed to supply other boards bool feedback_state = FDBK_12V_PCBS_get_state ();","title":"Feedbacks signals"},{"location":"fenice-bms-lv/Main%20functions/IOC%20file%20and%20pinout/","text":"IOC File and Pinout The .ioc file is the magic tool with the fw-devs can configure the pin functions, the peripherals parameters and the clock of the mcu. Here are the main pheriperals used in this project: Can Bus : to communicate with other devices on board UART : to communicate with the user in serial Baud Rate : 115200 Bit/s Word Length : 8 Bits Parity : None Stop Bits : 1 DAC : (Digital to Analog Converter) to control the pumps ADC : (Analog to Digital Converter) to read the temperature of the battery and the DCDCs, also used with the current sensing Current trasducer : HO-S_SP33-1106 (x1) ADC used : ADC1 Channel : CHANNEL 10 Sampling Time : 480 Cycles Temperature sensor : LM35 (x4) ADC used : ADC2 DCDC 12V Channel : CHANNEL 12 Sampling Time : 480 Cycles DCDC 24V Channel : CHANNEL 13 Sampling Time : 480 Cycles Battery side 1 Channel : CHANNEL 0 Sampling Time : 480 Cycles Battery side 2 Channel : CHANNEL 1 Sampling Time : 480 Cycles Timers : to manage time critical tasks TIM2 : used for Errors time tracking, Measurements, CAN messages Errors time tracking: Channel: TIM_CHANNEL_4 Mode: : Output compare no output Measurements : after the sensing phase the relative message it will be sent via CAN Cooling + LV_VERSION Channel: TIM_CHANNEL_1 Mode: : Output compare no output Timeout (ms): 1000 Current sensing + Inverter status Channel: TIM_CHANNEL_2 Mode: : Output compare no output Timeout (ms): 500 Voltage sensing + Temperature sensing Channel: TIM_CHANNEL_2 Mode: : Output compare no output Timeout (ms): 100 TIM3 : used to generate PWM signal for Right and Left radiators, and internal fan Left Radiator Channel: TIM_CHANNEL_1 Mode: : PWM Generator CH1 Frequency: 24 kHz Right Radiator Channel: TIM_CHANNEL_2 Mode: : PWM Generator CH2 Frequency: 24 kHz Fan inside the BMS Case Channel: TIM_CHANNEL_2 Mode: : PWM Generator CH2 Frequency: 24 kHz TIM4 : used to check if OPEN WIRE occurs Open wire check Channel: TIM_CHANNEL_2 Mode: : Output compare no output Timeout (ms): 50 TIM5 : used to hardware trigger the ADC Open wire check Channel: TIM_CHANNEL_1 Mode: : PWM Generator no output Frequency: 20 kHz TIM7 : used as sw interrupt to save ADC values via DMA Channel: TIM_CHANNEL_1 Mode: : PWM Generator no output Frequency: 1 kHz TIM7 : used as pwm output for the buzzer Channel: TIM_CHANNEL_1 Mode: : PWM Generator CH1 Frequency: 1 kHz","title":"IOC File and Pinout"},{"location":"fenice-bms-lv/Main%20functions/IOC%20file%20and%20pinout/#ioc-file-and-pinout","text":"The .ioc file is the magic tool with the fw-devs can configure the pin functions, the peripherals parameters and the clock of the mcu. Here are the main pheriperals used in this project: Can Bus : to communicate with other devices on board UART : to communicate with the user in serial Baud Rate : 115200 Bit/s Word Length : 8 Bits Parity : None Stop Bits : 1 DAC : (Digital to Analog Converter) to control the pumps ADC : (Analog to Digital Converter) to read the temperature of the battery and the DCDCs, also used with the current sensing Current trasducer : HO-S_SP33-1106 (x1) ADC used : ADC1 Channel : CHANNEL 10 Sampling Time : 480 Cycles Temperature sensor : LM35 (x4) ADC used : ADC2 DCDC 12V Channel : CHANNEL 12 Sampling Time : 480 Cycles DCDC 24V Channel : CHANNEL 13 Sampling Time : 480 Cycles Battery side 1 Channel : CHANNEL 0 Sampling Time : 480 Cycles Battery side 2 Channel : CHANNEL 1 Sampling Time : 480 Cycles Timers : to manage time critical tasks TIM2 : used for Errors time tracking, Measurements, CAN messages Errors time tracking: Channel: TIM_CHANNEL_4 Mode: : Output compare no output Measurements : after the sensing phase the relative message it will be sent via CAN Cooling + LV_VERSION Channel: TIM_CHANNEL_1 Mode: : Output compare no output Timeout (ms): 1000 Current sensing + Inverter status Channel: TIM_CHANNEL_2 Mode: : Output compare no output Timeout (ms): 500 Voltage sensing + Temperature sensing Channel: TIM_CHANNEL_2 Mode: : Output compare no output Timeout (ms): 100 TIM3 : used to generate PWM signal for Right and Left radiators, and internal fan Left Radiator Channel: TIM_CHANNEL_1 Mode: : PWM Generator CH1 Frequency: 24 kHz Right Radiator Channel: TIM_CHANNEL_2 Mode: : PWM Generator CH2 Frequency: 24 kHz Fan inside the BMS Case Channel: TIM_CHANNEL_2 Mode: : PWM Generator CH2 Frequency: 24 kHz TIM4 : used to check if OPEN WIRE occurs Open wire check Channel: TIM_CHANNEL_2 Mode: : Output compare no output Timeout (ms): 50 TIM5 : used to hardware trigger the ADC Open wire check Channel: TIM_CHANNEL_1 Mode: : PWM Generator no output Frequency: 20 kHz TIM7 : used as sw interrupt to save ADC values via DMA Channel: TIM_CHANNEL_1 Mode: : PWM Generator no output Frequency: 1 kHz TIM7 : used as pwm output for the buzzer Channel: TIM_CHANNEL_1 Mode: : PWM Generator CH1 Frequency: 1 kHz","title":"IOC File and Pinout"},{"location":"fenice-bms-lv/Main%20functions/State%20machine/","text":"State Machine Here you can find the firmware flowchart for the LV-BMS , don't be scared, there isn't a real state machine at all! The flowchart can be splitted into three stages: Warm up stage : Nothing in the car is already powered, the BMS is still initializing the peripherals and checking if there's a minimum amount of voltage from the battery to close the relay. Run stage : All the time critical tasks are executed Error stage : The system can still communicate via CLI and CAN Bus, however the relays is switched off and the car is not powered graph TD; subgraph Warm up stage A[Peripherals init] -->B[Accumulator total voltage measurement] B-->C{Measure attempt <br> <= <br> VOLT_MAX_ATTEMPTS} C--YES-->D{Total voltage measured <br> > <br> MIN_POWER_ON_VOLTAGE?} D--YES-->F[Close relay + Play buzzer] end C--NO-->E[Error state] D--NO-->B subgraph Run stage F-->F1[CLI Loop] F1-->F2[Do periodic measurements and send can messages] F2-->F2.1[Check feedback values] F2.1-->F3[Run cooling routine] F3-->F4{Errors or SCS?} F4--NO-->F1 F4--YES-->F5{Has error <br> reached its TIMEOUT?} F5--NO-->F1 end subgraph Error stage F5--YES-->E E-->E1[Open relay] E1-->E2[Loop CLI + Led Blink] E2-->E3[Do periodic measurements and send can messages] E3-->E2 end","title":"State Machine"},{"location":"fenice-bms-lv/Main%20functions/State%20machine/#state-machine","text":"Here you can find the firmware flowchart for the LV-BMS , don't be scared, there isn't a real state machine at all! The flowchart can be splitted into three stages: Warm up stage : Nothing in the car is already powered, the BMS is still initializing the peripherals and checking if there's a minimum amount of voltage from the battery to close the relay. Run stage : All the time critical tasks are executed Error stage : The system can still communicate via CLI and CAN Bus, however the relays is switched off and the car is not powered graph TD; subgraph Warm up stage A[Peripherals init] -->B[Accumulator total voltage measurement] B-->C{Measure attempt <br> <= <br> VOLT_MAX_ATTEMPTS} C--YES-->D{Total voltage measured <br> > <br> MIN_POWER_ON_VOLTAGE?} D--YES-->F[Close relay + Play buzzer] end C--NO-->E[Error state] D--NO-->B subgraph Run stage F-->F1[CLI Loop] F1-->F2[Do periodic measurements and send can messages] F2-->F2.1[Check feedback values] F2.1-->F3[Run cooling routine] F3-->F4{Errors or SCS?} F4--NO-->F1 F4--YES-->F5{Has error <br> reached its TIMEOUT?} F5--NO-->F1 end subgraph Error stage F5--YES-->E E-->E1[Open relay] E1-->E2[Loop CLI + Led Blink] E2-->E3[Do periodic measurements and send can messages] E3-->E2 end","title":"State Machine"},{"location":"fenice-bms-lv/Main%20functions/Timing%20and%20Can%20messages/","text":"Timing and CAN Messages Following the rules is mandatory for the LV-BMS and, to accomplish the required tasks, the system need to stick to a specific timing for each measurement or message sending. For this reason a specific timer with more compare threshold has been chosen (see TIM2 config) . For the 90% of the cases, when the timer is triggered to make a measure, it also send the relative payload via CAN. Intervals Here's the following periodic intervals Interval name Interval (ms) OPEN_WIRE_MEASURE 50 VOLT_MEASURE 100 CURRENT_AND_INVERTER_STATUS_MEASURE 500 TEMPERATURE_MEASURE 100 COOLING_STATUS 1000 LV_VERSION 1000 Flags setting When the measurement module is initialized the timer threshold are set and the flags are cleared. Help TIM2 is not the only timer which handles the measurements, in fact there's also TIM4 that it's dedicated to the OPEN WIRE check When an interrupts occurs a flag is set and the timer compare threshold is moved forward using for another period, in this way: // Set new threshold __HAL_TIM_SetCompare ( timer_handle , timer_channel , actual_counter + TIM_MS_TO_TICKS ( timer_handle , TRIGGERED_MEASURE_INTERVAL )); // Set the flag flags |= TRIGGERED_MEASURE_FLAG To understand if an event has occured a flag is set uint8_t flags ; // Like a bitset enum { MEAS_OPEN_WIRE = 1 , MEAS_VOLTS_AND_TEMPS_READ_FLAG = 2 , MEAS_COOLING_AND_LV_VERSION_READ_FLAG = 4 , MEAS_CURRENT_AND_INVERTERS_STATUS_READ_FLAG = 8 }; Flags check During the Running stage of the LV-BMS every flags checked with this basic logic: if ( flags & SELECTED_FLAG ){ //do stuffs ... //remove the flags flags &= ~ SELECTED_FLAGS ; } Example of a measure and can send if ( flags & MEAS_VOLTS_AND_TEMPS_READ_FLAG ) { // measure with the function sample and read if ( volt_sample_and_read () != VOLT_ERR ) { // if no errors are returned the data are sent via CAN can_primary_send ( primary_ID_LV_VOLTAGE ); can_primary_send ( primary_ID_LV_TOTAL_VOLTAGE ); } can_primary_send ( primary_ID_LV_TEMPERATURE ); flags &= ~ MEAS_VOLTS_AND_TEMPS_READ_FLAG ; }","title":"Timing and CAN Messages"},{"location":"fenice-bms-lv/Main%20functions/Timing%20and%20Can%20messages/#timing-and-can-messages","text":"Following the rules is mandatory for the LV-BMS and, to accomplish the required tasks, the system need to stick to a specific timing for each measurement or message sending. For this reason a specific timer with more compare threshold has been chosen (see TIM2 config) . For the 90% of the cases, when the timer is triggered to make a measure, it also send the relative payload via CAN.","title":"Timing and CAN Messages"},{"location":"fenice-bms-lv/Main%20functions/Timing%20and%20Can%20messages/#intervals","text":"Here's the following periodic intervals Interval name Interval (ms) OPEN_WIRE_MEASURE 50 VOLT_MEASURE 100 CURRENT_AND_INVERTER_STATUS_MEASURE 500 TEMPERATURE_MEASURE 100 COOLING_STATUS 1000 LV_VERSION 1000","title":"Intervals"},{"location":"fenice-bms-lv/Main%20functions/Timing%20and%20Can%20messages/#flags-setting","text":"When the measurement module is initialized the timer threshold are set and the flags are cleared. Help TIM2 is not the only timer which handles the measurements, in fact there's also TIM4 that it's dedicated to the OPEN WIRE check When an interrupts occurs a flag is set and the timer compare threshold is moved forward using for another period, in this way: // Set new threshold __HAL_TIM_SetCompare ( timer_handle , timer_channel , actual_counter + TIM_MS_TO_TICKS ( timer_handle , TRIGGERED_MEASURE_INTERVAL )); // Set the flag flags |= TRIGGERED_MEASURE_FLAG To understand if an event has occured a flag is set uint8_t flags ; // Like a bitset enum { MEAS_OPEN_WIRE = 1 , MEAS_VOLTS_AND_TEMPS_READ_FLAG = 2 , MEAS_COOLING_AND_LV_VERSION_READ_FLAG = 4 , MEAS_CURRENT_AND_INVERTERS_STATUS_READ_FLAG = 8 };","title":"Flags setting"},{"location":"fenice-bms-lv/Main%20functions/Timing%20and%20Can%20messages/#flags-check","text":"During the Running stage of the LV-BMS every flags checked with this basic logic: if ( flags & SELECTED_FLAG ){ //do stuffs ... //remove the flags flags &= ~ SELECTED_FLAGS ; }","title":"Flags check"},{"location":"fenice-bms-lv/Main%20functions/Timing%20and%20Can%20messages/#example-of-a-measure-and-can-send","text":"if ( flags & MEAS_VOLTS_AND_TEMPS_READ_FLAG ) { // measure with the function sample and read if ( volt_sample_and_read () != VOLT_ERR ) { // if no errors are returned the data are sent via CAN can_primary_send ( primary_ID_LV_VOLTAGE ); can_primary_send ( primary_ID_LV_TOTAL_VOLTAGE ); } can_primary_send ( primary_ID_LV_TEMPERATURE ); flags &= ~ MEAS_VOLTS_AND_TEMPS_READ_FLAG ; }","title":"Example of a measure and can send"},{"location":"fenice-dampers-DMT/Home/","text":"Linear vs non linear model Linear model The linear damper model is widely used and approximates the damping force as a proportional relation between damping force and velocity which is the input given: this proportion is given by a damping coefficient. The linear relationship is this following: \\[ F_{\\text {lindamp }}=d * v \\] Non linear model From empicarical test we can infer, however,that the linear model is a distant approximation of the real behaviour of the damper: experimentally, we can notice that the real behavior of the damper has different characteristics if it plays in rebound or bound (compression) conditions (for example if it is stressed by a gutter or a bump) and in both of two cases the behavior is different above or under a specific critical velocity . This behavior is difficult to express analitacally, because the diagrams used are empirically determined by the fitting of experimentally taken data. Empirically evidences on the non linear model Are shown below some diagrams obtained by empirical tests, that are the beginning point to search an analitacally for of the non linear damping behavior: Figure 1: Empirical diagram Figure 2: Empirical diagram Figure 3: Empirical diagram Non linear behavior modeling Assumptions As just seen on a linear dumper diagram or on a non linear dumper diagram there are present the force and the velocity. In the linear model there is a single slope this means that there is only one coefficient that links speed to the force. Instead the non linear curve can be approximated using straight lines with different slopes. The behavior in compression and in traction are different this leads to a total of four different coefficients. So to model a non-linear damper we can use a piecewise defined function where two critical speeds one for compression and one for traction separate the slopes of the curve. Figure 4: Linear curve Figure 5: Non linear curve Process For the achievement of this model/function we used the Matlab software. Initially to obtain this function we used some generic parameters. We define four functions (F1,F2,F3,F4) that repre- sent four straigth lines with different slopes modeled with four different coefficients (D1,D2,D3,D4). The four coefficients will be determined by an optimization process. We define two fixed critical velocity \\(c r 1 \\mathrm{e} c r 2\\) and to limit these functions a critical velocity \\(c r \\max\\) . The two functions F2 e F3 begin from the origin so they dont\u2019have to be traslated instead the F1 e F4 functions have to be traslated respectivly in the vertical direction of the value of the adiacent function calculated in the critical point and the horizontal direction of the respective critical velocity value. \\[ F_{\\text {nonlindamp }}(x)= \\begin{cases}D_{1}\\left(v-v_{c r 1}\\right)+D_{2} v_{c r 1} & v<v_{c r 1} \\\\ D_{2} v & v_{c r 1} \\leq v<0 \\\\ D_{3} v & 0 \\leq v<v_{c r 2} \\\\ D_{4}\\left(v-v_{c r 2}\\right)+D_{3} v_{c r 2} & v>v_{c r 2}\\end{cases} \\] Figure 6: Test function Once the model was validated, everything was inserted in a Matlab function with the if conditions in order to be able to use it in the model. Figure 7: Function for minimization Obtaining coefficients After making the model it had to be realized a \"Quarter car\" models (see section (4)), that is a a model that represents a quarter of a vehicle, in which it has been inserted the non-linear damper model, the spring, the mass of the vehicle and in addition a model of a tire that can be represented with spring, a damper and a mass. All the values of the elastic constants, of the masses(the sprung mass for rear and front and the tire) and the damping coefficient of the tire have been obtained from tests performed on the car. As input it has been inserted a road profile that will be discussed in section (3). Thanks to the \"Quarter car\" model and a minimization process that tries to find the minimum value of the force acting on the road the four coefficients for the non-linear curve and the two critical speeds can be found. Road parameters determination for simulation purpose In the simulation we have to determine the input velocity on the damper and so the road profile, because this velocity is generated by the vertical excursion of the pneumatic that follows the road profile assuming, to determine this excursion, a constant reference that represent a plane road: so we define a road profile that considers the asphalt and road type. Classification of the road profile For the road classification we base on the ISO 8606 that uses the power spectral density (PSD): \\[ \\Phi(\\Omega) \\] where we define \\(\\Omega\\) as an angular spatial frequency; we define moreover \\(\\Omega_{0}=1 \\mathrm{rad} / \\mathrm{m}\\) as a reference function and \\(\\Phi_{0}\\) as a descriptive value of the PSD on the reference frequency. Considering these variables, when a vehicle moves along a road with a \\(v\\) velocity, the excitation frequency of the road input become \\(\\omega=\\Omega v\\) . We define moreover the \\(\\alpha\\) coefficient as a coefficient that represent the road state . The power spectral density is: \\[ \\Phi(\\Omega)=\\Phi_{0}\\left(\\frac{\\Omega}{\\Omega_{0}}\\right)^{-\\omega} \\] Road profile modeling With some tables we can obtain various coefficients to determine different power spectral density of different road types. For simulation purpose we can emulate the road profile with a filter with \\(\\alpha, \\omega, v\\) parameters, which transfer function is: \\[ H(\\omega)=\\frac{1}{\\alpha v+j \\omega} \\] Different alpha values can be obtained, for example some usefull values are: \\(\\alpha=0.15 \\mathrm{~m}^{-} 1\\) for a \\(\\mathrm{v}=10-50 \\mathrm{~m} / \\mathrm{s}\\) velocity with variance \\(9 \\mathrm{~mm}^{2}\\) for asphalted road \\(\\alpha=0.45 \\mathrm{~m}^{-} 1\\) for a \\(\\mathrm{v}=5-30 \\mathrm{~m} / \\mathrm{s}\\) velocity with variance \\(300 \\mathrm{~mm}^{2}\\) for paved road or \\(\\alpha=0.127 \\mathrm{~m}^{-} 1\\) that is a standard that derives from a white noise and we can use it indipendently from the road type. Quarter Car simulation with non linear Damper To test the non linear damper model, as seen above, we use this simulink model: Figure 8: Simulink model Quarter car part This part of the Simulink model is the part that represents the quarter car: Figure 9: Quarter Car The \"Car\" box represents the usprung mass of the vehicle modeled as a lumped element, connected to the parallel of a \"Spring\" with the \"NLDamper\" (non linear damper); this part is connected in series with the \" Tire\" box that represents the unsprung mass of the tire, modeled as a lumped element, that is connected to another spring-damper parallel (Tire Stiffnes and Tire Damper). From this block we can monitorate various vehicle parameters as the vertical acceleration, the velocity (that is a parameter that is given to the NL Damper block for the computation of the curves) of the masses. Non linear damper part Figure 10: Non linear damper In this part of the non linear damper it has been inserted the function discussed previously in section 2. The input values are the difference between the velocity of the sprung mass and the unsprung mass and the six parameters that are needed. The output of this block is the value of the function. Road profile part Figure 11: Road profile This part is essentially explained in the third section and it's only implemented in a block-diagram way; only one annotation: in the \"Road\" box there is a direct connection between the input and the \"Pos\" output and the \"Vel\" output is given by the definition of velocity with the input given. Results Front Figure 12: Non linear curve obtained(front) As result is has been obtained a curve with the following parameters: The critical speed in compression: \\(-0.045733 \\frac{\\mathrm{m}}{\\mathrm{s}}\\) The critical speed in traction: \\(0.043852 \\frac{\\mathrm{m}}{\\mathrm{s}}\\) Compression in high-speed: \\(569.3763 \\frac{\\mathrm{Ns}}{\\mathrm{m}}\\) Compression in low-speed: \\(921.2548 \\frac{\\mathrm{Ns}}{\\mathrm{m}}\\) Traction in low-speed: \\(2166.7664 \\frac{\\mathrm{Ns}}{\\mathrm{m}}\\) Traction in high-speed: \\(1443.0206 \\frac{N s}{m}\\) Rear Figure 13: Non linear curve obtained(rear) As result is has been obtained a curve with the following parameters: The critical speed in compression: \\(-0.048829 \\frac{\\mathrm{m}}{\\mathrm{s}}\\) The critical speed in traction: \\(0.05451 \\frac{\\mathrm{m}}{\\mathrm{s}}\\) Compression in high-speed: \\(740.4203 \\frac{\\mathrm{Ns}}{\\mathrm{m}}\\) Compression in low-speed: \\(1121.4413 \\frac{N s}{m}\\) Traction in low-speed: \\(1107.1417 \\frac{N s}{m}\\) Traction in high-speed: \\(840.9172 \\frac{\\mathrm{Ns}}{\\mathrm{m}}\\) Revisioni 03/2020 - Initial Release (Grano, Rinaldi)","title":"Linear vs non linear model"},{"location":"fenice-dampers-DMT/Home/#linear-vs-non-linear-model","text":"","title":"Linear vs non linear model"},{"location":"fenice-dampers-DMT/Home/#linear-model","text":"The linear damper model is widely used and approximates the damping force as a proportional relation between damping force and velocity which is the input given: this proportion is given by a damping coefficient. The linear relationship is this following: \\[ F_{\\text {lindamp }}=d * v \\]","title":"Linear model"},{"location":"fenice-dampers-DMT/Home/#non-linear-model","text":"From empicarical test we can infer, however,that the linear model is a distant approximation of the real behaviour of the damper: experimentally, we can notice that the real behavior of the damper has different characteristics if it plays in rebound or bound (compression) conditions (for example if it is stressed by a gutter or a bump) and in both of two cases the behavior is different above or under a specific critical velocity . This behavior is difficult to express analitacally, because the diagrams used are empirically determined by the fitting of experimentally taken data.","title":"Non linear model"},{"location":"fenice-dampers-DMT/Home/#empirically-evidences-on-the-non-linear-model","text":"Are shown below some diagrams obtained by empirical tests, that are the beginning point to search an analitacally for of the non linear damping behavior: Figure 1: Empirical diagram Figure 2: Empirical diagram Figure 3: Empirical diagram","title":"Empirically evidences on the non linear model"},{"location":"fenice-dampers-DMT/Home/#non-linear-behavior-modeling","text":"","title":"Non linear behavior modeling"},{"location":"fenice-dampers-DMT/Home/#assumptions","text":"As just seen on a linear dumper diagram or on a non linear dumper diagram there are present the force and the velocity. In the linear model there is a single slope this means that there is only one coefficient that links speed to the force. Instead the non linear curve can be approximated using straight lines with different slopes. The behavior in compression and in traction are different this leads to a total of four different coefficients. So to model a non-linear damper we can use a piecewise defined function where two critical speeds one for compression and one for traction separate the slopes of the curve. Figure 4: Linear curve Figure 5: Non linear curve","title":"Assumptions"},{"location":"fenice-dampers-DMT/Home/#process","text":"For the achievement of this model/function we used the Matlab software. Initially to obtain this function we used some generic parameters. We define four functions (F1,F2,F3,F4) that repre- sent four straigth lines with different slopes modeled with four different coefficients (D1,D2,D3,D4). The four coefficients will be determined by an optimization process. We define two fixed critical velocity \\(c r 1 \\mathrm{e} c r 2\\) and to limit these functions a critical velocity \\(c r \\max\\) . The two functions F2 e F3 begin from the origin so they dont\u2019have to be traslated instead the F1 e F4 functions have to be traslated respectivly in the vertical direction of the value of the adiacent function calculated in the critical point and the horizontal direction of the respective critical velocity value. \\[ F_{\\text {nonlindamp }}(x)= \\begin{cases}D_{1}\\left(v-v_{c r 1}\\right)+D_{2} v_{c r 1} & v<v_{c r 1} \\\\ D_{2} v & v_{c r 1} \\leq v<0 \\\\ D_{3} v & 0 \\leq v<v_{c r 2} \\\\ D_{4}\\left(v-v_{c r 2}\\right)+D_{3} v_{c r 2} & v>v_{c r 2}\\end{cases} \\] Figure 6: Test function Once the model was validated, everything was inserted in a Matlab function with the if conditions in order to be able to use it in the model. Figure 7: Function for minimization","title":"Process"},{"location":"fenice-dampers-DMT/Home/#obtaining-coefficients","text":"After making the model it had to be realized a \"Quarter car\" models (see section (4)), that is a a model that represents a quarter of a vehicle, in which it has been inserted the non-linear damper model, the spring, the mass of the vehicle and in addition a model of a tire that can be represented with spring, a damper and a mass. All the values of the elastic constants, of the masses(the sprung mass for rear and front and the tire) and the damping coefficient of the tire have been obtained from tests performed on the car. As input it has been inserted a road profile that will be discussed in section (3). Thanks to the \"Quarter car\" model and a minimization process that tries to find the minimum value of the force acting on the road the four coefficients for the non-linear curve and the two critical speeds can be found.","title":"Obtaining coefficients"},{"location":"fenice-dampers-DMT/Home/#road-parameters-determination-for-simulation-purpose","text":"In the simulation we have to determine the input velocity on the damper and so the road profile, because this velocity is generated by the vertical excursion of the pneumatic that follows the road profile assuming, to determine this excursion, a constant reference that represent a plane road: so we define a road profile that considers the asphalt and road type.","title":"Road parameters determination for simulation purpose"},{"location":"fenice-dampers-DMT/Home/#classification-of-the-road-profile","text":"For the road classification we base on the ISO 8606 that uses the power spectral density (PSD): \\[ \\Phi(\\Omega) \\] where we define \\(\\Omega\\) as an angular spatial frequency; we define moreover \\(\\Omega_{0}=1 \\mathrm{rad} / \\mathrm{m}\\) as a reference function and \\(\\Phi_{0}\\) as a descriptive value of the PSD on the reference frequency. Considering these variables, when a vehicle moves along a road with a \\(v\\) velocity, the excitation frequency of the road input become \\(\\omega=\\Omega v\\) . We define moreover the \\(\\alpha\\) coefficient as a coefficient that represent the road state . The power spectral density is: \\[ \\Phi(\\Omega)=\\Phi_{0}\\left(\\frac{\\Omega}{\\Omega_{0}}\\right)^{-\\omega} \\]","title":"Classification of the road profile"},{"location":"fenice-dampers-DMT/Home/#road-profile-modeling","text":"With some tables we can obtain various coefficients to determine different power spectral density of different road types. For simulation purpose we can emulate the road profile with a filter with \\(\\alpha, \\omega, v\\) parameters, which transfer function is: \\[ H(\\omega)=\\frac{1}{\\alpha v+j \\omega} \\] Different alpha values can be obtained, for example some usefull values are: \\(\\alpha=0.15 \\mathrm{~m}^{-} 1\\) for a \\(\\mathrm{v}=10-50 \\mathrm{~m} / \\mathrm{s}\\) velocity with variance \\(9 \\mathrm{~mm}^{2}\\) for asphalted road \\(\\alpha=0.45 \\mathrm{~m}^{-} 1\\) for a \\(\\mathrm{v}=5-30 \\mathrm{~m} / \\mathrm{s}\\) velocity with variance \\(300 \\mathrm{~mm}^{2}\\) for paved road or \\(\\alpha=0.127 \\mathrm{~m}^{-} 1\\) that is a standard that derives from a white noise and we can use it indipendently from the road type.","title":"Road profile modeling"},{"location":"fenice-dampers-DMT/Home/#quarter-car-simulation-with-non-linear-damper","text":"To test the non linear damper model, as seen above, we use this simulink model: Figure 8: Simulink model","title":"Quarter Car simulation with non linear Damper"},{"location":"fenice-dampers-DMT/Home/#quarter-car-part","text":"This part of the Simulink model is the part that represents the quarter car: Figure 9: Quarter Car The \"Car\" box represents the usprung mass of the vehicle modeled as a lumped element, connected to the parallel of a \"Spring\" with the \"NLDamper\" (non linear damper); this part is connected in series with the \" Tire\" box that represents the unsprung mass of the tire, modeled as a lumped element, that is connected to another spring-damper parallel (Tire Stiffnes and Tire Damper). From this block we can monitorate various vehicle parameters as the vertical acceleration, the velocity (that is a parameter that is given to the NL Damper block for the computation of the curves) of the masses.","title":"Quarter car part"},{"location":"fenice-dampers-DMT/Home/#non-linear-damper-part","text":"Figure 10: Non linear damper In this part of the non linear damper it has been inserted the function discussed previously in section 2. The input values are the difference between the velocity of the sprung mass and the unsprung mass and the six parameters that are needed. The output of this block is the value of the function.","title":"Non linear damper part"},{"location":"fenice-dampers-DMT/Home/#road-profile-part","text":"Figure 11: Road profile This part is essentially explained in the third section and it's only implemented in a block-diagram way; only one annotation: in the \"Road\" box there is a direct connection between the input and the \"Pos\" output and the \"Vel\" output is given by the definition of velocity with the input given.","title":"Road profile part"},{"location":"fenice-dampers-DMT/Home/#results","text":"","title":"Results"},{"location":"fenice-dampers-DMT/Home/#front","text":"Figure 12: Non linear curve obtained(front) As result is has been obtained a curve with the following parameters: The critical speed in compression: \\(-0.045733 \\frac{\\mathrm{m}}{\\mathrm{s}}\\) The critical speed in traction: \\(0.043852 \\frac{\\mathrm{m}}{\\mathrm{s}}\\) Compression in high-speed: \\(569.3763 \\frac{\\mathrm{Ns}}{\\mathrm{m}}\\) Compression in low-speed: \\(921.2548 \\frac{\\mathrm{Ns}}{\\mathrm{m}}\\) Traction in low-speed: \\(2166.7664 \\frac{\\mathrm{Ns}}{\\mathrm{m}}\\) Traction in high-speed: \\(1443.0206 \\frac{N s}{m}\\)","title":"Front"},{"location":"fenice-dampers-DMT/Home/#rear","text":"Figure 13: Non linear curve obtained(rear) As result is has been obtained a curve with the following parameters: The critical speed in compression: \\(-0.048829 \\frac{\\mathrm{m}}{\\mathrm{s}}\\) The critical speed in traction: \\(0.05451 \\frac{\\mathrm{m}}{\\mathrm{s}}\\) Compression in high-speed: \\(740.4203 \\frac{\\mathrm{Ns}}{\\mathrm{m}}\\) Compression in low-speed: \\(1121.4413 \\frac{N s}{m}\\) Traction in low-speed: \\(1107.1417 \\frac{N s}{m}\\) Traction in high-speed: \\(840.9172 \\frac{\\mathrm{Ns}}{\\mathrm{m}}\\)","title":"Rear"},{"location":"fenice-dampers-DMT/Home/#revisioni","text":"03/2020 - Initial Release (Grano, Rinaldi)","title":"Revisioni"},{"location":"fenice-das-sw/","text":"Data Acquisition System The DAS codedbase in organized in modules so that every functionality can be easily located. Each module is indentifued by a three- or four-letter prefix that is prepended to every exported memeber (variable or function) so that no namespace collisions occur. Private members use this prefix as well but in turn prefixed with an underscore. The modules are the following: - Brakelight - Buzzer - CAN Bus - Encoders - Finite State Machine - Inverters - Pedals - Traction Control - Tractive System Brakelight Prefix: BKL Description: operate the three PWM channels connected to the brake light In-depth documentation: bkl.md Buzzer Prefix: BUZ Description: Activate and deactivate the buzzer, with sync or async calls In-depth documentation: buz.md CAN Prefix: CAN, CANMSG Description: In-depth documentation: Encoders Prefix: ENC Description: In-depth documentation: FSM Prefix: VFSM Description: In-depth documentation: Inverters Prefix: INV Description: In-depth documentation: Pedals Prefix: PED Description: In-depth documentation: Traction Control Prefix: CTRL Description: In-depth documentation: Tractive System Prefix: TSs Description: In-depth documentation:","title":"Introduction"},{"location":"fenice-das-sw/#data-acquisition-system","text":"The DAS codedbase in organized in modules so that every functionality can be easily located. Each module is indentifued by a three- or four-letter prefix that is prepended to every exported memeber (variable or function) so that no namespace collisions occur. Private members use this prefix as well but in turn prefixed with an underscore. The modules are the following: - Brakelight - Buzzer - CAN Bus - Encoders - Finite State Machine - Inverters - Pedals - Traction Control - Tractive System","title":"Data Acquisition System"},{"location":"fenice-das-sw/#brakelight","text":"Prefix: BKL Description: operate the three PWM channels connected to the brake light In-depth documentation: bkl.md","title":"Brakelight"},{"location":"fenice-das-sw/#buzzer","text":"Prefix: BUZ Description: Activate and deactivate the buzzer, with sync or async calls In-depth documentation: buz.md","title":"Buzzer"},{"location":"fenice-das-sw/#can","text":"Prefix: CAN, CANMSG Description: In-depth documentation:","title":"CAN"},{"location":"fenice-das-sw/#encoders","text":"Prefix: ENC Description: In-depth documentation:","title":"Encoders"},{"location":"fenice-das-sw/#fsm","text":"Prefix: VFSM Description: In-depth documentation:","title":"FSM"},{"location":"fenice-das-sw/#inverters","text":"Prefix: INV Description: In-depth documentation:","title":"Inverters"},{"location":"fenice-das-sw/#pedals","text":"Prefix: PED Description: In-depth documentation:","title":"Pedals"},{"location":"fenice-das-sw/#traction-control","text":"Prefix: CTRL Description: In-depth documentation:","title":"Traction Control"},{"location":"fenice-das-sw/#tractive-system","text":"Prefix: TSs Description: In-depth documentation:","title":"Tractive System"},{"location":"fenice-das-sw/bkl/","text":"Brakelight This module exports two functions and one enum: void BKL_light_show_step() Update, at each call, the status of a light sequence that alternates channels and PWM duty-cycles to test the brakelight void BKL_toggle(BKL_StateTypeDef state) Set the state of the brakelight to one of the options provied in the enumeration. typdef enum { ... } BKL_StateTypeDef The available states of the brakelight: BKL_OFF : Off BKL_LVL_1 : Low intensity BKL_LVL_2 : Medium intensity BKL_LVL_3 : Maximum intensity","title":"Brakelight"},{"location":"fenice-das-sw/bkl/#brakelight","text":"This module exports two functions and one enum:","title":"Brakelight"},{"location":"fenice-das-sw/bkl/#void-bkl_light_show_step","text":"Update, at each call, the status of a light sequence that alternates channels and PWM duty-cycles to test the brakelight","title":"void BKL_light_show_step()"},{"location":"fenice-das-sw/bkl/#void-bkl_togglebkl_statetypedef-state","text":"Set the state of the brakelight to one of the options provied in the enumeration.","title":"void BKL_toggle(BKL_StateTypeDef state)"},{"location":"fenice-das-sw/bkl/#typdef-enum-bkl_statetypedef","text":"The available states of the brakelight: BKL_OFF : Off BKL_LVL_1 : Low intensity BKL_LVL_2 : Medium intensity BKL_LVL_3 : Maximum intensity","title":"typdef enum { ... } BKL_StateTypeDef"},{"location":"fenice-das-sw/buz/","text":"Buzzer This module exports a transparent interface to start and stop sync and async beeps from a buzzer. void BUZ_beep_ms_sync(uint16_t ms) Activate the buzzer and return to the caller after ms milliseconds. void BUZ_beep_ms_async(uint16_t ms) Activate the buzzer and return to the caller. It will be deactivated after ms milliseconds when the function below will be called the next time. void BUZ_timer_callback() If the buzzer is active, check if the required time has passed and stop it.","title":"Buzzer"},{"location":"fenice-das-sw/buz/#buzzer","text":"This module exports a transparent interface to start and stop sync and async beeps from a buzzer.","title":"Buzzer"},{"location":"fenice-das-sw/buz/#void-buz_beep_ms_syncuint16_t-ms","text":"Activate the buzzer and return to the caller after ms milliseconds.","title":"void BUZ_beep_ms_sync(uint16_t ms)"},{"location":"fenice-das-sw/buz/#void-buz_beep_ms_asyncuint16_t-ms","text":"Activate the buzzer and return to the caller. It will be deactivated after ms milliseconds when the function below will be called the next time.","title":"void BUZ_beep_ms_async(uint16_t ms)"},{"location":"fenice-das-sw/buz/#void-buz_timer_callback","text":"If the buzzer is active, check if the required time has passed and stop it.","title":"void BUZ_timer_callback()"},{"location":"fenice-ecu/","text":"Electronic Control Unit Fenice's ECU controls the global state of the vehicle and manages its transitions between states. For example, when the driver requests the car to enter the RUN state, the ECU will execute all needed operations and will prepare the vehicle to meet all needed constraints in order to safely move. Although its main task is rather simple, this component is actually composed of many modules. The first reason is that this apparently small state machine conceals quite a lot of abstraction, therefore needing a certain quantity of code in order to reach down to the low level of a micro-controller interface. The second reason follows from the first, meaning that all this code, in order to remain maintainable and reliable in time, needs a proper level of modularization and separation.","title":"Introduction"},{"location":"fenice-ecu/#electronic-control-unit","text":"Fenice's ECU controls the global state of the vehicle and manages its transitions between states. For example, when the driver requests the car to enter the RUN state, the ECU will execute all needed operations and will prepare the vehicle to meet all needed constraints in order to safely move. Although its main task is rather simple, this component is actually composed of many modules. The first reason is that this apparently small state machine conceals quite a lot of abstraction, therefore needing a certain quantity of code in order to reach down to the low level of a micro-controller interface. The second reason follows from the first, meaning that all this code, in order to remain maintainable and reliable in time, needs a proper level of modularization and separation.","title":"Electronic Control Unit"},{"location":"fenice-ecu/can/","text":"CAN CubeMX Connectivity CAN: Activated Bit timing parameters (http://www.bittiming.can-wiki.info/) Prescaler TQ1 TQ2 NVIC: impisa tuto Generate Code Activate Notifications Register Callbacks Activate Filters HAL_CAN_Start // Add MCP oscilloscope debugging","title":"Can"},{"location":"fenice-ecu/can/#can","text":"","title":"CAN"},{"location":"fenice-ecu/can/#cubemx","text":"Connectivity CAN: Activated Bit timing parameters (http://www.bittiming.can-wiki.info/) Prescaler TQ1 TQ2 NVIC: impisa tuto Generate","title":"CubeMX"},{"location":"fenice-ecu/can/#code","text":"Activate Notifications Register Callbacks Activate Filters HAL_CAN_Start // Add MCP oscilloscope debugging","title":"Code"},{"location":"fenice-ecu/fsm/","text":"Finite State Machine Warning This document is no way definitive or contains reliable information States: Init The microcontroller is initializing its state and peripherals. Idle The ECU is ready to operate and receive inputs. Upon a TS_ON request, enter the precharge state. Precharge Send the BMS-HV a TS_ON message and wait for its precharge to complete, then enter the inv_updates_activation state. Inv. Updates Activation Ask the inverters to start reporting the contents of their status registers every 100ms. When the request is fulfilled, enter the inv_drive_activation state. Inv. Drive Activation Enable the inverters (Drive Mode) and upon confirmation enter the run state. Run Read pedal values from the PCU and forward them to the Control Unit and/or the inverters. Upon a TS_OFF request, enter the inv_drive_deactivation state. Inv. Drive Deactivation Disable the inverters and upon confirmation enter the inv_updates_deactivation state. Inv. Updates Deactivation Stop the inverters status reports and enter the discharge state. Discharge Send the BMS-HV a TS_OFF request and, upon fulfillment, enter the idle state.","title":"Finite State Machine"},{"location":"fenice-ecu/fsm/#finite-state-machine","text":"Warning This document is no way definitive or contains reliable information","title":"Finite State Machine"},{"location":"fenice-ecu/fsm/#states","text":"","title":"States:"},{"location":"fenice-ecu/fsm/#init","text":"The microcontroller is initializing its state and peripherals.","title":"Init"},{"location":"fenice-ecu/fsm/#idle","text":"The ECU is ready to operate and receive inputs. Upon a TS_ON request, enter the precharge state.","title":"Idle"},{"location":"fenice-ecu/fsm/#precharge","text":"Send the BMS-HV a TS_ON message and wait for its precharge to complete, then enter the inv_updates_activation state.","title":"Precharge"},{"location":"fenice-ecu/fsm/#inv-updates-activation","text":"Ask the inverters to start reporting the contents of their status registers every 100ms. When the request is fulfilled, enter the inv_drive_activation state.","title":"Inv. Updates Activation"},{"location":"fenice-ecu/fsm/#inv-drive-activation","text":"Enable the inverters (Drive Mode) and upon confirmation enter the run state.","title":"Inv. Drive Activation"},{"location":"fenice-ecu/fsm/#run","text":"Read pedal values from the PCU and forward them to the Control Unit and/or the inverters. Upon a TS_OFF request, enter the inv_drive_deactivation state.","title":"Run"},{"location":"fenice-ecu/fsm/#inv-drive-deactivation","text":"Disable the inverters and upon confirmation enter the inv_updates_deactivation state.","title":"Inv. Drive Deactivation"},{"location":"fenice-ecu/fsm/#inv-updates-deactivation","text":"Stop the inverters status reports and enter the discharge state.","title":"Inv. Updates Deactivation"},{"location":"fenice-ecu/fsm/#discharge","text":"Send the BMS-HV a TS_OFF request and, upon fulfillment, enter the idle state.","title":"Discharge"},{"location":"fenice-ecu/modules/","text":"Modules UART Four devices make use of serial communication: a textual UART for debugging messages, two wheel encoders, and one steering encoder. Among these, however, only the debugging UART is directly interfaced with the STM serial controller: Interface TX Pin RX Pin Baud Rate Description UART4 PA12 PA13 115200 Debugging messages The serial signal from the wheel encoders instead, is decoded by transceivers on the DAS board that, in turn, feed two timer channels each that operate in Encoder Mode . Further details on the interfacing with timers are given in the Timer section , while information on their decoding is available in the Encoders section . Device Protocol Wheel Encoders ( LM13ICD40AB10F00 ) RS422 Steer Encoder ( RM44SC0012B10F2F10 ) RS422 Timers List of STM timers employed: Timer Mode Pins Description TIM2 Combined Channels: Encoder Mode PA15 (CH1), PB3 (CH2) Left wheel encoder TIM5 Combined Channels: Encoder Mode PA0 (CH1), PA1 (CH2) Right wheel encoder TIM10 Channel1: PWM Generation CH1 PB8 Buzzer PWM output Buzzer As required by the rulebook, the ECU must beep a buzzer for at least (?) ... The buzzer is driven by a MOSFET operated via the PWM output generated by the TIM10 timer on pin PB8, and powered by the 12V line. CAN Fenice's internal networks operate on two CAN buses. Networks Network Interface CAN_TX Pin CAN_RX Pin Primary CAN1 PD1 PD0 Secondary CAN3 PB4 PA8 Bit Timing Parameters APB1 Peripheral Clock (PCLK1): 54 MHz Prescaler: 3 Time Quantum is therefore 55.555 ns Time Quanta in Bit Segment 1: 12 Time Quanta in Bit Segment 2: 5 Time for one bit is therefore 999.99 ns Baud rate is therefore 1000000 bps ( 1 Mbit/s ) ReSynchronization Jump Width: 1 Messages For the list and definition of all CAN messages please refer to the can-cicd documentation . SPI The SPI interface is used to communicate with the Traction Control Unit and exchange information on vehicle state and motor torque. Since the TCU runs on a Raspberry Pi which is, by design, only capable of operating as a Master node, the ECU acts as the Slave node. Interface CLK Pin ... ... For more information on how and what information is exchanged, please refer to the Traction Control section below. IMU This module records the acceleration data coming from the Inertial Measurement Unit (IMU) sensor over the CAN network. Namely, it receives: - Linear acceleration on the three directions - Gyroscopic acceleration on the three axes Sensor Configuration In order to work properly, the sensor needs to be configured with the following parameters: - Sampling frequency: ? - ... IRTS Four Infra-Red Temperature Sensors (IRTSs) are pointed toward the tires and measure their temperature gradient using 8 (?) channels each (...) Inverters The Inverters and the ECU communicate over the CAN network and exchange the following information: - The ECU periodically (at which freq. ?) sends two torque values to be applied to the motors, one for the left side and one for the right side - The inverters periodically (every 100ms) report the contents of their status register (more details below) - The inverters periodically (every 100ms) report the output voltage at which they are driving the motors Status Register Contents Bit Symbol Description 0 Ena Drive Enable 1 RcR0 Speed limit to zero 2 Lim+ Limited switch + tripped 3 Lim- Limited switch - tripped 4 OK Drive okay 5 Icns Current is limited to the continuous current level 6 T-Nlim Speed limit torque mode active 7 P-N Position control active 8 N-I Speed control active 9 <N0 Actual speed is less than 0.1% 10 Rsw Reference switch tripped 11 Cal0 Calibration move active 12 Cal Calibration move completed 13 Tol Position within tolerance window 14 Rdy Drive ready (BTB/RDY contact closed) 15 Brk0 Unexcited brake with motor active 16 SignMag Speed internally inverted 17 Nclip Speed limiting enabled (N-Lim < 90%) 18 Nclip+ Speed limiting (+) via input switch enabled 19 Ncip- Speed limiting (-) via input switch enabled 20 Ird-Dig Current limiting via input switch enabled 21 Iuse-rchd Actual current limit reached 22 Ird-N Current derating to cont. current via speed limit enabled 23 Ird-TI Current derating to cont. current due to igbt temp. enabled 24 Ird-TIR Current derating to cont. current due to igbt temp. active 25 >10Hz Current derating to cont. current at rotation freq. < 10 Hz active 26 Ird-TM Current derating to cont. current due to motor temp. active 27 Ird-Ana Current derating due to analog input (if <= 90%) possible 28 Iwcns Current peak value warning 29 RFEpulse Pulsed RFE - input monitoring active 30 M+d vacant 31 HndWhl Hand-wheel function selected Current-Torque Curve and Power Limiting Note Controlling the inverters by torque or current is equivalent Since, for a given current, power absorption of the motors is proportional to their rotational speed, and given that inverters are controlled in torque/current mode, care must be taken not to request more than the allowed limit of 80 KWh. More details on the matter are available in this report: Essentially, requesting the maximum available current of 200A per motor when the angular velocity is above 4000 RPM causes the power to exceed the allowed limit. To overcome this issue, the following equation must then be followed to obtain the correct torque limit at each rotational speed: \\[ C_{mot\\_max} = \\begin{cases} C_{max} & \\text{if } \\omega_{mot} < \\omega_{limit} \\\\ \\frac{358098.6}{\\omega_{mot}} & \\text{if } \\omega_{mot} \\geq \\omega_{limit} \\end{cases} \\] At this point, the current value must be converted into a 16-bits integer to be sent to the inverters, which is a percent value of the characteristic maximum current of the device, equal to 423A (e.g., 50% = +32768 = 212.5A). Consequently, the maximum current of 200A (corresponding to the 47.3% of the maximum peak) will be represented as 15493. Some clarifying examples follow: Current Percent int16 -423 A -100% -32768 0 A 0% 0 200 A +47.2% +15493 423 A +100% +32768 PCU This module controls all communication (via CAN-Bus) between the ECU and the Pedal Control Unit (PCU). More specifically: - ADC brake and accelerator values are read and scaled from 0 to 100 - Errors and Warnings are checked (e.g. implausibility) - Calibration values are read/written from/to the EEPROM and sent/received Tractive System The TC code handles the generation and delivery of messages concerning the status of the BMS-HV (PRECHARGE, TS-ON, TS-OFF, ...). Traction Control Since the actual software for controlling the traction of the vehicle runs on a separate device (for reliability purposes), the ECU and the Traction Control Unit (TCU) need to constantly exchange a number of values. Parameter Name Direction Description Brake ECU -> TCU How much the brake pedal is pressed ... Further technical details on how this data is exchanged over SPI can be found at the TCU Protocol page. Encoders Magnetic rotative encoders are used to read angular speed from wheels and absolute position from steering. Wheels Wheel encoders are composed of a magnetic ring and a read head. Following, is the data-sheet of the read head where its characteristics are described: Decoding the part number ( LM13ICD40AB10F00 ) and referencing the various tables gives the following key points: Most importantly, we must note that at maximum measurable speed (18.67 m/s, on the ring), each timer will be fed with two 8 MHz signals, leading to 4 million increments/decrements per second. TIM2 and TIM5 have been chosen specifically for their 32-bits counter registers (in contrast with other timers' 16-bits counters) so that they can receive up to 4'294'967'296 pulses before overflowing (instead of 65536 for 16 bits). Consequently, while 16 bit timers would need to be read and reset at most every 16 milliseconds, TIM2 and TIM5 could allow for correct counting for over 17 minutes. Nonetheless, for efficient decoding and to avoid periodic overflows, timer counters should be reset to 0 after every read, which as said, is now free to happen at lower frequencies than every 16 milliseconds, if needed. For information on timer configuration on the STM, see the Timers section . Steering ...","title":"Modules"},{"location":"fenice-ecu/modules/#modules","text":"","title":"Modules"},{"location":"fenice-ecu/modules/#uart","text":"Four devices make use of serial communication: a textual UART for debugging messages, two wheel encoders, and one steering encoder. Among these, however, only the debugging UART is directly interfaced with the STM serial controller: Interface TX Pin RX Pin Baud Rate Description UART4 PA12 PA13 115200 Debugging messages The serial signal from the wheel encoders instead, is decoded by transceivers on the DAS board that, in turn, feed two timer channels each that operate in Encoder Mode . Further details on the interfacing with timers are given in the Timer section , while information on their decoding is available in the Encoders section . Device Protocol Wheel Encoders ( LM13ICD40AB10F00 ) RS422 Steer Encoder ( RM44SC0012B10F2F10 ) RS422","title":"UART"},{"location":"fenice-ecu/modules/#timers","text":"List of STM timers employed: Timer Mode Pins Description TIM2 Combined Channels: Encoder Mode PA15 (CH1), PB3 (CH2) Left wheel encoder TIM5 Combined Channels: Encoder Mode PA0 (CH1), PA1 (CH2) Right wheel encoder TIM10 Channel1: PWM Generation CH1 PB8 Buzzer PWM output","title":"Timers"},{"location":"fenice-ecu/modules/#buzzer","text":"As required by the rulebook, the ECU must beep a buzzer for at least (?) ... The buzzer is driven by a MOSFET operated via the PWM output generated by the TIM10 timer on pin PB8, and powered by the 12V line.","title":"Buzzer"},{"location":"fenice-ecu/modules/#can","text":"Fenice's internal networks operate on two CAN buses.","title":"CAN"},{"location":"fenice-ecu/modules/#networks","text":"Network Interface CAN_TX Pin CAN_RX Pin Primary CAN1 PD1 PD0 Secondary CAN3 PB4 PA8","title":"Networks"},{"location":"fenice-ecu/modules/#bit-timing-parameters","text":"APB1 Peripheral Clock (PCLK1): 54 MHz Prescaler: 3 Time Quantum is therefore 55.555 ns Time Quanta in Bit Segment 1: 12 Time Quanta in Bit Segment 2: 5 Time for one bit is therefore 999.99 ns Baud rate is therefore 1000000 bps ( 1 Mbit/s ) ReSynchronization Jump Width: 1","title":"Bit Timing Parameters"},{"location":"fenice-ecu/modules/#messages","text":"For the list and definition of all CAN messages please refer to the can-cicd documentation .","title":"Messages"},{"location":"fenice-ecu/modules/#spi","text":"The SPI interface is used to communicate with the Traction Control Unit and exchange information on vehicle state and motor torque. Since the TCU runs on a Raspberry Pi which is, by design, only capable of operating as a Master node, the ECU acts as the Slave node. Interface CLK Pin ... ... For more information on how and what information is exchanged, please refer to the Traction Control section below.","title":"SPI"},{"location":"fenice-ecu/modules/#imu","text":"This module records the acceleration data coming from the Inertial Measurement Unit (IMU) sensor over the CAN network. Namely, it receives: - Linear acceleration on the three directions - Gyroscopic acceleration on the three axes","title":"IMU"},{"location":"fenice-ecu/modules/#sensor-configuration","text":"In order to work properly, the sensor needs to be configured with the following parameters: - Sampling frequency: ? - ...","title":"Sensor Configuration"},{"location":"fenice-ecu/modules/#irts","text":"Four Infra-Red Temperature Sensors (IRTSs) are pointed toward the tires and measure their temperature gradient using 8 (?) channels each (...)","title":"IRTS"},{"location":"fenice-ecu/modules/#inverters","text":"The Inverters and the ECU communicate over the CAN network and exchange the following information: - The ECU periodically (at which freq. ?) sends two torque values to be applied to the motors, one for the left side and one for the right side - The inverters periodically (every 100ms) report the contents of their status register (more details below) - The inverters periodically (every 100ms) report the output voltage at which they are driving the motors","title":"Inverters"},{"location":"fenice-ecu/modules/#status-register-contents","text":"Bit Symbol Description 0 Ena Drive Enable 1 RcR0 Speed limit to zero 2 Lim+ Limited switch + tripped 3 Lim- Limited switch - tripped 4 OK Drive okay 5 Icns Current is limited to the continuous current level 6 T-Nlim Speed limit torque mode active 7 P-N Position control active 8 N-I Speed control active 9 <N0 Actual speed is less than 0.1% 10 Rsw Reference switch tripped 11 Cal0 Calibration move active 12 Cal Calibration move completed 13 Tol Position within tolerance window 14 Rdy Drive ready (BTB/RDY contact closed) 15 Brk0 Unexcited brake with motor active 16 SignMag Speed internally inverted 17 Nclip Speed limiting enabled (N-Lim < 90%) 18 Nclip+ Speed limiting (+) via input switch enabled 19 Ncip- Speed limiting (-) via input switch enabled 20 Ird-Dig Current limiting via input switch enabled 21 Iuse-rchd Actual current limit reached 22 Ird-N Current derating to cont. current via speed limit enabled 23 Ird-TI Current derating to cont. current due to igbt temp. enabled 24 Ird-TIR Current derating to cont. current due to igbt temp. active 25 >10Hz Current derating to cont. current at rotation freq. < 10 Hz active 26 Ird-TM Current derating to cont. current due to motor temp. active 27 Ird-Ana Current derating due to analog input (if <= 90%) possible 28 Iwcns Current peak value warning 29 RFEpulse Pulsed RFE - input monitoring active 30 M+d vacant 31 HndWhl Hand-wheel function selected","title":"Status Register Contents"},{"location":"fenice-ecu/modules/#current-torque-curve-and-power-limiting","text":"Note Controlling the inverters by torque or current is equivalent Since, for a given current, power absorption of the motors is proportional to their rotational speed, and given that inverters are controlled in torque/current mode, care must be taken not to request more than the allowed limit of 80 KWh. More details on the matter are available in this report: Essentially, requesting the maximum available current of 200A per motor when the angular velocity is above 4000 RPM causes the power to exceed the allowed limit. To overcome this issue, the following equation must then be followed to obtain the correct torque limit at each rotational speed: \\[ C_{mot\\_max} = \\begin{cases} C_{max} & \\text{if } \\omega_{mot} < \\omega_{limit} \\\\ \\frac{358098.6}{\\omega_{mot}} & \\text{if } \\omega_{mot} \\geq \\omega_{limit} \\end{cases} \\] At this point, the current value must be converted into a 16-bits integer to be sent to the inverters, which is a percent value of the characteristic maximum current of the device, equal to 423A (e.g., 50% = +32768 = 212.5A). Consequently, the maximum current of 200A (corresponding to the 47.3% of the maximum peak) will be represented as 15493. Some clarifying examples follow: Current Percent int16 -423 A -100% -32768 0 A 0% 0 200 A +47.2% +15493 423 A +100% +32768","title":"Current-Torque Curve and Power Limiting"},{"location":"fenice-ecu/modules/#pcu","text":"This module controls all communication (via CAN-Bus) between the ECU and the Pedal Control Unit (PCU). More specifically: - ADC brake and accelerator values are read and scaled from 0 to 100 - Errors and Warnings are checked (e.g. implausibility) - Calibration values are read/written from/to the EEPROM and sent/received","title":"PCU"},{"location":"fenice-ecu/modules/#tractive-system","text":"The TC code handles the generation and delivery of messages concerning the status of the BMS-HV (PRECHARGE, TS-ON, TS-OFF, ...).","title":"Tractive System"},{"location":"fenice-ecu/modules/#traction-control","text":"Since the actual software for controlling the traction of the vehicle runs on a separate device (for reliability purposes), the ECU and the Traction Control Unit (TCU) need to constantly exchange a number of values. Parameter Name Direction Description Brake ECU -> TCU How much the brake pedal is pressed ... Further technical details on how this data is exchanged over SPI can be found at the TCU Protocol page.","title":"Traction Control"},{"location":"fenice-ecu/modules/#encoders","text":"Magnetic rotative encoders are used to read angular speed from wheels and absolute position from steering.","title":"Encoders"},{"location":"fenice-ecu/modules/#wheels","text":"Wheel encoders are composed of a magnetic ring and a read head. Following, is the data-sheet of the read head where its characteristics are described: Decoding the part number ( LM13ICD40AB10F00 ) and referencing the various tables gives the following key points: Most importantly, we must note that at maximum measurable speed (18.67 m/s, on the ring), each timer will be fed with two 8 MHz signals, leading to 4 million increments/decrements per second. TIM2 and TIM5 have been chosen specifically for their 32-bits counter registers (in contrast with other timers' 16-bits counters) so that they can receive up to 4'294'967'296 pulses before overflowing (instead of 65536 for 16 bits). Consequently, while 16 bit timers would need to be read and reset at most every 16 milliseconds, TIM2 and TIM5 could allow for correct counting for over 17 minutes. Nonetheless, for efficient decoding and to avoid periodic overflows, timer counters should be reset to 0 after every read, which as said, is now free to happen at lower frequencies than every 16 milliseconds, if needed. For information on timer configuration on the STM, see the Timers section .","title":"Wheels"},{"location":"fenice-ecu/modules/#steering","text":"...","title":"Steering"},{"location":"fenice-steering-system-DMT/Home/","text":"Fenice Steering System Abstract The aim of this paper would be on the design of steering system for a formula SAE vehicle. The design would consist of determining steering geometry optimizing the design to have the best efficiency. Obtained all the parameters is possible to evaluate the effort required by the pilot to steer, given the geometry of the steering system. The steering box adopted is of the type pinion-rack, which results more precise and direct compared to other systems. In this regard is dimensioned of these two elements for the construction of the steering box. For the analysis is used Wolfram Mathematica for finding all the parameters, while Maple is utilized for the dynamic analysis and so how the forces act on the steering system. Introduction The steering system needs to be such that the car can cover all turns on the track and also give accurate steering feel to the driver. The steering effort required by the driver should not be too much that it makes it uncomfortable and at the same time maintains enough steering feel. As soon as the front wheels steer, the characteristics of the steering system determine if them remain parallel to each other or the internal wheel steers less or more than the external one. This steering system has been projected using the Ackermann objective function. In the figure below are represented the three systems shortly cited before. The typical steering system, in a road or race car, has tie-rod linkages and steering arms that form an approximate parallelogram, which skews to one side as the wheels turn. If the steering arms are parallel, then both wheels are steered to the same angle. If the steering arms are angled, this is known as Ackerman geometry. The inside wheel is steered to a greater angle then the outside wheel, allowing the inside wheel to steer a tighter radius. The steering arm angles as drawn show \\(100 \\%\\) Ackerman. Different designs may use more or less percentage pro-Ackerman, anti-Ackerman, or Ackerman may be adjustable. Full Ackerman geometry requires steering angles, inner wheel and outer wheel. The angles are a function of turn centre radius, wheel base and track, but this fact is discussed in the second part. Ackermann geometry is commonly adopted in every application that has low lateral acceleration. Normally for vehicles that race in Formula SAE competitions, tracks used for ski-pad and autocross have features for which velocity in curve is so low, because its radius is so little. For this reasons Ackerman geometry has been chosen for Fenice. In Formula 1 cars are reached strong lateral acceleration, the situation is totally different: in these conditions wheels are characterised by significative slip angles. Moreover the load applied on the external wheel is pretty higher compared to the load on internal one. In the figure on the left side is clear that with low loads the vehicle needs slip angles lower to reach the peak of the maximum lateral load resistible for the wheels. With Ackermann geometry the internal wheel is forced to assume an higher slip angle to reach the maximum lateral force. This means a drag of the internal wheel, determining a growth of the temperature and a slowdown of the vehicle. Tyre drag is a force in the opposite direction of vehicle movement analogous to aerodynamic drag but created due to the tire. Higher the slip angle at which the car operates more the drag produced by the tire. This tire drag has a huge effect on cornering of a vehicle. Consequently for race cars is normally used a parallel steering system or even an antiAckerman geometry. Static Analysis Definition of the objective function Keeping in mind that the goal is that of creating a steering system which describes, as faithfully as possible the Ackermann's steer, the scheme shown on image number 3 allows to relate the geometrical parameters for the definition of the loss function, which is the one that describes a \\(100 \\%\\) Ackermann's steer. Image number 3 takes into consideration a steering system which is symmetrical to the longitudinal line of the car; moreover the deemed half is schematized as a quadrilateral: as will be seen later, this scheme will be brought back to one which presents a steering box with rack-pinion rather than a hinge. Parameter \" \\(w\\) \" indicates the \"wheelbase\", which, in the displayed case, is equivalent to \\(1540 \\mathrm{~mm}\\) ; Parameter \" \\(\\mathrm{t}\\) \" shows the \"track\", which is the carriageway, which, is the shown case, is equivalent to 1270mm; \\(\\mathrm{R}\\) is the radius of the curve carried out by the car; \\(\\delta\\) angle is the steering angle carried out in the case in which the steering wheel is directly connected to the central hinge, operating therefore directly on the steering arms (in this case too, it will later on displayed how to take in count the gear ratio brought by the rack); \\(\\delta s\\) is the angle which describes the internal wheel compared to the longitudinal direction; CIR stands for \"center of instant rotation\", as previously mentioned, if the steering is similar to the Ackermann's one, then all four wheels will rotate (on the plan ?) following a common rotation centre. At this point we can describe: \\[ \\begin{gathered} \\tan \\delta=\\frac{w}{R} \\\\ \\tan \\delta_{s}=\\frac{w}{R-\\frac{t}{2}}=\\frac{w / R}{1-\\frac{t}{2 R}}=\\frac{\\tan \\delta}{1-\\frac{t}{2 R}} \\\\ \\delta_{s}=\\tan ^{-1}\\left(\\frac{\\tan \\delta}{1-\\frac{t}{2 w} \\tan \\delta}\\right) \\end{gathered} \\] 3.3 Allows to calculate the angle that the wheel must have based on the steering angle, in order to respect the Ackermann's steer. Such angle is, therefore, the loss function, which one tries to obtain by properly selecting the steering arms length. It is so possible to describe the \\(\\mathrm{yd}(\\delta)\\) function as: \\[ y d(\\delta)=\\tan ^{-1}\\left(\\frac{\\tan \\delta}{1-\\frac{t}{2 w} \\tan \\delta}\\right) \\] Definition of geometry In the following considerations it'll be only displayed the movement of the anterior right wheel, since what happens on the left wheel is symmetrical. The steering system is, therefore, schematized as a quadrilateral with the only difference that the central hinge in image 3 is substituted with a prismatic joint, which only allows the traversing along the transversal direction. Taking into account that a steering box with a rack is being used, the general steering geometry is represented on image 5: It is important to highlight that the segment CD doesn't represent a physical arm which will be part of the steering system, but an ideal line which connects the attachment point of the arm \\(B C\\) to the hub bracket with the real rotation center of the wheel (point D which remains fixed during the wheel movement); it basically has the simple function of \"graphically\" complete the quadrilateral with which it is possible to describe any steering system. Instead \\(s\\) is the distance from the centre of the rack and the origin of the main reference frame. It is collocated where the pinion is attached to the steering box. The optimization parameters will be: \\(\\mathrm{BC}\\) length (which we will call \\(\\mathrm{L} 2\\) ), \\(\\mathrm{CD}\\) length (which we will call \\(\\mathrm{L} 3\\) ) and \\(\\alpha\\) angle, which is the angle between the wheel longitudinal direction and the CD segment: such angle stays constant during the wheel rotation. To define the geometry of this mechanism in an analogous way as the one shown on image 5 , the following procedure was used, written in Mathematica: All the names given to the parameters match with the ones written in the image 5 ; a little clarification must be given concerning \" \\(c\\) \" parameter and \" \\(\\beta\\) \" angle. The figure below shows a triangle which was obtained inside the quadrilateral. By applying the cosine theorem to such triangle it is possible to find: \\[ \\cos \\beta=\\frac{L_{2}^{2}+L_{5}^{2}-L_{3}^{2}}{2 L_{2} L_{5}} \\] From here it is possible to obtain angle \\(\\beta\\) as shown in the procedure. Finally, the parameter \"modo\" allows to select how to assemble the mechanism: in one case BC and CD sides are going to be over the artificial side \\(L 5\\) , while the opposite happens in the second case. Optimization procedure At this point it is possible to proceed with the actual optimization in order to find the parameters mentioned above. The following procedure was used: The first thing to clarify is that the \"Steer\" function allows to transform the steering wheel rotation (expressed by the \\(p 1, \\gamma 2=-115,115\\) angles) in the rack \" \\(q\\) \" linear shift. In partcular calculating the circular crown of the pinion equal to \\(\\frac{2*\\pi*r}{360}\\) , where r is radius of the pinion = 17 mm. In order to do so, a c-factor was set (which corresponds to the millimeters of displacement of tha rack for every full rotation of the pinion) which is equal to: cfactor \\(=108 \\mathrm{~mm}\\) . It was decided to limit the steering wheel rotation range between \\(-115^{\\circ}\\) and \\(+115^{\\circ}\\) since the pilot, which sits inside the narrow cockpit of the single-seater car, would have many difficulties in turning the steering wheel at higher angles. To connect the \\(\\delta\\) steering angle (which is the one that you would have in the case in which the steering wheel was directly connected to the central hung in image 3), initially defined as the shift of the \\(q\\) rack, it is possible to consider the scheme shown in the image 7 : The length L1 corresponds to the size of the rack when the wheels are straight; in this case it was chosen L1 \\(=225 \\mathrm{~mm}\\) . It is therefore possible to notice that the \\(\\delta\\) angle can be calculated as: \\[ \\delta=\\tan ^{-1} \\frac{q}{s} \\] It is necessary to specify that the optimization was carried out on a set of \"s\" values: the values taken into consideration are: \\(30,40,50,60,70,80 \\mathrm{~mm}\\) . As it will be shown, in the final version \\(\\mathrm{s}=70 \\mathrm{~mm}\\) . The two parameters \"offsetx\" and \"offsety\" allow to indicate the effective point around which the tyre turns, keeping in count the influence the caster and kingpin angles. In this case we have: offsetx \\(=-77.67 \\mathrm{~mm}\\) , offsety \\(=16.78 \\mathrm{~m}\\) . The tyre center of rotation is, therefore, moved to the center and towards the front of the car compared to the \"physical\" center of the wheel. It will be now described the goal of the various functions which are part of the optimization procedure: the \" \\(y\\) \" function calculates the first output of the \"Quadrilateral\" procedure, that is the \\(\\theta 3\\) angle, to which the \\(90^{\\circ}+\\alpha\\) is subtracted. The coordinate X of the point A is fixed corresponding to the origin, while the y is a set of values that is going to be optimized. In agreement with Image 5 , it is possible to affirm that the \" \\(\\mathrm{y}\\) \" function calculates the effective angle on which the right tyre turns (so it represents the output of the steering system); the \"yd\" function, as previously said, is the desired function, namely the ideal output that the steering system should have if it perfectly respected the Ackermann's geometry; the \"f\" function calculates a series of values which describe the linear moving of the rack between the maximum value (q1) and the minimum one (q2). After that it calculates the mistake which one has for each of these values, which is the absolute value of the subtraction between the real steering angle (given by the \" \\(\\mathrm{y}\\) \" function) and the idea steering angle (given by the \" \\(\\mathrm{yd}\\) \" function). Worth mentioning that, thanks to the absolute value, during the optimization the singular configurations will be automatically excluded, which, since they're complex numbers, give a major contribution to the module; the \"yforce\" function calculates the cosine of the subtraction between the \\(\\theta 3\\) angle and the \\(\\theta 2\\) angle, obtaining, this way the cosine of the angle between \\(\\mathrm{BC}\\) and \\(\\mathrm{CD}\\) arms; the \"fforce\" function, as the \"f\" function calculates a series of values included between \\(q 1\\) and \\(q 2\\) , after that it determines the maximum of the \"yforce\" function module, assessed in each of these points; finally, \"NMinimize\" allows to carry out the real optimization, using as optimization parameters the one previously listed (which are highlighted in blue). By minimizing both the \" \\(f\\) \" and \"fforce\" function we have two effects: on one side you minimize the mistake calculated in the first function, on the other one you minimize the the cosine of the angle between the two \\(B C\\) and \\(C D\\) arms; this means that, following the optimization, such angle will tend to be as close as possible to \\(90^{\\circ}\\) (where the cosine is to the minimum). This was made because, by maintaining such angle close to \\(90^{\\circ}\\) it is possibile to maximize the transfer of forces between arm and wheel, reducing, then, the necessary effort to steer. It is possible to notice that the \"fforce\" function gets multiplied for a number: it allows such function to augment or diminish the importance of such function inside the optimization; this is made to avoid reaching a top high mistake in order to minimize the \"fforce\" function; Results analysis The result of the optimization is shown on table: s [mm] Error [deg] L2 [mm] L3 [mm] \u03b1 [deg] 30 23.79 214.4 136.9 72.37 40 16.89 224.4 133.6 64.53 50 3.46 348.1 59.3 -13.33 60 2.83 352.7 69.3 -15.55 70 2.44 334.7 74.4 0.043 It is possible to notice that for the fist values of \" \\(\\mathrm{s}\\) \" the mistakes is very high, therefore such solutions are not achievable. In the end it was decided to use the configuration with \\(\\mathrm{s}=70 \\mathrm{~mm}\\) : it is not the one that allows to have the minimum mistake, but it is the one which best represents the compromise in order to deny the risk of the two arms touching the internal wall of the wheel rim while steering. The final result, using the parameters related to \\(s=70 \\mathrm{~mm}\\) , is shown on Image 8 : This configuration, as shown on Table 1, presents an average mistake of circa \\(2.44^{\\circ}\\) . Image 9 shows, though, the effective variance between the ideal function and the one carried out by the right wheel of the steering system, for the steering wheel dangles comprehended between \\(-115^{\\circ}\\) and \\(115^{\\circ}\\) . In the previous graphic a clockwise rotation was taken in consideration as negative, that is when the right wheel results in being internal to the curve. It is possible to notice that the mistake grows as we move away from the configuration with straight wheels; however in the range in which we operate the most, the mistake is contained. It must be said that, by reducing the influence of the \"fforce\" function (so by diminishing the multiplier which precedes it) it would have been possible to obtain an even lower mistake. However in this way, point \" \\(\\mathrm{C}^{\\text {\" }}\\) would have resulted in being way more moved toward right and this wouldn't have been acceptable since such point (in which we have a spherical joint) would have crashed into the brake discs. The steering system was built in order to allow the car to cover a curve (quite narrow) with a \\(3 \\mathrm{~mm}\\) ray, considering that competitions take place on tracks which are characterized by very narrows curves. By using the \\(3.1\\) it is possible to calculate the \\(\\delta\\) angle, which is necessary to accomplish such curve where w is equal to \\(1540 \\mathrm{~mm}\\) and \\(\\mathrm{R}\\) equal to \\(3000 \\mathrm{~mm}\\) (it is to remember that \\(\\delta\\) angle represents the steering angle as if the steer operated directly in the arms). By passing such angle at the entrance of the \"yd\" function we obtain \\(y d=-32.17^{\\circ}\\) (it is to remember that the minus sign indicates a clockwise rotation). Ideally, therefore, to obtain a minimal \\(3 \\mathrm{~m}\\) steering ray it is necessary that the for the wheel too, to turn of such quantity. With a \\(108 \\mathrm{~mm}\\) c-factor as the one used when there's a maximal steer, that is \\(115^{\\circ}\\) , the rack swifts for \\(34.62\\) \\(\\mathrm{mm}\\) ; using \\(4.1\\) we obtain \\(\\delta=26.32^{\\circ}\\) to which corresponds; \\(y d=-31.01^{\\circ}\\) . The chosen c-factor allows therefore to get very close to the ideal steering angle which would be necessary to perform a \\(3 \\mathrm{~m}\\) ray curve; it was decided to not further increase the c-factor to deny the steering wheel being too direct, resulting in it being too difficult to control and ever heavier to maneuver. In the end the real maximal rotation angle which describes the \\(i\\) thermal wheel compared to the curve is circa \\(-29.66^{\\circ}\\) . It is possible to calculate that this value makes it possible for the car to cover a curve with a maximal ray of \\(3.256 \\mathrm{~m}\\) . This value differ a little bit from the one that was chosen as the goal, however it is still acceptable. In this table are shown the optimized dimensions of the steering system: L1 [mm] L2 [mm] L3 [mm] s [mm] \u03b1 [deg] 225 334.7 74.4 70 0.043 Revision History V1.0: Initial release (Andrea Colavero)","title":"Fenice Steering System"},{"location":"fenice-steering-system-DMT/Home/#fenice-steering-system","text":"","title":"Fenice Steering System"},{"location":"fenice-steering-system-DMT/Home/#abstract","text":"The aim of this paper would be on the design of steering system for a formula SAE vehicle. The design would consist of determining steering geometry optimizing the design to have the best efficiency. Obtained all the parameters is possible to evaluate the effort required by the pilot to steer, given the geometry of the steering system. The steering box adopted is of the type pinion-rack, which results more precise and direct compared to other systems. In this regard is dimensioned of these two elements for the construction of the steering box. For the analysis is used Wolfram Mathematica for finding all the parameters, while Maple is utilized for the dynamic analysis and so how the forces act on the steering system.","title":"Abstract"},{"location":"fenice-steering-system-DMT/Home/#introduction","text":"The steering system needs to be such that the car can cover all turns on the track and also give accurate steering feel to the driver. The steering effort required by the driver should not be too much that it makes it uncomfortable and at the same time maintains enough steering feel. As soon as the front wheels steer, the characteristics of the steering system determine if them remain parallel to each other or the internal wheel steers less or more than the external one. This steering system has been projected using the Ackermann objective function. In the figure below are represented the three systems shortly cited before. The typical steering system, in a road or race car, has tie-rod linkages and steering arms that form an approximate parallelogram, which skews to one side as the wheels turn. If the steering arms are parallel, then both wheels are steered to the same angle. If the steering arms are angled, this is known as Ackerman geometry. The inside wheel is steered to a greater angle then the outside wheel, allowing the inside wheel to steer a tighter radius. The steering arm angles as drawn show \\(100 \\%\\) Ackerman. Different designs may use more or less percentage pro-Ackerman, anti-Ackerman, or Ackerman may be adjustable. Full Ackerman geometry requires steering angles, inner wheel and outer wheel. The angles are a function of turn centre radius, wheel base and track, but this fact is discussed in the second part. Ackermann geometry is commonly adopted in every application that has low lateral acceleration. Normally for vehicles that race in Formula SAE competitions, tracks used for ski-pad and autocross have features for which velocity in curve is so low, because its radius is so little. For this reasons Ackerman geometry has been chosen for Fenice. In Formula 1 cars are reached strong lateral acceleration, the situation is totally different: in these conditions wheels are characterised by significative slip angles. Moreover the load applied on the external wheel is pretty higher compared to the load on internal one. In the figure on the left side is clear that with low loads the vehicle needs slip angles lower to reach the peak of the maximum lateral load resistible for the wheels. With Ackermann geometry the internal wheel is forced to assume an higher slip angle to reach the maximum lateral force. This means a drag of the internal wheel, determining a growth of the temperature and a slowdown of the vehicle. Tyre drag is a force in the opposite direction of vehicle movement analogous to aerodynamic drag but created due to the tire. Higher the slip angle at which the car operates more the drag produced by the tire. This tire drag has a huge effect on cornering of a vehicle. Consequently for race cars is normally used a parallel steering system or even an antiAckerman geometry.","title":"Introduction"},{"location":"fenice-steering-system-DMT/Home/#static-analysis","text":"","title":"Static Analysis"},{"location":"fenice-steering-system-DMT/Home/#definition-of-the-objective-function","text":"Keeping in mind that the goal is that of creating a steering system which describes, as faithfully as possible the Ackermann's steer, the scheme shown on image number 3 allows to relate the geometrical parameters for the definition of the loss function, which is the one that describes a \\(100 \\%\\) Ackermann's steer. Image number 3 takes into consideration a steering system which is symmetrical to the longitudinal line of the car; moreover the deemed half is schematized as a quadrilateral: as will be seen later, this scheme will be brought back to one which presents a steering box with rack-pinion rather than a hinge. Parameter \" \\(w\\) \" indicates the \"wheelbase\", which, in the displayed case, is equivalent to \\(1540 \\mathrm{~mm}\\) ; Parameter \" \\(\\mathrm{t}\\) \" shows the \"track\", which is the carriageway, which, is the shown case, is equivalent to 1270mm; \\(\\mathrm{R}\\) is the radius of the curve carried out by the car; \\(\\delta\\) angle is the steering angle carried out in the case in which the steering wheel is directly connected to the central hinge, operating therefore directly on the steering arms (in this case too, it will later on displayed how to take in count the gear ratio brought by the rack); \\(\\delta s\\) is the angle which describes the internal wheel compared to the longitudinal direction; CIR stands for \"center of instant rotation\", as previously mentioned, if the steering is similar to the Ackermann's one, then all four wheels will rotate (on the plan ?) following a common rotation centre. At this point we can describe: \\[ \\begin{gathered} \\tan \\delta=\\frac{w}{R} \\\\ \\tan \\delta_{s}=\\frac{w}{R-\\frac{t}{2}}=\\frac{w / R}{1-\\frac{t}{2 R}}=\\frac{\\tan \\delta}{1-\\frac{t}{2 R}} \\\\ \\delta_{s}=\\tan ^{-1}\\left(\\frac{\\tan \\delta}{1-\\frac{t}{2 w} \\tan \\delta}\\right) \\end{gathered} \\] 3.3 Allows to calculate the angle that the wheel must have based on the steering angle, in order to respect the Ackermann's steer. Such angle is, therefore, the loss function, which one tries to obtain by properly selecting the steering arms length. It is so possible to describe the \\(\\mathrm{yd}(\\delta)\\) function as: \\[ y d(\\delta)=\\tan ^{-1}\\left(\\frac{\\tan \\delta}{1-\\frac{t}{2 w} \\tan \\delta}\\right) \\]","title":"Definition of the objective function"},{"location":"fenice-steering-system-DMT/Home/#definition-of-geometry","text":"In the following considerations it'll be only displayed the movement of the anterior right wheel, since what happens on the left wheel is symmetrical. The steering system is, therefore, schematized as a quadrilateral with the only difference that the central hinge in image 3 is substituted with a prismatic joint, which only allows the traversing along the transversal direction. Taking into account that a steering box with a rack is being used, the general steering geometry is represented on image 5: It is important to highlight that the segment CD doesn't represent a physical arm which will be part of the steering system, but an ideal line which connects the attachment point of the arm \\(B C\\) to the hub bracket with the real rotation center of the wheel (point D which remains fixed during the wheel movement); it basically has the simple function of \"graphically\" complete the quadrilateral with which it is possible to describe any steering system. Instead \\(s\\) is the distance from the centre of the rack and the origin of the main reference frame. It is collocated where the pinion is attached to the steering box. The optimization parameters will be: \\(\\mathrm{BC}\\) length (which we will call \\(\\mathrm{L} 2\\) ), \\(\\mathrm{CD}\\) length (which we will call \\(\\mathrm{L} 3\\) ) and \\(\\alpha\\) angle, which is the angle between the wheel longitudinal direction and the CD segment: such angle stays constant during the wheel rotation. To define the geometry of this mechanism in an analogous way as the one shown on image 5 , the following procedure was used, written in Mathematica: All the names given to the parameters match with the ones written in the image 5 ; a little clarification must be given concerning \" \\(c\\) \" parameter and \" \\(\\beta\\) \" angle. The figure below shows a triangle which was obtained inside the quadrilateral. By applying the cosine theorem to such triangle it is possible to find: \\[ \\cos \\beta=\\frac{L_{2}^{2}+L_{5}^{2}-L_{3}^{2}}{2 L_{2} L_{5}} \\] From here it is possible to obtain angle \\(\\beta\\) as shown in the procedure. Finally, the parameter \"modo\" allows to select how to assemble the mechanism: in one case BC and CD sides are going to be over the artificial side \\(L 5\\) , while the opposite happens in the second case.","title":"Definition of geometry"},{"location":"fenice-steering-system-DMT/Home/#optimization-procedure","text":"At this point it is possible to proceed with the actual optimization in order to find the parameters mentioned above. The following procedure was used: The first thing to clarify is that the \"Steer\" function allows to transform the steering wheel rotation (expressed by the \\(p 1, \\gamma 2=-115,115\\) angles) in the rack \" \\(q\\) \" linear shift. In partcular calculating the circular crown of the pinion equal to \\(\\frac{2*\\pi*r}{360}\\) , where r is radius of the pinion = 17 mm. In order to do so, a c-factor was set (which corresponds to the millimeters of displacement of tha rack for every full rotation of the pinion) which is equal to: cfactor \\(=108 \\mathrm{~mm}\\) . It was decided to limit the steering wheel rotation range between \\(-115^{\\circ}\\) and \\(+115^{\\circ}\\) since the pilot, which sits inside the narrow cockpit of the single-seater car, would have many difficulties in turning the steering wheel at higher angles. To connect the \\(\\delta\\) steering angle (which is the one that you would have in the case in which the steering wheel was directly connected to the central hung in image 3), initially defined as the shift of the \\(q\\) rack, it is possible to consider the scheme shown in the image 7 : The length L1 corresponds to the size of the rack when the wheels are straight; in this case it was chosen L1 \\(=225 \\mathrm{~mm}\\) . It is therefore possible to notice that the \\(\\delta\\) angle can be calculated as: \\[ \\delta=\\tan ^{-1} \\frac{q}{s} \\] It is necessary to specify that the optimization was carried out on a set of \"s\" values: the values taken into consideration are: \\(30,40,50,60,70,80 \\mathrm{~mm}\\) . As it will be shown, in the final version \\(\\mathrm{s}=70 \\mathrm{~mm}\\) . The two parameters \"offsetx\" and \"offsety\" allow to indicate the effective point around which the tyre turns, keeping in count the influence the caster and kingpin angles. In this case we have: offsetx \\(=-77.67 \\mathrm{~mm}\\) , offsety \\(=16.78 \\mathrm{~m}\\) . The tyre center of rotation is, therefore, moved to the center and towards the front of the car compared to the \"physical\" center of the wheel. It will be now described the goal of the various functions which are part of the optimization procedure: the \" \\(y\\) \" function calculates the first output of the \"Quadrilateral\" procedure, that is the \\(\\theta 3\\) angle, to which the \\(90^{\\circ}+\\alpha\\) is subtracted. The coordinate X of the point A is fixed corresponding to the origin, while the y is a set of values that is going to be optimized. In agreement with Image 5 , it is possible to affirm that the \" \\(\\mathrm{y}\\) \" function calculates the effective angle on which the right tyre turns (so it represents the output of the steering system); the \"yd\" function, as previously said, is the desired function, namely the ideal output that the steering system should have if it perfectly respected the Ackermann's geometry; the \"f\" function calculates a series of values which describe the linear moving of the rack between the maximum value (q1) and the minimum one (q2). After that it calculates the mistake which one has for each of these values, which is the absolute value of the subtraction between the real steering angle (given by the \" \\(\\mathrm{y}\\) \" function) and the idea steering angle (given by the \" \\(\\mathrm{yd}\\) \" function). Worth mentioning that, thanks to the absolute value, during the optimization the singular configurations will be automatically excluded, which, since they're complex numbers, give a major contribution to the module; the \"yforce\" function calculates the cosine of the subtraction between the \\(\\theta 3\\) angle and the \\(\\theta 2\\) angle, obtaining, this way the cosine of the angle between \\(\\mathrm{BC}\\) and \\(\\mathrm{CD}\\) arms; the \"fforce\" function, as the \"f\" function calculates a series of values included between \\(q 1\\) and \\(q 2\\) , after that it determines the maximum of the \"yforce\" function module, assessed in each of these points; finally, \"NMinimize\" allows to carry out the real optimization, using as optimization parameters the one previously listed (which are highlighted in blue). By minimizing both the \" \\(f\\) \" and \"fforce\" function we have two effects: on one side you minimize the mistake calculated in the first function, on the other one you minimize the the cosine of the angle between the two \\(B C\\) and \\(C D\\) arms; this means that, following the optimization, such angle will tend to be as close as possible to \\(90^{\\circ}\\) (where the cosine is to the minimum). This was made because, by maintaining such angle close to \\(90^{\\circ}\\) it is possibile to maximize the transfer of forces between arm and wheel, reducing, then, the necessary effort to steer. It is possible to notice that the \"fforce\" function gets multiplied for a number: it allows such function to augment or diminish the importance of such function inside the optimization; this is made to avoid reaching a top high mistake in order to minimize the \"fforce\" function;","title":"Optimization procedure"},{"location":"fenice-steering-system-DMT/Home/#results-analysis","text":"The result of the optimization is shown on table: s [mm] Error [deg] L2 [mm] L3 [mm] \u03b1 [deg] 30 23.79 214.4 136.9 72.37 40 16.89 224.4 133.6 64.53 50 3.46 348.1 59.3 -13.33 60 2.83 352.7 69.3 -15.55 70 2.44 334.7 74.4 0.043 It is possible to notice that for the fist values of \" \\(\\mathrm{s}\\) \" the mistakes is very high, therefore such solutions are not achievable. In the end it was decided to use the configuration with \\(\\mathrm{s}=70 \\mathrm{~mm}\\) : it is not the one that allows to have the minimum mistake, but it is the one which best represents the compromise in order to deny the risk of the two arms touching the internal wall of the wheel rim while steering. The final result, using the parameters related to \\(s=70 \\mathrm{~mm}\\) , is shown on Image 8 : This configuration, as shown on Table 1, presents an average mistake of circa \\(2.44^{\\circ}\\) . Image 9 shows, though, the effective variance between the ideal function and the one carried out by the right wheel of the steering system, for the steering wheel dangles comprehended between \\(-115^{\\circ}\\) and \\(115^{\\circ}\\) . In the previous graphic a clockwise rotation was taken in consideration as negative, that is when the right wheel results in being internal to the curve. It is possible to notice that the mistake grows as we move away from the configuration with straight wheels; however in the range in which we operate the most, the mistake is contained. It must be said that, by reducing the influence of the \"fforce\" function (so by diminishing the multiplier which precedes it) it would have been possible to obtain an even lower mistake. However in this way, point \" \\(\\mathrm{C}^{\\text {\" }}\\) would have resulted in being way more moved toward right and this wouldn't have been acceptable since such point (in which we have a spherical joint) would have crashed into the brake discs. The steering system was built in order to allow the car to cover a curve (quite narrow) with a \\(3 \\mathrm{~mm}\\) ray, considering that competitions take place on tracks which are characterized by very narrows curves. By using the \\(3.1\\) it is possible to calculate the \\(\\delta\\) angle, which is necessary to accomplish such curve where w is equal to \\(1540 \\mathrm{~mm}\\) and \\(\\mathrm{R}\\) equal to \\(3000 \\mathrm{~mm}\\) (it is to remember that \\(\\delta\\) angle represents the steering angle as if the steer operated directly in the arms). By passing such angle at the entrance of the \"yd\" function we obtain \\(y d=-32.17^{\\circ}\\) (it is to remember that the minus sign indicates a clockwise rotation). Ideally, therefore, to obtain a minimal \\(3 \\mathrm{~m}\\) steering ray it is necessary that the for the wheel too, to turn of such quantity. With a \\(108 \\mathrm{~mm}\\) c-factor as the one used when there's a maximal steer, that is \\(115^{\\circ}\\) , the rack swifts for \\(34.62\\) \\(\\mathrm{mm}\\) ; using \\(4.1\\) we obtain \\(\\delta=26.32^{\\circ}\\) to which corresponds; \\(y d=-31.01^{\\circ}\\) . The chosen c-factor allows therefore to get very close to the ideal steering angle which would be necessary to perform a \\(3 \\mathrm{~m}\\) ray curve; it was decided to not further increase the c-factor to deny the steering wheel being too direct, resulting in it being too difficult to control and ever heavier to maneuver. In the end the real maximal rotation angle which describes the \\(i\\) thermal wheel compared to the curve is circa \\(-29.66^{\\circ}\\) . It is possible to calculate that this value makes it possible for the car to cover a curve with a maximal ray of \\(3.256 \\mathrm{~m}\\) . This value differ a little bit from the one that was chosen as the goal, however it is still acceptable. In this table are shown the optimized dimensions of the steering system: L1 [mm] L2 [mm] L3 [mm] s [mm] \u03b1 [deg] 225 334.7 74.4 70 0.043","title":"Results analysis"},{"location":"fenice-steering-system-DMT/Home/#revision-history","text":"V1.0: Initial release (Andrea Colavero)","title":"Revision History"},{"location":"fenice-steeringwheel/","text":"Steering Wheel Welcome to the Fenice Steering Wheel documentation. Fenice Steering Wheel is a modular Qt application that interacts with the rest of the vehicle and displays useful information to the team and the pilot during preparation or race. In production the software is deployed to a Raspberry Pi 3b+ into a custom PCB that allows simple communications with all the I/O of the device. During development the software can be tested on any x86 machine that supports Qt natively. Most of the custom I/O is abstracted so complex interaction can still be tested.","title":"Steering Wheel"},{"location":"fenice-steeringwheel/#steering-wheel","text":"Welcome to the Fenice Steering Wheel documentation. Fenice Steering Wheel is a modular Qt application that interacts with the rest of the vehicle and displays useful information to the team and the pilot during preparation or race. In production the software is deployed to a Raspberry Pi 3b+ into a custom PCB that allows simple communications with all the I/O of the device. During development the software can be tested on any x86 machine that supports Qt natively. Most of the custom I/O is abstracted so complex interaction can still be tested.","title":"Steering Wheel"},{"location":"fenice-steeringwheel/development/qt/","text":"Building Qt for the Raspberry Pi This guide is an edited version of the original by abhiTronix . Prerequites A. Hardware Host: Any x86 / x86_64 AMD / Intel machine Target: Raspberry Pi any variant / module B. Software Host: Any Linux machine (Ubuntu 20.04 Tested) Target: Any Raspberry Pi Linux 32-bit OS (Raspbian Buster Tested) C. Others Storage and Time Requirements: The build directory takes around \\~10GB space and about 2-5 hours to complete (based on dependencies & Host Machine Specifications) . Networking: Your Target Machine (Raspberry Pi) and Host Machine (where you cross-compiling) both must have internet access, and must be on same network to follow these instructions. Setup the Target Machine 1. Start from Scratch (Optional) Important: If you just brought a new Raspberry Pi or wanted to start from scratch just follow along. Otherwise, if you already has your Raspberry Pi setup, running, and Network Ready, then just skip to step 2 . Note: This section assume you have atleast 10GB SDcard for installing Raspbian Buster OS and a Laptop/PC for uploading it. 1.1. Download Softwares & Prepare the SD card Download the latest version of Raspbian (Buster) from here on your laptop/pc. You will be needing an image writer to write the downloaded OS into the SD card (micro SD card in our case) . So download the open-source \u201cwin32 disk imager\u201d from here , OR you can also use Balena Etcher instead. Insert the SD card into the laptop/pc and run the image writer. Once open, browse and select the downloaded Raspbian image file. Select the correct device, that is the drive representing the SD card. Note: If the drive (or device) selected is different from the SD card then the other selected drive will become corrupted. SO BE CAREFUL! Once the write is complete, eject the SD card and insert it into the Raspberry Pi and turn it on. It should start booting up. Please remember that after booting the Pi, there might be situations when the user credentials like the \u201cusername\u201d and password will be asked. Raspberry Pi comes with a default username pi and password raspberry and so use it whenever it is being asked. 1.2 Set up Network Now the you have your Raspberry Pi up and Running, its time to connect it your network with one of following ways: If you have Monitor . If you don\u2019t have Monitor Any other way 2. Set up SSH If you have Monitor: On the Raspberry Pi terminal, type: sudo raspi-config and menu should pop up on your terminal. To enable SSH, go to: Interfacing Options -> SSH -> Yes , and Click OK to enable it. Choose Finish finally and exit. If you don\u2019t have Monitor: After setting up the network, if you don\u2019t have monitor or you operating it remotely. Then, enable SSH by just taking out your SD card, and hook it your computer, and simply create an empty file called ssh in the /boot/parition path inside SD card. Now insert back SD card into the Raspberry Pi. 3. Open Terminal From another Laptop/PC using SSH: To connect to your Pi from a different computer, copy and paste the following command into the terminal window but replace 192.160.1.47 with the IP address of the Raspberry Pi. Use Ctrl + Shift + V to paste in the terminal. ssh pi@192.168.1.47 It will ask for password, and if not changed, it is default ( raspberry ), and so use it whenever it is being asked. Note: It is possible to configure your Raspberry Pi to allow access from another computer without needing to provide a password each time you connect. For more details, see here . On Raspberry Pi directly with a Monitor: Just search \u201cTerminal\u201d and click on it. 4. Enable GL (FAKE KMS) To enable Fake KMS, type sudo raspi-config on your terminal to open a menu, then go to: Advanced Options -> A8 GL Driver -> G2 GL (Fake KMS) That should enable KMS. Choose Finish finally and exit. Note: If you are using a minimal build, you may be prompted to download some updates before this option becomes available. If asked, do so. 5. Enable Development Sources You need to edit your sources list to enable development sources. To do this, enter the following command into pi terminal: sudo nano /etc/apt/sources.list In the nano text editor, uncomment the following line by removing the # character from following line: deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi When done, press Ctrl+O and then ENTER to quit. 6. Update the system Run the following commands in terminal to update the system sudo apt update sudo apt dist-upgrade 7. Enable rsync with elevated rights Later in this guide, we will be using the rsync command to sync files between the Host PC/Laptop and the Raspberry Pi. For some of these files, root rights (i.e. sudo) is required internally. You can do this with a single terminal command as follows: echo \" $USER ALL=NOPASSWD: $( which rsync ) \" | sudo tee --append /etc/sudoers That\u2019s it. Now rsync should be setup to run with sudo if needed. 8. Install the important Development Packages Run the following commands in Raspberry Pi terminal to install the required packages: sudo apt install build-essential cmake unzip pkg-config gfortran sudo apt build-dep qt5-qmake libqt5gui5 libqt5webengine-data libqt5webkit5 libudev-dev libinput-dev libts-dev libxcb-xinerama0-dev libxcb-xinerama0 gdbserver sudo apt install libxcb-randr0-dev libxcb-xtest0-dev libxcb-shape0-dev libxcb-xkb-dev 9. Additional packages (Optional) You can install these packages if you want additional multimedia and bluetooth capability with your QT binaries: # additional (multimedia) packages sudo apt install libjpeg-dev libpng-dev libtiff-dev sudo apt install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt install libxvidcore-dev libx264-dev # audio packages sudo apt install libopenal-data libsndio7.0 libopenal1 libopenal-dev pulseaudio # bluetooth packages sudo apt install bluez-tools sudo apt install libbluetooth-dev # gstreamer (multimedia) packages sudo apt install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa gstreamer1.0-gl gstreamer1.0-gtk3 gstreamer1.0-qt5 gstreamer1.0-pulseaudio sudo apt install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev 10. Create directory for QT Deployment Now we create directories where the built QT Binaries will be deployed to your the Rasberry Pi, with following commands: sudo mkdir /usr/local/qt5.15 sudo chown -R pi:pi /usr/local/qt5.15 Also don\u2019t forget to setup Important Symlinks as follows: (Important) sudo ln -sf -r /usr/include/arm-linux-gnueabihf/asm /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/gnu /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/bits /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/sys /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/openssl /usr/include sudo ln -sf /usr/lib/arm-linux-gnueabihf/crtn.o /usr/lib/crtn.o sudo ln -sf /usr/lib/arm-linux-gnueabihf/crt1.o /usr/lib/crt1.o sudo ln -sf /usr/lib/arm-linux-gnueabihf/crti.o /usr/lib/crti.o That\u2019s it for Raspberry Pi setup. Setup the Host Machine Now Raspberry Pi Side all setup, Let\u2019s focus on commands for our Host Machine, i.e. PC/Laptop, where you going to cross-compile the QT Binaries for your Raspberry Pi. Important: Make sure your Raspberry Pi and this Host machine (where you cross-compiling) MUST be on the SAME Network. 1. Update the Host Machine First of all, Run the following commands to update your system and install important dependancies: sudo apt update sudo apt dist-upgrade sudo apt install build-essential cmake unzip gfortran sudo apt install gcc git bison python gperf pkg-config gdb-multiarch wget sudo apt-get -y install gcc g++ gperf flex texinfo gawk bison openssl pigz libncurses-dev autoconf automake tar figlet 2. Setting up the directory structure You can use these following commands to create \u201crpi-qt\u201d to use as workspace for building QT Binaries: sudo mkdir ~/rpi-qt sudo mkdir ~/rpi-qt/build sudo mkdir ~/rpi-qt/tools sudo mkdir ~/rpi-qt/sysroot sudo mkdir ~/rpi-qt/sysroot/usr sudo mkdir ~/rpi-qt/sysroot/opt sudo chown -R 1000 :1000 ~/rpi-qt cd ~/rpi-qt Note: Ensure the last command should have changed your current directory to ~/rpi-qt . If not, run the last line again to make sure you are inside it, as the next steps assume you\u2019re running your commands from this directory. 3. Download & Extract QT Source A. Download Binary Now, we can download the Latest source files for QT LTS (i.e. v5.15.2 ) by running following Terminal command to download the source files: sudo wget http://download.qt.io/archive/qt/5.15/5.15.2/single/qt-everywhere-src-5.15.2.tar.xz Note: You can also manually download file through browser, and place it in the ~/rpi-qt directory. B. Extract Binary Extract the downloaded tar file with the following command: sudo tar xfv qt-everywhere-src-5.15.2.tar.xz 4. Patching QT Source We need to slightly modify the a mkspec file within the source files to allow us to use our cross compiler. We will copy an existing directory within the source files, and modify the name of the directory and the contents of the qmake.conf file within that directory to follow the name of our compiler. To do this, run the following two command: cp -R qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabi-g++ qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabihf-g++ sed -i -e 's/arm-linux-gnueabi-/arm-linux-gnueabihf-/g' qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabihf-g++/qmake.conf 5. Download & Extract the Precompiled Cross-Compiler Let\u2019s first change into tools directory for downloading our Precompiled Cross-compiler with the following command: cd ~/rpi-qt/tools Note: Ensure the last command should have changed your current directory to ~/rpi-qt/tools now. If not, run it again. A. Copy Binary URL Copy URL from one of following Precompiled Compressed Base-Toolchain (for maximum compatability) based on your Raspberry Pi Variant and OS you installed on it, from below: Raspberry Pi Board Stretch (32 bit) Buster (32 bit) Zero/W/WH & 1 Model A/B/A+/B+ https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-6.3.0-pi_0-1.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-8.3.0-pi_0-1.tar.gz 2 & 3 Model A/B https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-6.3.0-pi_2-3.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-8.3.0-pi_2-3.tar.gz 3 & 4 Model A+/B+ & Compute 3/3-lite/3+ https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%203A%2B%2C%203B%2B%2C%204/cross-gcc-6.3.0-pi_3%2B.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%203A%2B%2C%203B%2B%2C%204/cross-gcc-8.3.0-pi_3%2B.tar.gz Note: You can also use the latest cross-compiler binaries instead. But they are not tested. B. Download Binary After that, paste your copied URL and run the following command to download the Cross-compiler: wget <Copied Binary URL goes here> #for e.g. => wget https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-8.3.0-pi_2-3.tar.gz C. Extract Binary Once it is downloaded, we can extract it using the following command: tar xf cross-gcc-*.tar.gz 6. Sync Raspberry Pi sysroot (Most Important) First, let\u2019s move back into the rpi folder as needed for the next sections: cd ~/rpi-qt Now, we need to sync up our sysroot folder with the system files from the Raspberry Pi. We will be using rsync that let us sync (i.e. copy) files from the Raspberry Pi with appropriate permission onto your Host Machine, potentially saving you alot of time. To do this, enter the following commands one by one into your terminal (change ``192.168.1.47`` with the IP address of your Raspberry Pi present on the same network) : Command 1: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/lib sysroot Command 2: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/usr/include sysroot/usr Command 3: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/usr/lib sysroot/usr Command 4: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/opt/vc sysroot/opt Note: Double check after each of the above commands that all the files have been copied to ~/rpi-qt/sysroot folder. There will be an information message if there were any issues. 7. Fix symbolic links The files we copied in the previous step still have symbolic links pointing to the file system on the Raspberry Pi. We need to alter this so that they become relative links from the new sysroot directory on the host machine. We can do this with a python script, which we can download as follows: wget https://raw.githubusercontent.com/abhiTronix/rpi_rootfs/master/scripts/sysroot-relativelinks.py Once it is downloaded, you just need to make it executable and run it, using the following commands: sudo chmod +x sysroot-relativelinks.py ./sysroot-relativelinks.py sysroot 8. Configure QT Build Let\u2019s move into the build directory for further steps, as we don\u2019t want to build within that source directory as its crowded, so we will access it from within this this directory: cd ~/rpi-qt/build Finally, Now we can configure our QT build. We need to run the configure script inside QT source to configure our build. Run following command to configure the build, including all the necessary options: CROSS_COMPILER_LOCATION = $HOME /rpi-qt/tools/cross-pi-gcc-* ../qt-everywhere-src-5.15.2/configure -release -opengl es2 -eglfs -device linux-rasp-pi4-v3d-g++ -device-option CROSS_COMPILE = $( echo $CROSS_COMPILER_LOCATION ) /bin/arm-linux-gnueabihf- -sysroot ~/rpi-qt/sysroot/ -prefix /usr/local/qt5.15 -extprefix ~/rpi-qt/qt5.15 -opensource -confirm-license -skip qtscript -skip qtwayland -skip qtwebengine -nomake tests -make libs -pkg-config -no-use-gold-linker -v -recheck -L $HOME /rpi-qt/sysroot/usr/lib/arm-linux-gnueabihf -I $HOME /rpi-qt/sysroot/usr/include/arm-linux-gnueabihf The configure script may take a few minutes to complete. 8.1 Check Configure Output Once it is completed you should get a summary of what has been configured. Make sure the following options appear: Configure summary: Building on: linux-g++ ( x86_64, CPU features: mmx sse sse2 ) Building for : devices/linux-rasp-pi4-v3d-g++ ( arm, CPU features: neon ) Target compiler: gcc 8 .3.0 Configuration: cross_compile compile_examples enable_new_dtags largefile neon precompile_header shared shared rpath release c++11 c++14 c++17 c++1z concurrent dbus reduce_exports stl 8.2 Check if EGLFS enabled QPA backends: EGLFS .................................. yes [ SHOULD BE YES ] EGLFS details: EGLFS OpenWFD ........................ no EGLFS i.Mx6 .......................... no EGLFS i.Mx6 Wayland .................. no EGLFS RCAR ........................... no EGLFS EGLDevice ...................... yes [ SHOULD BE YES ] EGLFS GBM ............................ yes EGLFS VSP2 ........................... no EGLFS Mali ........................... no EGLFS Raspberry Pi ................... no [ SHOULD BE NO ] EGLFS X11 ............................ yes If the your configuration summary doesn\u2019t have the EGLFS features set to what\u2019s shown above, something has probably gone wrong. You can look at the config.log file in the build directory to try and diagnose what the issue might be. If all looks good and all libraries you need have been installed we can continue to the next section 9. Build QT Source Our build has been configured now, and it is time to actually build the source files, and run the following command: Important: Ensure you are still in the ~/rpi-qt/build directory make -j $( nproc ) Note: -j$(nproc) option indicates that the job should be spread into mutliple threads and run in parallel on available cores. \u2615\ufe0f This process will take some time! 10. Install QT Source Once it is completed, we can install the built package using the following command: make install This should install the files in the correct directories 11. Deploy QT to Raspberry Pi First move back into the rpi folder using the following command: cd ~/rpi-qt Now, We can now deploy built QT Binaries (contained in ``qt5.15`` folder in ``~/rpi-qt`` directory) back to our Raspberry Pi, again using rsync command. Just run the following command (change ``192.168.1.47`` with the IP address of your Raspberry Pi present on the same network) : rsync -avz --rsync-path = \"sudo rsync\" qt5.15 pi@192.168.1.47:/usr/local Final Step for Target Machine Update linker on Raspberry Pi Enter the following command to update the device letting the linker to find the new QT binary files: echo /usr/local/qt5.15/lib | sudo tee /etc/ld.so.conf.d/qt5.15.conf sudo ldconfig For Raspberry Pi 2: If you\u2019re facing issues with running the example, try to use 00-qt5pi.conf instead of qt5pi.conf , in the above command. \ud83c\udf7b That should be it! You have now succesfully installed latest QT 5.15.2 on the Raspberry Pi.","title":"Building Qt for the Raspberry Pi"},{"location":"fenice-steeringwheel/development/qt/#building-qt-for-the-raspberry-pi","text":"This guide is an edited version of the original by abhiTronix .","title":"Building Qt for the Raspberry Pi"},{"location":"fenice-steeringwheel/development/qt/#prerequites","text":"","title":"Prerequites"},{"location":"fenice-steeringwheel/development/qt/#a-hardware","text":"Host: Any x86 / x86_64 AMD / Intel machine Target: Raspberry Pi any variant / module","title":"A. Hardware"},{"location":"fenice-steeringwheel/development/qt/#b-software","text":"Host: Any Linux machine (Ubuntu 20.04 Tested) Target: Any Raspberry Pi Linux 32-bit OS (Raspbian Buster Tested)","title":"B. Software"},{"location":"fenice-steeringwheel/development/qt/#c-others","text":"Storage and Time Requirements: The build directory takes around \\~10GB space and about 2-5 hours to complete (based on dependencies & Host Machine Specifications) . Networking: Your Target Machine (Raspberry Pi) and Host Machine (where you cross-compiling) both must have internet access, and must be on same network to follow these instructions.","title":"C. Others"},{"location":"fenice-steeringwheel/development/qt/#setup-the-target-machine","text":"","title":"Setup the Target Machine"},{"location":"fenice-steeringwheel/development/qt/#1-start-from-scratch-optional","text":"Important: If you just brought a new Raspberry Pi or wanted to start from scratch just follow along. Otherwise, if you already has your Raspberry Pi setup, running, and Network Ready, then just skip to step 2 . Note: This section assume you have atleast 10GB SDcard for installing Raspbian Buster OS and a Laptop/PC for uploading it.","title":"1. Start from Scratch (Optional)"},{"location":"fenice-steeringwheel/development/qt/#11-download-softwares-prepare-the-sd-card","text":"Download the latest version of Raspbian (Buster) from here on your laptop/pc. You will be needing an image writer to write the downloaded OS into the SD card (micro SD card in our case) . So download the open-source \u201cwin32 disk imager\u201d from here , OR you can also use Balena Etcher instead. Insert the SD card into the laptop/pc and run the image writer. Once open, browse and select the downloaded Raspbian image file. Select the correct device, that is the drive representing the SD card. Note: If the drive (or device) selected is different from the SD card then the other selected drive will become corrupted. SO BE CAREFUL! Once the write is complete, eject the SD card and insert it into the Raspberry Pi and turn it on. It should start booting up. Please remember that after booting the Pi, there might be situations when the user credentials like the \u201cusername\u201d and password will be asked. Raspberry Pi comes with a default username pi and password raspberry and so use it whenever it is being asked.","title":"1.1. Download Softwares &amp; Prepare the SD card"},{"location":"fenice-steeringwheel/development/qt/#12-set-up-network","text":"Now the you have your Raspberry Pi up and Running, its time to connect it your network with one of following ways: If you have Monitor . If you don\u2019t have Monitor Any other way","title":"1.2 Set up Network"},{"location":"fenice-steeringwheel/development/qt/#2-set-up-ssh","text":"If you have Monitor: On the Raspberry Pi terminal, type: sudo raspi-config and menu should pop up on your terminal. To enable SSH, go to: Interfacing Options -> SSH -> Yes , and Click OK to enable it. Choose Finish finally and exit. If you don\u2019t have Monitor: After setting up the network, if you don\u2019t have monitor or you operating it remotely. Then, enable SSH by just taking out your SD card, and hook it your computer, and simply create an empty file called ssh in the /boot/parition path inside SD card. Now insert back SD card into the Raspberry Pi.","title":"2. Set up SSH"},{"location":"fenice-steeringwheel/development/qt/#3-open-terminal","text":"From another Laptop/PC using SSH: To connect to your Pi from a different computer, copy and paste the following command into the terminal window but replace 192.160.1.47 with the IP address of the Raspberry Pi. Use Ctrl + Shift + V to paste in the terminal. ssh pi@192.168.1.47 It will ask for password, and if not changed, it is default ( raspberry ), and so use it whenever it is being asked. Note: It is possible to configure your Raspberry Pi to allow access from another computer without needing to provide a password each time you connect. For more details, see here . On Raspberry Pi directly with a Monitor: Just search \u201cTerminal\u201d and click on it.","title":"3. Open Terminal"},{"location":"fenice-steeringwheel/development/qt/#4-enable-gl-fake-kms","text":"To enable Fake KMS, type sudo raspi-config on your terminal to open a menu, then go to: Advanced Options -> A8 GL Driver -> G2 GL (Fake KMS) That should enable KMS. Choose Finish finally and exit. Note: If you are using a minimal build, you may be prompted to download some updates before this option becomes available. If asked, do so.","title":"4. Enable GL (FAKE KMS)"},{"location":"fenice-steeringwheel/development/qt/#5-enable-development-sources","text":"You need to edit your sources list to enable development sources. To do this, enter the following command into pi terminal: sudo nano /etc/apt/sources.list In the nano text editor, uncomment the following line by removing the # character from following line: deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi When done, press Ctrl+O and then ENTER to quit.","title":"5. Enable Development Sources"},{"location":"fenice-steeringwheel/development/qt/#6-update-the-system","text":"Run the following commands in terminal to update the system sudo apt update sudo apt dist-upgrade","title":"6. Update the system"},{"location":"fenice-steeringwheel/development/qt/#7-enable-rsync-with-elevated-rights","text":"Later in this guide, we will be using the rsync command to sync files between the Host PC/Laptop and the Raspberry Pi. For some of these files, root rights (i.e. sudo) is required internally. You can do this with a single terminal command as follows: echo \" $USER ALL=NOPASSWD: $( which rsync ) \" | sudo tee --append /etc/sudoers That\u2019s it. Now rsync should be setup to run with sudo if needed.","title":"7. Enable rsync with elevated rights"},{"location":"fenice-steeringwheel/development/qt/#8-install-the-important-development-packages","text":"Run the following commands in Raspberry Pi terminal to install the required packages: sudo apt install build-essential cmake unzip pkg-config gfortran sudo apt build-dep qt5-qmake libqt5gui5 libqt5webengine-data libqt5webkit5 libudev-dev libinput-dev libts-dev libxcb-xinerama0-dev libxcb-xinerama0 gdbserver sudo apt install libxcb-randr0-dev libxcb-xtest0-dev libxcb-shape0-dev libxcb-xkb-dev","title":"8. Install the important Development Packages"},{"location":"fenice-steeringwheel/development/qt/#9-additional-packages-optional","text":"You can install these packages if you want additional multimedia and bluetooth capability with your QT binaries: # additional (multimedia) packages sudo apt install libjpeg-dev libpng-dev libtiff-dev sudo apt install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt install libxvidcore-dev libx264-dev # audio packages sudo apt install libopenal-data libsndio7.0 libopenal1 libopenal-dev pulseaudio # bluetooth packages sudo apt install bluez-tools sudo apt install libbluetooth-dev # gstreamer (multimedia) packages sudo apt install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa gstreamer1.0-gl gstreamer1.0-gtk3 gstreamer1.0-qt5 gstreamer1.0-pulseaudio sudo apt install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev","title":"9. Additional packages (Optional)"},{"location":"fenice-steeringwheel/development/qt/#10-create-directory-for-qt-deployment","text":"Now we create directories where the built QT Binaries will be deployed to your the Rasberry Pi, with following commands: sudo mkdir /usr/local/qt5.15 sudo chown -R pi:pi /usr/local/qt5.15 Also don\u2019t forget to setup Important Symlinks as follows: (Important) sudo ln -sf -r /usr/include/arm-linux-gnueabihf/asm /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/gnu /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/bits /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/sys /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/openssl /usr/include sudo ln -sf /usr/lib/arm-linux-gnueabihf/crtn.o /usr/lib/crtn.o sudo ln -sf /usr/lib/arm-linux-gnueabihf/crt1.o /usr/lib/crt1.o sudo ln -sf /usr/lib/arm-linux-gnueabihf/crti.o /usr/lib/crti.o That\u2019s it for Raspberry Pi setup.","title":"10. Create directory for QT Deployment"},{"location":"fenice-steeringwheel/development/qt/#setup-the-host-machine","text":"Now Raspberry Pi Side all setup, Let\u2019s focus on commands for our Host Machine, i.e. PC/Laptop, where you going to cross-compile the QT Binaries for your Raspberry Pi. Important: Make sure your Raspberry Pi and this Host machine (where you cross-compiling) MUST be on the SAME Network.","title":"Setup the Host Machine"},{"location":"fenice-steeringwheel/development/qt/#1-update-the-host-machine","text":"First of all, Run the following commands to update your system and install important dependancies: sudo apt update sudo apt dist-upgrade sudo apt install build-essential cmake unzip gfortran sudo apt install gcc git bison python gperf pkg-config gdb-multiarch wget sudo apt-get -y install gcc g++ gperf flex texinfo gawk bison openssl pigz libncurses-dev autoconf automake tar figlet","title":"1. Update the Host Machine"},{"location":"fenice-steeringwheel/development/qt/#2-setting-up-the-directory-structure","text":"You can use these following commands to create \u201crpi-qt\u201d to use as workspace for building QT Binaries: sudo mkdir ~/rpi-qt sudo mkdir ~/rpi-qt/build sudo mkdir ~/rpi-qt/tools sudo mkdir ~/rpi-qt/sysroot sudo mkdir ~/rpi-qt/sysroot/usr sudo mkdir ~/rpi-qt/sysroot/opt sudo chown -R 1000 :1000 ~/rpi-qt cd ~/rpi-qt Note: Ensure the last command should have changed your current directory to ~/rpi-qt . If not, run the last line again to make sure you are inside it, as the next steps assume you\u2019re running your commands from this directory.","title":"2. Setting up the directory structure"},{"location":"fenice-steeringwheel/development/qt/#3-download-extract-qt-source","text":"","title":"3. Download &amp; Extract QT Source"},{"location":"fenice-steeringwheel/development/qt/#a-download-binary","text":"Now, we can download the Latest source files for QT LTS (i.e. v5.15.2 ) by running following Terminal command to download the source files: sudo wget http://download.qt.io/archive/qt/5.15/5.15.2/single/qt-everywhere-src-5.15.2.tar.xz Note: You can also manually download file through browser, and place it in the ~/rpi-qt directory.","title":"A. Download Binary"},{"location":"fenice-steeringwheel/development/qt/#b-extract-binary","text":"Extract the downloaded tar file with the following command: sudo tar xfv qt-everywhere-src-5.15.2.tar.xz","title":"B. Extract Binary"},{"location":"fenice-steeringwheel/development/qt/#4-patching-qt-source","text":"We need to slightly modify the a mkspec file within the source files to allow us to use our cross compiler. We will copy an existing directory within the source files, and modify the name of the directory and the contents of the qmake.conf file within that directory to follow the name of our compiler. To do this, run the following two command: cp -R qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabi-g++ qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabihf-g++ sed -i -e 's/arm-linux-gnueabi-/arm-linux-gnueabihf-/g' qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabihf-g++/qmake.conf","title":"4. Patching QT Source"},{"location":"fenice-steeringwheel/development/qt/#5-download-extract-the-precompiled-cross-compiler","text":"Let\u2019s first change into tools directory for downloading our Precompiled Cross-compiler with the following command: cd ~/rpi-qt/tools Note: Ensure the last command should have changed your current directory to ~/rpi-qt/tools now. If not, run it again.","title":"5. Download &amp; Extract the Precompiled Cross-Compiler"},{"location":"fenice-steeringwheel/development/qt/#a-copy-binary-url","text":"Copy URL from one of following Precompiled Compressed Base-Toolchain (for maximum compatability) based on your Raspberry Pi Variant and OS you installed on it, from below: Raspberry Pi Board Stretch (32 bit) Buster (32 bit) Zero/W/WH & 1 Model A/B/A+/B+ https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-6.3.0-pi_0-1.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-8.3.0-pi_0-1.tar.gz 2 & 3 Model A/B https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-6.3.0-pi_2-3.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-8.3.0-pi_2-3.tar.gz 3 & 4 Model A+/B+ & Compute 3/3-lite/3+ https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%203A%2B%2C%203B%2B%2C%204/cross-gcc-6.3.0-pi_3%2B.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%203A%2B%2C%203B%2B%2C%204/cross-gcc-8.3.0-pi_3%2B.tar.gz Note: You can also use the latest cross-compiler binaries instead. But they are not tested.","title":"A. Copy Binary URL"},{"location":"fenice-steeringwheel/development/qt/#b-download-binary","text":"After that, paste your copied URL and run the following command to download the Cross-compiler: wget <Copied Binary URL goes here> #for e.g. => wget https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-8.3.0-pi_2-3.tar.gz","title":"B. Download Binary"},{"location":"fenice-steeringwheel/development/qt/#c-extract-binary","text":"Once it is downloaded, we can extract it using the following command: tar xf cross-gcc-*.tar.gz","title":"C. Extract Binary"},{"location":"fenice-steeringwheel/development/qt/#6-sync-raspberry-pi-sysroot-most-important","text":"First, let\u2019s move back into the rpi folder as needed for the next sections: cd ~/rpi-qt Now, we need to sync up our sysroot folder with the system files from the Raspberry Pi. We will be using rsync that let us sync (i.e. copy) files from the Raspberry Pi with appropriate permission onto your Host Machine, potentially saving you alot of time. To do this, enter the following commands one by one into your terminal (change ``192.168.1.47`` with the IP address of your Raspberry Pi present on the same network) : Command 1: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/lib sysroot Command 2: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/usr/include sysroot/usr Command 3: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/usr/lib sysroot/usr Command 4: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/opt/vc sysroot/opt Note: Double check after each of the above commands that all the files have been copied to ~/rpi-qt/sysroot folder. There will be an information message if there were any issues.","title":"6. Sync Raspberry Pi sysroot (Most Important)"},{"location":"fenice-steeringwheel/development/qt/#7-fix-symbolic-links","text":"The files we copied in the previous step still have symbolic links pointing to the file system on the Raspberry Pi. We need to alter this so that they become relative links from the new sysroot directory on the host machine. We can do this with a python script, which we can download as follows: wget https://raw.githubusercontent.com/abhiTronix/rpi_rootfs/master/scripts/sysroot-relativelinks.py Once it is downloaded, you just need to make it executable and run it, using the following commands: sudo chmod +x sysroot-relativelinks.py ./sysroot-relativelinks.py sysroot","title":"7. Fix symbolic links"},{"location":"fenice-steeringwheel/development/qt/#8-configure-qt-build","text":"Let\u2019s move into the build directory for further steps, as we don\u2019t want to build within that source directory as its crowded, so we will access it from within this this directory: cd ~/rpi-qt/build Finally, Now we can configure our QT build. We need to run the configure script inside QT source to configure our build. Run following command to configure the build, including all the necessary options: CROSS_COMPILER_LOCATION = $HOME /rpi-qt/tools/cross-pi-gcc-* ../qt-everywhere-src-5.15.2/configure -release -opengl es2 -eglfs -device linux-rasp-pi4-v3d-g++ -device-option CROSS_COMPILE = $( echo $CROSS_COMPILER_LOCATION ) /bin/arm-linux-gnueabihf- -sysroot ~/rpi-qt/sysroot/ -prefix /usr/local/qt5.15 -extprefix ~/rpi-qt/qt5.15 -opensource -confirm-license -skip qtscript -skip qtwayland -skip qtwebengine -nomake tests -make libs -pkg-config -no-use-gold-linker -v -recheck -L $HOME /rpi-qt/sysroot/usr/lib/arm-linux-gnueabihf -I $HOME /rpi-qt/sysroot/usr/include/arm-linux-gnueabihf The configure script may take a few minutes to complete.","title":"8. Configure QT Build"},{"location":"fenice-steeringwheel/development/qt/#81-check-configure-output","text":"Once it is completed you should get a summary of what has been configured. Make sure the following options appear: Configure summary: Building on: linux-g++ ( x86_64, CPU features: mmx sse sse2 ) Building for : devices/linux-rasp-pi4-v3d-g++ ( arm, CPU features: neon ) Target compiler: gcc 8 .3.0 Configuration: cross_compile compile_examples enable_new_dtags largefile neon precompile_header shared shared rpath release c++11 c++14 c++17 c++1z concurrent dbus reduce_exports stl","title":"8.1 Check Configure Output"},{"location":"fenice-steeringwheel/development/qt/#82-check-if-eglfs-enabled","text":"QPA backends: EGLFS .................................. yes [ SHOULD BE YES ] EGLFS details: EGLFS OpenWFD ........................ no EGLFS i.Mx6 .......................... no EGLFS i.Mx6 Wayland .................. no EGLFS RCAR ........................... no EGLFS EGLDevice ...................... yes [ SHOULD BE YES ] EGLFS GBM ............................ yes EGLFS VSP2 ........................... no EGLFS Mali ........................... no EGLFS Raspberry Pi ................... no [ SHOULD BE NO ] EGLFS X11 ............................ yes If the your configuration summary doesn\u2019t have the EGLFS features set to what\u2019s shown above, something has probably gone wrong. You can look at the config.log file in the build directory to try and diagnose what the issue might be. If all looks good and all libraries you need have been installed we can continue to the next section","title":"8.2 Check if EGLFS enabled"},{"location":"fenice-steeringwheel/development/qt/#9-build-qt-source","text":"Our build has been configured now, and it is time to actually build the source files, and run the following command: Important: Ensure you are still in the ~/rpi-qt/build directory make -j $( nproc ) Note: -j$(nproc) option indicates that the job should be spread into mutliple threads and run in parallel on available cores. \u2615\ufe0f This process will take some time!","title":"9. Build QT Source"},{"location":"fenice-steeringwheel/development/qt/#10-install-qt-source","text":"Once it is completed, we can install the built package using the following command: make install This should install the files in the correct directories","title":"10. Install QT Source"},{"location":"fenice-steeringwheel/development/qt/#11-deploy-qt-to-raspberry-pi","text":"First move back into the rpi folder using the following command: cd ~/rpi-qt Now, We can now deploy built QT Binaries (contained in ``qt5.15`` folder in ``~/rpi-qt`` directory) back to our Raspberry Pi, again using rsync command. Just run the following command (change ``192.168.1.47`` with the IP address of your Raspberry Pi present on the same network) : rsync -avz --rsync-path = \"sudo rsync\" qt5.15 pi@192.168.1.47:/usr/local","title":"11. Deploy QT to Raspberry Pi"},{"location":"fenice-steeringwheel/development/qt/#final-step-for-target-machine","text":"","title":"Final Step for Target Machine"},{"location":"fenice-steeringwheel/development/qt/#update-linker-on-raspberry-pi","text":"Enter the following command to update the device letting the linker to find the new QT binary files: echo /usr/local/qt5.15/lib | sudo tee /etc/ld.so.conf.d/qt5.15.conf sudo ldconfig For Raspberry Pi 2: If you\u2019re facing issues with running the example, try to use 00-qt5pi.conf instead of qt5pi.conf , in the above command. \ud83c\udf7b That should be it! You have now succesfully installed latest QT 5.15.2 on the Raspberry Pi.","title":"Update linker on Raspberry Pi"},{"location":"fenice-steeringwheel/interface/tabs/","text":"Concept of Tabs","title":"Concept of Tabs"},{"location":"fenice-steeringwheel/interface/tabs/#concept-of-tabs","text":"","title":"Concept of Tabs"},{"location":"fenice-suspension-DMT/01-Folder-organization/","text":"Folder organization 2D suspension model In this folder there is a simple 2D model of a suspension, can be used to learn Maple and the kinematics of a suspension mechanism 2D_model_axle_fsolve: file maple of the suspension data_for_2d: file maple of the data suspensions Data_susp: library maple to read data of the suspensions docs In this folder there is the wiki files Fenice suspension model In this folder there is the fenice suspension model","title":"Folder organization"},{"location":"fenice-suspension-DMT/01-Folder-organization/#folder-organization","text":"","title":"Folder organization"},{"location":"fenice-suspension-DMT/01-Folder-organization/#2d-suspension-model","text":"In this folder there is a simple 2D model of a suspension, can be used to learn Maple and the kinematics of a suspension mechanism 2D_model_axle_fsolve: file maple of the suspension data_for_2d: file maple of the data suspensions Data_susp: library maple to read data of the suspensions","title":"2D suspension model"},{"location":"fenice-suspension-DMT/01-Folder-organization/#docs","text":"In this folder there is the wiki files","title":"docs"},{"location":"fenice-suspension-DMT/01-Folder-organization/#fenice-suspension-model","text":"In this folder there is the fenice suspension model","title":"Fenice suspension model"},{"location":"fenice-suspension-DMT/02-2D-suspension-model/","text":"2D suspension model","title":"2D suspension model"},{"location":"fenice-suspension-DMT/02-2D-suspension-model/#2d-suspension-model","text":"","title":"2D suspension model"},{"location":"fenice-suspension-DMT/03-Fenice-suspension-model/","text":"Fenice suspension model","title":"Fenice suspension model"},{"location":"fenice-suspension-DMT/03-Fenice-suspension-model/#fenice-suspension-model","text":"","title":"Fenice suspension model"},{"location":"fenice-suspension-DMT/Home/","text":"Fenice Suspensions Welcome to the Fenice Suspensions wiki! TABLE OF CONTENTS Folder organization 2D suspension model Fenice suspension model","title":"Fenice Suspensions"},{"location":"fenice-suspension-DMT/Home/#fenice-suspensions","text":"Welcome to the Fenice Suspensions wiki!","title":"Fenice Suspensions"},{"location":"fenice-suspension-DMT/Home/#table-of-contents","text":"Folder organization 2D suspension model Fenice suspension model","title":"TABLE OF CONTENTS"},{"location":"fenice-traction-control-sw/","text":"Fenice ECU: Traction Control Software The traction control software relies on the following components: The Matlab model (refer to the dynamics team) The Raspberry PI hosting the model and updating it with sensor data from the DAS The DAS module that reads and writes a UART channel with the RPi to communicate with the model Note The choice of running the model on a separate device is for reliability purposes. The car must be able to run even if the model crashes or the RPi breaks / has issues. This documentation is organized in the following sections: Setting up the correct environment on the Raspberry Pi Compiling and running the traction control server","title":"Overview"},{"location":"fenice-traction-control-sw/#fenice-ecu-traction-control-software","text":"The traction control software relies on the following components: The Matlab model (refer to the dynamics team) The Raspberry PI hosting the model and updating it with sensor data from the DAS The DAS module that reads and writes a UART channel with the RPi to communicate with the model Note The choice of running the model on a separate device is for reliability purposes. The car must be able to run even if the model crashes or the RPi breaks / has issues. This documentation is organized in the following sections: Setting up the correct environment on the Raspberry Pi Compiling and running the traction control server","title":"Fenice ECU: Traction Control Software"},{"location":"fenice-traction-control-sw/compiling/","text":"Compiling & Executing The Server Step 1: Install Dependencies To compile the code on the RPi you need to install GCC, Make, glibc_base-dev, and binutils. Install them with: tce-load -wi gcc make glibc_base-dev binutils .","title":"Compiling & Executing"},{"location":"fenice-traction-control-sw/compiling/#compiling-executing-the-server","text":"","title":"Compiling &amp; Executing The Server"},{"location":"fenice-traction-control-sw/compiling/#step-1-install-dependencies","text":"To compile the code on the RPi you need to install GCC, Make, glibc_base-dev, and binutils. Install them with: tce-load -wi gcc make glibc_base-dev binutils .","title":"Step 1: Install Dependencies"},{"location":"fenice-traction-control-sw/rpi-setup/","text":"Operating System In order to obtain maximum performance from the small RPi's CPU, the OS needs to be as lightweight as possible, and needs to support nothing more that a C compiler and serial communication. Core Linux is a distro that ships just a kernel and some core utilities in under 20Mb. Also, it runs completely from RAM, therefore strongly limiting the possibility of failure from SD card wear. Step 1: Download Go to Core Linux's home page and download the Raspberry Pi port, called PiCore : http://www.tinycorelinux.net . If you're not familiar with operating on this type of stripped-down OS, read the booklet or the wiki, both accessible from their website. Step 2: Flash The OS Insert an SD card and flash PiCore with dd : sudo dd if=piCore-13.1.0.img of=/dev/mmcblk0 Step 3: Extend SD Partition By default the storage partition is rather small, so in order to accomodate GCC and other extensions we need to expand it to the full available size: Boot the RPi and log in with user tc and password piCore Run fdisk /dev/mmcblk0 as root Print existing partitions with p and take note of the starting cylinder of the second partition Delete the second partition with d and recreate it with n Use the same starting cylinder as the old partition and maximum available size Write the partition table with w Reboot to make the kernel aware of the changes Now resize the existing filesystem to fill the partition with resize2fs /dev/mmcblk0p2 Step 4: Configure Linux First, set a password that everyone working on the project can remember easily with passwd , like sborato . Since Core runs completely in RAM, such changes won't normally remain after boot, so to make them permanent we need to instruct filetool to backup and restore some files across reboots. To do so, just add their path to /opt/.filetool.lst and trigger a backup by calling filetool.sh -b . In this case, we need to run echo '/etc/shadow' >> /opt/.filetool.lst and trigger the backup. Setp 5: Configure SSH If it's not already installed, run tce-load -wi openssh . To autostart it at every boot, add it to the startup script with sudo echo '/usr/local/etc/init.d/openssh start &' >> /opt/bootlocal.sh Since the filesystem is not persistent, the encryption keys are lost and regenerated at every boot. To make them permanent, add them to the filetool list with sudo echo '/usr/local/etc/ssh' >> /opt/.filetool.lst Trigger the backup with filetool.sh -b Step 6: Disable Bluetooth to Access The Primary UART In RPis with embedded Bluetooth and WiFi, the primary UART is connected to those modules and cannot be used by the user. To remedy that, add dt-overlay=diable-bt and enable_uart=1 to /boot/config.txt . Now, a device named /dev/ttyAMA0 will be available to the user to access the serial interface.","title":"RPi Setup"},{"location":"fenice-traction-control-sw/rpi-setup/#operating-system","text":"In order to obtain maximum performance from the small RPi's CPU, the OS needs to be as lightweight as possible, and needs to support nothing more that a C compiler and serial communication. Core Linux is a distro that ships just a kernel and some core utilities in under 20Mb. Also, it runs completely from RAM, therefore strongly limiting the possibility of failure from SD card wear.","title":"Operating System"},{"location":"fenice-traction-control-sw/rpi-setup/#step-1-download","text":"Go to Core Linux's home page and download the Raspberry Pi port, called PiCore : http://www.tinycorelinux.net . If you're not familiar with operating on this type of stripped-down OS, read the booklet or the wiki, both accessible from their website.","title":"Step 1: Download"},{"location":"fenice-traction-control-sw/rpi-setup/#step-2-flash-the-os","text":"Insert an SD card and flash PiCore with dd : sudo dd if=piCore-13.1.0.img of=/dev/mmcblk0","title":"Step 2: Flash The OS"},{"location":"fenice-traction-control-sw/rpi-setup/#step-3-extend-sd-partition","text":"By default the storage partition is rather small, so in order to accomodate GCC and other extensions we need to expand it to the full available size: Boot the RPi and log in with user tc and password piCore Run fdisk /dev/mmcblk0 as root Print existing partitions with p and take note of the starting cylinder of the second partition Delete the second partition with d and recreate it with n Use the same starting cylinder as the old partition and maximum available size Write the partition table with w Reboot to make the kernel aware of the changes Now resize the existing filesystem to fill the partition with resize2fs /dev/mmcblk0p2","title":"Step 3: Extend SD Partition"},{"location":"fenice-traction-control-sw/rpi-setup/#step-4-configure-linux","text":"First, set a password that everyone working on the project can remember easily with passwd , like sborato . Since Core runs completely in RAM, such changes won't normally remain after boot, so to make them permanent we need to instruct filetool to backup and restore some files across reboots. To do so, just add their path to /opt/.filetool.lst and trigger a backup by calling filetool.sh -b . In this case, we need to run echo '/etc/shadow' >> /opt/.filetool.lst and trigger the backup.","title":"Step 4: Configure Linux"},{"location":"fenice-traction-control-sw/rpi-setup/#setp-5-configure-ssh","text":"If it's not already installed, run tce-load -wi openssh . To autostart it at every boot, add it to the startup script with sudo echo '/usr/local/etc/init.d/openssh start &' >> /opt/bootlocal.sh Since the filesystem is not persistent, the encryption keys are lost and regenerated at every boot. To make them permanent, add them to the filetool list with sudo echo '/usr/local/etc/ssh' >> /opt/.filetool.lst Trigger the backup with filetool.sh -b","title":"Setp 5: Configure SSH"},{"location":"fenice-traction-control-sw/rpi-setup/#step-6-disable-bluetooth-to-access-the-primary-uart","text":"In RPis with embedded Bluetooth and WiFi, the primary UART is connected to those modules and cannot be used by the user. To remedy that, add dt-overlay=diable-bt and enable_uart=1 to /boot/config.txt . Now, a device named /dev/ttyAMA0 will be available to the user to access the serial interface.","title":"Step 6: Disable Bluetooth to Access The Primary UART"},{"location":"fenice-vehicle-model-DMT/Vehicle_Design_Choices/","text":"Vehicle Design Choices General dimensions Wheelbase As short as possible by regulation (with a few extra millimetres to be on the safe side). Track One constraint is the tilt test and cornering roll-over. In SAE the track at the rear is usually done a few \\(\\mathrm{cm}\\) less than at the front so if you don't catch the cone at the front you shouldn't catch it with the wheels at the back either. For the track, some simulations had been done, but not much influence on performance could be seen. However, one could theoretically derive an optimum track for a given tyre given the position of the vehicle's centre of gravity. Steering system For what regard the steering kinematics, we decide to adopt an anti-ackerman configuration in which the inner tire does not turn as much as the outer tire with the same input steering angle. This solution has been found to work better in fast turn and for this kind of vehicle moreover our particular set of tires prefer this geometry as the outer tire needs more slip angle to obtain peak lateral force values. Suspension system Double wishbone with carbon fiber tubes arms. Pull-rod configuration at the front, Push-rod at the rear. There are 5 main bodies in the suspension system (Upper and Lower A-arm, Upright, Rocker, Chassis). The design of the suspension system influences the position of the roll centers (points around which the chassis rolls). The greater is the distance of the roll axis from the center of mass, the greater is the force reacted by the springs (instead of been transferred through the suspension arms to the chassis) during roll; so the vehicle is less stiff. Roll center Front : \\(\\quad 23 \\mathrm{~mm}\\) Roll center Rear : \\(\\quad 54 \\mathrm{~mm}\\) The kinematic chain pull/push rod - rocker - damper has been optimized in order to have constant value of the motion ratio. Besides optimal loading conditions are guaranteed by correct angles between push/pull rod and rocker, and between rocker and damper. Custom-made shock absorber designed through non linear models and an optimization process. Anti-roll bar The classical ARB consists of a torsional bar connected with two knives at the roker. However, in our case, this solution does not accommodate the roker movement. Consequently, we moved toward a solution in which there are only the two bending knives and the torsional bar is substituted by an undeformable support able to rotate. The design allows also the tuning of the ARB: the elastic parts are the knives; since they are not radially symmetric we can rotate them to obtain a different ARB stiffness and so a different rolling response. This makes the vehicle set-up more elastic to the driver's needs. Brake system Rear on-board brakes reduction of unsprung masses less strain on arms and hub carriers more freedom in positioning wheel-side points shorter braking circuit and if desired rigid pipes could be used This solution also affects vehicle's anti-dive and was therefore considered in the design of the anti-dive and anti-squat features. Front on-wheel : ANTI DIVE \\(0.84\\) ( \\(-0.12\\) for on board brakes) Rear on-board : ANTI LIFT \\(0.32\\) ( \\(0.56\\) for in wheel brakes) ANTI SQUAT \\(0.80\\) ( \\(1.40\\) for in wheel brakes) Electric motors For the design and dimensioning of the two electric motors look at this report . The choice to have onboard motors have been made according to the same considerations done for the rear onboard brakes. Additionally, consider the greater complexity and difficulty in fitting in-wheel motors and gearboxes of that power with \\(10^{\\prime \\prime}\\) rims. Comparison of the Yaw-rate response for on-board and on-wheel configuration This comparison has been made by studying the transfer function between a sinusoidal steering wheel input with an increasing frequency and the output yaw-rate obtained by the car. It can be noticed that with on-board masses, it is possible to reach an higher yaw-rate response resulting in a better turning behavior of the car. Revision History V1.0 - 08/08/22 - Initial Release (Luca Dalle Sasse)","title":"Vehicle Design Choices"},{"location":"fenice-vehicle-model-DMT/Vehicle_Design_Choices/#vehicle-design-choices","text":"","title":"Vehicle Design Choices"},{"location":"fenice-vehicle-model-DMT/Vehicle_Design_Choices/#general-dimensions","text":"","title":"General dimensions"},{"location":"fenice-vehicle-model-DMT/Vehicle_Design_Choices/#wheelbase","text":"As short as possible by regulation (with a few extra millimetres to be on the safe side).","title":"Wheelbase"},{"location":"fenice-vehicle-model-DMT/Vehicle_Design_Choices/#track","text":"One constraint is the tilt test and cornering roll-over. In SAE the track at the rear is usually done a few \\(\\mathrm{cm}\\) less than at the front so if you don't catch the cone at the front you shouldn't catch it with the wheels at the back either. For the track, some simulations had been done, but not much influence on performance could be seen. However, one could theoretically derive an optimum track for a given tyre given the position of the vehicle's centre of gravity.","title":"Track"},{"location":"fenice-vehicle-model-DMT/Vehicle_Design_Choices/#steering-system","text":"For what regard the steering kinematics, we decide to adopt an anti-ackerman configuration in which the inner tire does not turn as much as the outer tire with the same input steering angle. This solution has been found to work better in fast turn and for this kind of vehicle moreover our particular set of tires prefer this geometry as the outer tire needs more slip angle to obtain peak lateral force values.","title":"Steering system"},{"location":"fenice-vehicle-model-DMT/Vehicle_Design_Choices/#suspension-system","text":"Double wishbone with carbon fiber tubes arms. Pull-rod configuration at the front, Push-rod at the rear. There are 5 main bodies in the suspension system (Upper and Lower A-arm, Upright, Rocker, Chassis). The design of the suspension system influences the position of the roll centers (points around which the chassis rolls). The greater is the distance of the roll axis from the center of mass, the greater is the force reacted by the springs (instead of been transferred through the suspension arms to the chassis) during roll; so the vehicle is less stiff. Roll center Front : \\(\\quad 23 \\mathrm{~mm}\\) Roll center Rear : \\(\\quad 54 \\mathrm{~mm}\\) The kinematic chain pull/push rod - rocker - damper has been optimized in order to have constant value of the motion ratio. Besides optimal loading conditions are guaranteed by correct angles between push/pull rod and rocker, and between rocker and damper. Custom-made shock absorber designed through non linear models and an optimization process.","title":"Suspension system"},{"location":"fenice-vehicle-model-DMT/Vehicle_Design_Choices/#anti-roll-bar","text":"The classical ARB consists of a torsional bar connected with two knives at the roker. However, in our case, this solution does not accommodate the roker movement. Consequently, we moved toward a solution in which there are only the two bending knives and the torsional bar is substituted by an undeformable support able to rotate. The design allows also the tuning of the ARB: the elastic parts are the knives; since they are not radially symmetric we can rotate them to obtain a different ARB stiffness and so a different rolling response. This makes the vehicle set-up more elastic to the driver's needs.","title":"Anti-roll bar"},{"location":"fenice-vehicle-model-DMT/Vehicle_Design_Choices/#brake-system","text":"","title":"Brake system"},{"location":"fenice-vehicle-model-DMT/Vehicle_Design_Choices/#rear-on-board-brakes","text":"reduction of unsprung masses less strain on arms and hub carriers more freedom in positioning wheel-side points shorter braking circuit and if desired rigid pipes could be used This solution also affects vehicle's anti-dive and was therefore considered in the design of the anti-dive and anti-squat features. Front on-wheel : ANTI DIVE \\(0.84\\) ( \\(-0.12\\) for on board brakes) Rear on-board : ANTI LIFT \\(0.32\\) ( \\(0.56\\) for in wheel brakes) ANTI SQUAT \\(0.80\\) ( \\(1.40\\) for in wheel brakes)","title":"Rear on-board brakes"},{"location":"fenice-vehicle-model-DMT/Vehicle_Design_Choices/#electric-motors","text":"For the design and dimensioning of the two electric motors look at this report . The choice to have onboard motors have been made according to the same considerations done for the rear onboard brakes. Additionally, consider the greater complexity and difficulty in fitting in-wheel motors and gearboxes of that power with \\(10^{\\prime \\prime}\\) rims. Comparison of the Yaw-rate response for on-board and on-wheel configuration This comparison has been made by studying the transfer function between a sinusoidal steering wheel input with an increasing frequency and the output yaw-rate obtained by the car. It can be noticed that with on-board masses, it is possible to reach an higher yaw-rate response resulting in a better turning behavior of the car.","title":"Electric motors"},{"location":"fenice-vehicle-model-DMT/Vehicle_Design_Choices/#revision-history","text":"V1.0 - 08/08/22 - Initial Release (Luca Dalle Sasse)","title":"Revision History"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/01-How-to-get-started/","text":"Getting Started Table of Contents Required Software GitHub Setup Setting up the SSH key Cloning the team's repository MATLAB Setup Run MATLAB/Simulink's model Required Software Visual Studio Code Matlab (version 2022a) and Simulink GitBash (only for Windows) GitHub setup Create a Github account using your academic e-mail (you can link multiple emails to the account, so you can also add your personal one) and send your git username to your CT (if you don't have one, add it to the recruitment form) . Once you've been invited to the team's Github organization, you can access DMT's repositories. Furthermore, if you have Windows you will need to download Git Bash . Then, you have to properly setup the SSH key to make your computer communicate correctly with the Github portal (both MacOS and Windows) . Setting up the SSH key Open GitBash for Windows or a terminal for MacOS. Check if you already have an SSH key, using the following command: ls -al ~/.ssh This command lists the files in your .ssh directory, if they exist. By default, the filenames of supported public keys for GitHub are id_rsa.pub , id_ecdsa.pub , id_ed25519.pub . If the list is empty, you have to create a new key . Paste the command below into GitBash , substituting your_email@example.com with your email address. ssh-keygen -t ed25519 -C \"your_email@example.com\" When you're prompted to Enter a file in which to save the key press Enter . This saves the key in the default file and location. At the prompt, type a secure passphrase (it's better to use an empty passphrase) Enter passphrase ( empty for no passphrase ) : [ Type a passphrase ] Enter same passphrase again: [ Type passphrase again ] Ensure the ssh-agent is running or start it manually. eval \" $( ssh-agent -s ) \" Add your SSH private key to the ssh-agent . If you created your key with a different name, or if you are adding an existing key that has a different name, replace id_ed25519 with the name of your private key's file. ssh-add ~/.ssh/id_ed25519 Add the SSH key to your account on GitHub . For more information, see \"Adding a new SSH key to your GitHub account\" . If you encounter any problems, take a look at the Official Github documentation . Cloning the team's repo: Go to the vehicle model's repository in the team's GitHub Organization , click on the Code button, copy the link to clone the repository (you'll need it in the upcoming step) . Open Git Bash (Windows) or your Terminal (MacOS) , be sure that you're in the folder in which you want to download the repo (usually it's useful to create a GitHub folder in which you'll download all the repo) Paste the following command to clone the repository: git clone --recurse-submodules git@github.com:eagletrt/fenice-vehicle-model-DMT.git NB: \"git@github.com:eagletrt/fenice-vehicle-model-DMT.git\" is the url of the repository, to clone other repositories you can substitute it with the other repository's url. MATLAB Setup First of all check that you have installed the correct version of MATLAB to avoid incompatibility problems when using the files. NB: This first section is crucial to properly setup MATLAB's environment, in order to execute the model correctly. The following list contains the toolboxes that you have to install manually: Control System Toolbox Curve Fitting Toolbox Digital Signal Processing Embedded Coder Fuzzy Logic Toolbox MATLAB Coder MinGW-w64 C/C++ Compiler ( only for Windows ) Optimization Toolbox Simscape Simscape Electrical Simscape Multibody Simulink Simulink 3D Animation Simulink Coder Simulink Control Design Symbolic Math Toolbox System Identification Toolbox Clothoids (The last toolbox and its documentation can be found at https://github.com/ebertolazzi/Clothoids/releases and can be used instead of the folder Clothoids (used in the old vehicle model) .\\ We suggest to follow the installation instructions the you can find and the previous link , because the toolbox is constantly updated by professor Bertolazzi.\\ During the installation phase, MATLAB may require to install an additional package called LAB Support for MinGW-w64 C/C++ Compiler . Run MATLAB/Simulink's Model Open MATLAB (after the initial setup described above for first time users) Open the local folder where you previously cloned the model's repository from GitHub Now on MATLAB's left column you can open the model's files and folders, particularly the main.m file!","title":"Getting Started"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/01-How-to-get-started/#getting-started","text":"","title":"Getting Started"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/01-How-to-get-started/#table-of-contents","text":"Required Software GitHub Setup Setting up the SSH key Cloning the team's repository MATLAB Setup Run MATLAB/Simulink's model","title":"Table of Contents"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/01-How-to-get-started/#required-software","text":"Visual Studio Code Matlab (version 2022a) and Simulink GitBash (only for Windows)","title":"Required Software"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/01-How-to-get-started/#github-setup","text":"Create a Github account using your academic e-mail (you can link multiple emails to the account, so you can also add your personal one) and send your git username to your CT (if you don't have one, add it to the recruitment form) . Once you've been invited to the team's Github organization, you can access DMT's repositories. Furthermore, if you have Windows you will need to download Git Bash . Then, you have to properly setup the SSH key to make your computer communicate correctly with the Github portal (both MacOS and Windows) .","title":"GitHub setup"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/01-How-to-get-started/#setting-up-the-ssh-key","text":"Open GitBash for Windows or a terminal for MacOS. Check if you already have an SSH key, using the following command: ls -al ~/.ssh This command lists the files in your .ssh directory, if they exist. By default, the filenames of supported public keys for GitHub are id_rsa.pub , id_ecdsa.pub , id_ed25519.pub . If the list is empty, you have to create a new key . Paste the command below into GitBash , substituting your_email@example.com with your email address. ssh-keygen -t ed25519 -C \"your_email@example.com\" When you're prompted to Enter a file in which to save the key press Enter . This saves the key in the default file and location. At the prompt, type a secure passphrase (it's better to use an empty passphrase) Enter passphrase ( empty for no passphrase ) : [ Type a passphrase ] Enter same passphrase again: [ Type passphrase again ] Ensure the ssh-agent is running or start it manually. eval \" $( ssh-agent -s ) \" Add your SSH private key to the ssh-agent . If you created your key with a different name, or if you are adding an existing key that has a different name, replace id_ed25519 with the name of your private key's file. ssh-add ~/.ssh/id_ed25519 Add the SSH key to your account on GitHub . For more information, see \"Adding a new SSH key to your GitHub account\" . If you encounter any problems, take a look at the Official Github documentation .","title":"Setting up the SSH key"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/01-How-to-get-started/#cloning-the-teams-repo","text":"Go to the vehicle model's repository in the team's GitHub Organization , click on the Code button, copy the link to clone the repository (you'll need it in the upcoming step) . Open Git Bash (Windows) or your Terminal (MacOS) , be sure that you're in the folder in which you want to download the repo (usually it's useful to create a GitHub folder in which you'll download all the repo) Paste the following command to clone the repository: git clone --recurse-submodules git@github.com:eagletrt/fenice-vehicle-model-DMT.git NB: \"git@github.com:eagletrt/fenice-vehicle-model-DMT.git\" is the url of the repository, to clone other repositories you can substitute it with the other repository's url.","title":"Cloning the team's repo:"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/01-How-to-get-started/#matlab-setup","text":"First of all check that you have installed the correct version of MATLAB to avoid incompatibility problems when using the files. NB: This first section is crucial to properly setup MATLAB's environment, in order to execute the model correctly. The following list contains the toolboxes that you have to install manually: Control System Toolbox Curve Fitting Toolbox Digital Signal Processing Embedded Coder Fuzzy Logic Toolbox MATLAB Coder MinGW-w64 C/C++ Compiler ( only for Windows ) Optimization Toolbox Simscape Simscape Electrical Simscape Multibody Simulink Simulink 3D Animation Simulink Coder Simulink Control Design Symbolic Math Toolbox System Identification Toolbox Clothoids (The last toolbox and its documentation can be found at https://github.com/ebertolazzi/Clothoids/releases and can be used instead of the folder Clothoids (used in the old vehicle model) .\\ We suggest to follow the installation instructions the you can find and the previous link , because the toolbox is constantly updated by professor Bertolazzi.\\ During the installation phase, MATLAB may require to install an additional package called LAB Support for MinGW-w64 C/C++ Compiler .","title":"MATLAB Setup"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/01-How-to-get-started/#run-matlabsimulinks-model","text":"Open MATLAB (after the initial setup described above for first time users) Open the local folder where you previously cloned the model's repository from GitHub Now on MATLAB's left column you can open the model's files and folders, particularly the main.m file!","title":"Run MATLAB/Simulink's Model"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/02-main.m/","text":"main.m The main file is main.m Type of Simulation At the beginning of the main there is the possibility to assign the variable mod. Assign a number to the variable mod to decide if you want to perform optimization for torque/slip or a standard simulation There is also the possibility to compare the performance and test velocity estimation algorithms Graphics Choice At the beginning of the main file there is also the possibility to decide which graphics we want to plot. Assign a number to the variable The calling of one type of plot corresponds to the calling of one of the three .m files present in the Utilities folder: plots.m (1: all plots), antislipplot.m (2), torquevectoringplot.m (3). So, if you want to modify graphics to modify plots or add new plots for the specific type of plot chosen modify those files, if you want to add another type of plot you have to create a similar file of them and add another option in the main.m file in the Post Processing section. Parameters The main parameters are in the function getSimulationParams : Maneuver type (First argument: a number between 1 and 12): defined in the vehicle inputs section of the Simulink model and inside getsimulationparams: see dedicated section Control types (Second argument: a number between 1 and 4) Sensor Noise (Third argument: Yes(1) or No(2)) Simulation Time: usually, 10 s for slip optimization/slip comparison is useful to reduce it (acceleration maneuver) we need only the starting behaviour for some tv maneuvers, we need instead to increase it and is automatically set in getsimualtionparam (step cornering and ramp steer have fixed simulation time) also for data follow from test is automatically set Motors and controls maps There is the possibility to change the map for the motors (simulating the map chosen by the driver), which impose a maximum torque to the motors (map values between 1 and 6). In the case of the maximum Torque we have developed a function (motorCurve.m in the folder Vehicle Modules) which limits the motor Torque in function of the angular velocity of the wheels and the selected map of the motor. Map 6 is the map that allows the maximum erogable torque . With the parameters map_tv and map_sc (values between 0 and 1) you can select a different level of intensity of the controller action (simulating the map chosen by the driver on the steering wheel), in this way the pilot can even deactivate a control putting it to the lowest value (map_tv/sc = 0) where the contribution of the control goes to zero. Instead map_tv/sc = 1 impose the maximum level for the controls. Other Sections Parameter initialization for the velocity estimation, slip control, torque vectoring: See dedicated sections Parameters for noise In this section there are some estimated values of the variances of the sensor's noise process; these variances are parameters used in the noise injection in Simulink by a random input process in addition to the sensor's signals in Simulink. The noise is selectable in the input part of the getsimulationparam function. Define initial conditions of the simulation In this section are defined the initial conditions for the simulation and the initial conditions for solving the equations of motion. In particular, initial velocity for some maneuvers. Start simulation There is the if cycle which chooses the type of simulation selected with the variable mod at the beginning of the main.m, with embedded graphic options.","title":"main.m"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/02-main.m/#mainm","text":"The main file is main.m","title":"main.m"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/02-main.m/#type-of-simulation","text":"At the beginning of the main there is the possibility to assign the variable mod. Assign a number to the variable mod to decide if you want to perform optimization for torque/slip or a standard simulation There is also the possibility to compare the performance and test velocity estimation algorithms","title":"Type of Simulation"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/02-main.m/#graphics-choice","text":"At the beginning of the main file there is also the possibility to decide which graphics we want to plot. Assign a number to the variable The calling of one type of plot corresponds to the calling of one of the three .m files present in the Utilities folder: plots.m (1: all plots), antislipplot.m (2), torquevectoringplot.m (3). So, if you want to modify graphics to modify plots or add new plots for the specific type of plot chosen modify those files, if you want to add another type of plot you have to create a similar file of them and add another option in the main.m file in the Post Processing section.","title":"Graphics Choice"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/02-main.m/#parameters","text":"The main parameters are in the function getSimulationParams : Maneuver type (First argument: a number between 1 and 12): defined in the vehicle inputs section of the Simulink model and inside getsimulationparams: see dedicated section Control types (Second argument: a number between 1 and 4) Sensor Noise (Third argument: Yes(1) or No(2)) Simulation Time: usually, 10 s for slip optimization/slip comparison is useful to reduce it (acceleration maneuver) we need only the starting behaviour for some tv maneuvers, we need instead to increase it and is automatically set in getsimualtionparam (step cornering and ramp steer have fixed simulation time) also for data follow from test is automatically set","title":"Parameters"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/02-main.m/#motors-and-controls-maps","text":"There is the possibility to change the map for the motors (simulating the map chosen by the driver), which impose a maximum torque to the motors (map values between 1 and 6). In the case of the maximum Torque we have developed a function (motorCurve.m in the folder Vehicle Modules) which limits the motor Torque in function of the angular velocity of the wheels and the selected map of the motor. Map 6 is the map that allows the maximum erogable torque . With the parameters map_tv and map_sc (values between 0 and 1) you can select a different level of intensity of the controller action (simulating the map chosen by the driver on the steering wheel), in this way the pilot can even deactivate a control putting it to the lowest value (map_tv/sc = 0) where the contribution of the control goes to zero. Instead map_tv/sc = 1 impose the maximum level for the controls.","title":"Motors and controls maps"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/02-main.m/#other-sections","text":"Parameter initialization for the velocity estimation, slip control, torque vectoring: See dedicated sections Parameters for noise In this section there are some estimated values of the variances of the sensor's noise process; these variances are parameters used in the noise injection in Simulink by a random input process in addition to the sensor's signals in Simulink. The noise is selectable in the input part of the getsimulationparam function. Define initial conditions of the simulation In this section are defined the initial conditions for the simulation and the initial conditions for solving the equations of motion. In particular, initial velocity for some maneuvers. Start simulation There is the if cycle which chooses the type of simulation selected with the variable mod at the beginning of the main.m, with embedded graphic options.","title":"Other Sections"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/03-initialization.m/","text":"initialization.m The initialization file is initialization.m In this file there is the definition of the path (folders) useful to Matlab to find all the files during its running. Moreover, there is the graphical message that appears when you launch the simulation and some commands to automatically comment subsections of the Simulink model to allow safe exportation of the C code.","title":"initialization.m"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/03-initialization.m/#initializationm","text":"The initialization file is initialization.m In this file there is the definition of the path (folders) useful to Matlab to find all the files during its running. Moreover, there is the graphical message that appears when you launch the simulation and some commands to automatically comment subsections of the Simulink model to allow safe exportation of the C code.","title":"initialization.m"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/04-Fenice_VehicleModel.slx/","text":"Fenice_VehicleModel.slx The Simulink model is Fenice_VehicleModel.slx The Simulink file is the most important file of the entire model. In the file we have 3 main blocks: the Input block, vehicle model block and the control block. To enter in one of this block you can double click on it or use the tent menu in the upperleft part of the simulink window. Since the controls work at a step size of 10ms we need a resample block in order to resample the data from a 1ms step size to 10ms step size. Input block The vehicle model in order to work needs 3 input values that are the steering angle (transformed in radians after input block), break (values between 0 and 1), throttle (values between 0 and 1). In the input block we can recreate different maneuvers by setting directly the 3 input variables using a signal generator. Alternatively, we can set the desired velocity using a signal generator that enters into a cruise control in order to get the break and throttle signal. In the block we have 12 maneuvers that can be selected directly in the main.m file. STRAIGHT LINE MANEUVERS: We must have a straight line, otherwise something is wrong 1) Straight line : No driver input (delta, throttle,brake), initial speed ( v_init defined in main) [suggested t_f=5-10 s]. 2) Contant speed : Cruise control on desired speed (v_init), no steering [suggested t_f = 5-10 s] 3) Acceleration : Full throttle from standing start, for slip optimization use t_f lower than 5 s 4) Braking : Acceleration from 0 to 100km/h, at t=5s brake until the car stops. NEED A REVIEW STEERING MANEUVERS 5) Double line change : Two sharp lane changes at t=4s and t=8s at cruise speed set in the main with V_init and delta_des set in getsimulationparam. T_f suggested 10 s 6) Step cornering : Sharp turn (step) [need t_f very high, so it is fixed in getsimparam]. After starting to turn the steering isconstant so the car has to perform circles (v des set in getsimand V_init taken in the main) 7) Ramp steer : Progressive steering increase from straight to max angle (first part is a spiral, then with constant steering the second part is made by circles [t_f fixed at 15 s directly in getsimparam) 8) Line keeping: Deviation from a line starts at velocity v_init (set in the main) up to v_des reached with a ramp of 3 second. At 3 sec the car steers with an angle delta_des and then counter-steers to return to the initial line (v_des, delta_des set in getsimulationparam) 9) Sine steer : Sinusoidal steering input (parameter impose in getsimulationparam) with constant longitudinal speed (equal to v_init, set in the main file) OTHER MANEUVERS 10) As an input we can also use the Data Follower (Maneuver 10) using the data measured on track tests that can be found in the Tests folder. The data must be filtered and cut using the repository for the data analysis. The test file is chosen interactively when the aneuver is started by the user. 11) Logitech Cruise Control : not used anymore 12) For Torque Vectoring optimization the aneuver to use is 12, can be tested also with standard simulation, with v_init take in the main and delta_des in get simulationparam. Otherwise, if we are performing a tuning of TV the parameters are set in tune_PID_for_TV_v 13) Inertia Simulation : maneuever used for analising the benefits of having on-board brakes or motors. Sinusoidal steering with increasing frequency (steering angle and sinusoidal frequency have to be specified in the file Performance_comparison/inertia_comparison.m). Controller block In the control block we have the velocity estimation and 4 blocks: slip control and torque vectoring together, only torque vectoring, only slip control and no control. The 4 blocks have all the same inputs that come from the vehicle model block, input block and velocity estimation. They can be selected directly in the main.m file. For the description of the two controls read the respective pdf files. The output of the control block provides the two motor torques. An important note, the implementation of this routing is mandatory: all the inputs must flow inside each controller, only after the controller blocks there must be the case function, the reason lies on the Simulink to C exportation procedure. Velocity estimation (inside controller block) Three different algorithms have been developed for the velocity estimation: - Panzani algorithm : to take the most reliable information from different sensors (encoders and accelerometers) we have implemented a complementary filter in the frequency domain. The main idea is to take the velocity of the tires and rely on them for the low frequency information (using a low pass filter), instead for the high frequency (using a high pass filter) can rely on the longitudinal acceleration of the car. The estimated speed is the sum of high and low frequency components. - Savaresi algorithm : The algorithm considers 4 states of the car: very low speed, accelerating, constant speed (or softly braking) and braking. Each one relies on different data to estimate the velocity. This algorithm considers the angular velocity of all the wheel. NEED A REVIEW - Raw algorithm : simply the angular velocity * radius of the front wheels. In this block are computed also the maps for the motors to allow an easier code exportation (velocity estimation + maps together). Vehicle model block The vehicle model block is the main block of the model. In this block we can find the 10 Dof vehicle model. This block uses the equation of motion copied from the Maple file and collects all models that can be found in the Vehicle modules folder. From the 10 Dof model we get all the important states of the car like the acceleration, velocity, position but also values of the forces, torques that can be used as output values. The inputs of this block are the torque of the two motors, the steering angle, and the brake signal.","title":"Fenice_VehicleModel.slx"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/04-Fenice_VehicleModel.slx/#fenice_vehiclemodelslx","text":"The Simulink model is Fenice_VehicleModel.slx The Simulink file is the most important file of the entire model. In the file we have 3 main blocks: the Input block, vehicle model block and the control block. To enter in one of this block you can double click on it or use the tent menu in the upperleft part of the simulink window. Since the controls work at a step size of 10ms we need a resample block in order to resample the data from a 1ms step size to 10ms step size.","title":"Fenice_VehicleModel.slx"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/04-Fenice_VehicleModel.slx/#input-block","text":"The vehicle model in order to work needs 3 input values that are the steering angle (transformed in radians after input block), break (values between 0 and 1), throttle (values between 0 and 1). In the input block we can recreate different maneuvers by setting directly the 3 input variables using a signal generator. Alternatively, we can set the desired velocity using a signal generator that enters into a cruise control in order to get the break and throttle signal. In the block we have 12 maneuvers that can be selected directly in the main.m file. STRAIGHT LINE MANEUVERS: We must have a straight line, otherwise something is wrong 1) Straight line : No driver input (delta, throttle,brake), initial speed ( v_init defined in main) [suggested t_f=5-10 s]. 2) Contant speed : Cruise control on desired speed (v_init), no steering [suggested t_f = 5-10 s] 3) Acceleration : Full throttle from standing start, for slip optimization use t_f lower than 5 s 4) Braking : Acceleration from 0 to 100km/h, at t=5s brake until the car stops. NEED A REVIEW STEERING MANEUVERS 5) Double line change : Two sharp lane changes at t=4s and t=8s at cruise speed set in the main with V_init and delta_des set in getsimulationparam. T_f suggested 10 s 6) Step cornering : Sharp turn (step) [need t_f very high, so it is fixed in getsimparam]. After starting to turn the steering isconstant so the car has to perform circles (v des set in getsimand V_init taken in the main) 7) Ramp steer : Progressive steering increase from straight to max angle (first part is a spiral, then with constant steering the second part is made by circles [t_f fixed at 15 s directly in getsimparam) 8) Line keeping: Deviation from a line starts at velocity v_init (set in the main) up to v_des reached with a ramp of 3 second. At 3 sec the car steers with an angle delta_des and then counter-steers to return to the initial line (v_des, delta_des set in getsimulationparam) 9) Sine steer : Sinusoidal steering input (parameter impose in getsimulationparam) with constant longitudinal speed (equal to v_init, set in the main file) OTHER MANEUVERS 10) As an input we can also use the Data Follower (Maneuver 10) using the data measured on track tests that can be found in the Tests folder. The data must be filtered and cut using the repository for the data analysis. The test file is chosen interactively when the aneuver is started by the user. 11) Logitech Cruise Control : not used anymore 12) For Torque Vectoring optimization the aneuver to use is 12, can be tested also with standard simulation, with v_init take in the main and delta_des in get simulationparam. Otherwise, if we are performing a tuning of TV the parameters are set in tune_PID_for_TV_v 13) Inertia Simulation : maneuever used for analising the benefits of having on-board brakes or motors. Sinusoidal steering with increasing frequency (steering angle and sinusoidal frequency have to be specified in the file Performance_comparison/inertia_comparison.m).","title":"Input block"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/04-Fenice_VehicleModel.slx/#controller-block","text":"In the control block we have the velocity estimation and 4 blocks: slip control and torque vectoring together, only torque vectoring, only slip control and no control. The 4 blocks have all the same inputs that come from the vehicle model block, input block and velocity estimation. They can be selected directly in the main.m file. For the description of the two controls read the respective pdf files. The output of the control block provides the two motor torques. An important note, the implementation of this routing is mandatory: all the inputs must flow inside each controller, only after the controller blocks there must be the case function, the reason lies on the Simulink to C exportation procedure.","title":"Controller block"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/04-Fenice_VehicleModel.slx/#velocity-estimation-inside-controller-block","text":"Three different algorithms have been developed for the velocity estimation: - Panzani algorithm : to take the most reliable information from different sensors (encoders and accelerometers) we have implemented a complementary filter in the frequency domain. The main idea is to take the velocity of the tires and rely on them for the low frequency information (using a low pass filter), instead for the high frequency (using a high pass filter) can rely on the longitudinal acceleration of the car. The estimated speed is the sum of high and low frequency components. - Savaresi algorithm : The algorithm considers 4 states of the car: very low speed, accelerating, constant speed (or softly braking) and braking. Each one relies on different data to estimate the velocity. This algorithm considers the angular velocity of all the wheel. NEED A REVIEW - Raw algorithm : simply the angular velocity * radius of the front wheels. In this block are computed also the maps for the motors to allow an easier code exportation (velocity estimation + maps together).","title":"Velocity estimation (inside controller block)"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/04-Fenice_VehicleModel.slx/#vehicle-model-block","text":"The vehicle model block is the main block of the model. In this block we can find the 10 Dof vehicle model. This block uses the equation of motion copied from the Maple file and collects all models that can be found in the Vehicle modules folder. From the 10 Dof model we get all the important states of the car like the acceleration, velocity, position but also values of the forces, torques that can be used as output values. The inputs of this block are the torque of the two motors, the steering angle, and the brake signal.","title":"Vehicle model block"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/05-Slip_Control-%28Folder%29/","text":"Slip_Control (Folder) The Slip Control folder is Slip_Control Optimization: Set the value of mod = 2 in the main In main.m you can change the arguments of getsimulationparams. The PI coefficients of the slip controller are tuned in order to find the maximum velocity of the selected test, starting from different initial velocities, so it is a good choice to select the acceleration maneuver (3 in getsimulationparam, with a low simulation time Ts \\< 5). Run main.m (for changes see the section \u2018 Useful files and possible changes\u2019 ) Useful files and possible changes: Vehicle_Modules/PajeckaModel_Tyres: it contains the model for the longitudinal simulation of the slip and a very useful script for analyze the peak value of the longitudinal force (lambda ref) and all the tyres curves (also lateral and combined) Slip_Control (folder): it contains the files for performing the optimization of the parameters (tuning) of the controller Utilities/Antislipplot.m: plot procedure for plotting the relevant outputs from the simulation main.m : In main.m there is the variable mod for imposing the optimization (mod = 2) or a standard simulation (mod = 1). Under section \u2018Simulation parameters\u2019 you can change the parameters of the simulation (the most common maneuver for the slip control is the acceleration maneuver, you can simulate with only the slip controller active of both, you can also simulate noise but this will also influence the steering angle so the car will turn, the final time should stay under 8 because in the acceleration maneuver the car will start to brake because of the definition of the maneuver), under \u2018Parameters for the slip control\u2019 you can change the intensity of the controller actions and the reference values for the optimization and under \u2018Define initial conditions for the simulation\u2019 you can change the initial velocity but pay attention that at low velocities the simulation has problems. Tune_PI_for_slip.m : you can change the options of the minimization if you want to get useful results (increase the MaxIteration), then you can also change the initial guesses and the parameters of the simulation. The results are stored in Slip_Control/Slip_Test/sc_try.txt, if you want to use these results to see the behaviour of the system or to actually make them the default for the controller then make a copy of this file and call it optimized_coeff_antislip.txt in the Slip_Control folder, but make sure to keep the old version safe somewhere else. (or change in the main.m file the name of the PID_Gain_Scheduling file with the one you want to try) Fenice_VehicleModel.slx: in Vehicle Controller/Slip Control there is the whole controller logic and there are different controllers that can be used just by substituting one of the commented blocks with the default one ( the default one is the most used ). Note: for the optimization we must use the simplest one that is called \u2018Low-level slip control for optimization\u2019, the best results can be obtained with the default \u2018Low-level Slip Control\u2019, \u2018Cascade Slip Control\u2019 does not work. Inside the default controller the parameters of the integral and proportional gains are taken from a table which is the result of the optimization of the performances at different velocities. Tyres: Pacejka curves Pacejka curves are VERY important for the longitudinal and lateral dynamics of the car: they affect longitudinal and lateral forces and so control actions. Previously there were two types of modelling curves: the new and the old one, the first is the one validated by Matteo Tomasi\u2019s thesis (and it\u2019s simpler, less coefficient in modelling), instead the latter is the one given by Hoosier fitting and it\u2019s more complete. Nowadays inside Vehicle_Modules/PajeckaModel_Tyres you can find all the updated files for the Pacejka curves. These files are provided by PhD student Matteo Larcher and have been introduced to solve all the problems related to the various maneuvers and instability of the machine in certain situations. Inside this folder, there are 3 files referring to different tyre sets fitting from the data provided by the Tyre Testing Consortium. It\u2019s essential to have a perfect tir file to avoid problem with the whole model (attention high risks of modello sborato!!!!!!!) To change the type of curve for the tyre you have to change the loading of the files of the Pacejka model in the following files: 1) Main.m (by changing the variable \u201cpacejkaParams\u201d) Open problems: We are changing tyres and car, so we need the new data fitting We can improve the combinate behaviour of the tir file Notes about slip optimization The anti-slip optimization script works well with V_init >= 5 and a step of 10km/k between the simulation is the sweet spot. The suggested initial conditions are: x0 = [200,2000]; %starting conditions x0 = [Kp, Ki] lb = [10,800]; %lower bounds ub = [300,3000]; %upper bounds I suggest performing the last simulation with V_init around 60 or 70 km/h, as at such speed the wheels are not slipping anymore so we can just copy and paste the coefficients of the last simulation for higher speeds. If the oscillations of the torque are too high lowering the value of Ki can be a solution. With V_init < 5 the simulation performs worse (there is a sort of \"change of behaviour\" of the torque), so a separate simulations is advised with the following initial conditions: x0 = [180,100]; lb = [10,10]; ub = [300,1000]; The results are decent but the performance is about 10% less relative to a \"manual\" optimization (aka just play with the coefficients until you find the best parameters), which is the suggested methodology at low speeds. (I noticed that the graph of the performance in function of Kp and Ki is very \"noisy\" and the non linear optimization function doesn't work well in this condition). For the manual optimization just disconnect the tables from the PI controller and use two variable blocks instead (for both wheels!). Now just put everything in a single .txt file and follow the instructions on the wiki! WARNING! If you want to do an acceleration maneuvre (mod = 1, maneuvre = 3) with V_init =! 0 you have to comment this portion of code in the main.m script otherwise the initil velocity will remain zero. if F ~= 1 && F ~= 2 && F ~= 5 && F ~= 6 && F ~= 8 && F ~= 9 && F ~= 12 && F ~= 13 V_init = 0; % [km/h] elseif F == 10 V_init = test.V_L(1); end","title":"Slip_Control (Folder)"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/05-Slip_Control-%28Folder%29/#slip_control-folder","text":"The Slip Control folder is Slip_Control","title":"Slip_Control (Folder)"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/05-Slip_Control-%28Folder%29/#optimization","text":"Set the value of mod = 2 in the main In main.m you can change the arguments of getsimulationparams. The PI coefficients of the slip controller are tuned in order to find the maximum velocity of the selected test, starting from different initial velocities, so it is a good choice to select the acceleration maneuver (3 in getsimulationparam, with a low simulation time Ts \\< 5). Run main.m (for changes see the section \u2018 Useful files and possible changes\u2019 ) Useful files and possible changes: Vehicle_Modules/PajeckaModel_Tyres: it contains the model for the longitudinal simulation of the slip and a very useful script for analyze the peak value of the longitudinal force (lambda ref) and all the tyres curves (also lateral and combined) Slip_Control (folder): it contains the files for performing the optimization of the parameters (tuning) of the controller Utilities/Antislipplot.m: plot procedure for plotting the relevant outputs from the simulation main.m : In main.m there is the variable mod for imposing the optimization (mod = 2) or a standard simulation (mod = 1). Under section \u2018Simulation parameters\u2019 you can change the parameters of the simulation (the most common maneuver for the slip control is the acceleration maneuver, you can simulate with only the slip controller active of both, you can also simulate noise but this will also influence the steering angle so the car will turn, the final time should stay under 8 because in the acceleration maneuver the car will start to brake because of the definition of the maneuver), under \u2018Parameters for the slip control\u2019 you can change the intensity of the controller actions and the reference values for the optimization and under \u2018Define initial conditions for the simulation\u2019 you can change the initial velocity but pay attention that at low velocities the simulation has problems. Tune_PI_for_slip.m : you can change the options of the minimization if you want to get useful results (increase the MaxIteration), then you can also change the initial guesses and the parameters of the simulation. The results are stored in Slip_Control/Slip_Test/sc_try.txt, if you want to use these results to see the behaviour of the system or to actually make them the default for the controller then make a copy of this file and call it optimized_coeff_antislip.txt in the Slip_Control folder, but make sure to keep the old version safe somewhere else. (or change in the main.m file the name of the PID_Gain_Scheduling file with the one you want to try) Fenice_VehicleModel.slx: in Vehicle Controller/Slip Control there is the whole controller logic and there are different controllers that can be used just by substituting one of the commented blocks with the default one ( the default one is the most used ). Note: for the optimization we must use the simplest one that is called \u2018Low-level slip control for optimization\u2019, the best results can be obtained with the default \u2018Low-level Slip Control\u2019, \u2018Cascade Slip Control\u2019 does not work. Inside the default controller the parameters of the integral and proportional gains are taken from a table which is the result of the optimization of the performances at different velocities.","title":"Optimization:"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/05-Slip_Control-%28Folder%29/#tyres-pacejka-curves","text":"Pacejka curves are VERY important for the longitudinal and lateral dynamics of the car: they affect longitudinal and lateral forces and so control actions. Previously there were two types of modelling curves: the new and the old one, the first is the one validated by Matteo Tomasi\u2019s thesis (and it\u2019s simpler, less coefficient in modelling), instead the latter is the one given by Hoosier fitting and it\u2019s more complete. Nowadays inside Vehicle_Modules/PajeckaModel_Tyres you can find all the updated files for the Pacejka curves. These files are provided by PhD student Matteo Larcher and have been introduced to solve all the problems related to the various maneuvers and instability of the machine in certain situations. Inside this folder, there are 3 files referring to different tyre sets fitting from the data provided by the Tyre Testing Consortium. It\u2019s essential to have a perfect tir file to avoid problem with the whole model (attention high risks of modello sborato!!!!!!!) To change the type of curve for the tyre you have to change the loading of the files of the Pacejka model in the following files: 1) Main.m (by changing the variable \u201cpacejkaParams\u201d) Open problems: We are changing tyres and car, so we need the new data fitting We can improve the combinate behaviour of the tir file","title":"Tyres: Pacejka curves"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/05-Slip_Control-%28Folder%29/#notes-about-slip-optimization","text":"The anti-slip optimization script works well with V_init >= 5 and a step of 10km/k between the simulation is the sweet spot. The suggested initial conditions are: x0 = [200,2000]; %starting conditions x0 = [Kp, Ki] lb = [10,800]; %lower bounds ub = [300,3000]; %upper bounds I suggest performing the last simulation with V_init around 60 or 70 km/h, as at such speed the wheels are not slipping anymore so we can just copy and paste the coefficients of the last simulation for higher speeds. If the oscillations of the torque are too high lowering the value of Ki can be a solution. With V_init < 5 the simulation performs worse (there is a sort of \"change of behaviour\" of the torque), so a separate simulations is advised with the following initial conditions: x0 = [180,100]; lb = [10,10]; ub = [300,1000]; The results are decent but the performance is about 10% less relative to a \"manual\" optimization (aka just play with the coefficients until you find the best parameters), which is the suggested methodology at low speeds. (I noticed that the graph of the performance in function of Kp and Ki is very \"noisy\" and the non linear optimization function doesn't work well in this condition). For the manual optimization just disconnect the tables from the PI controller and use two variable blocks instead (for both wheels!). Now just put everything in a single .txt file and follow the instructions on the wiki!","title":"Notes about slip optimization"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/05-Slip_Control-%28Folder%29/#warning","text":"If you want to do an acceleration maneuvre (mod = 1, maneuvre = 3) with V_init =! 0 you have to comment this portion of code in the main.m script otherwise the initil velocity will remain zero. if F ~= 1 && F ~= 2 && F ~= 5 && F ~= 6 && F ~= 8 && F ~= 9 && F ~= 12 && F ~= 13 V_init = 0; % [km/h] elseif F == 10 V_init = test.V_L(1); end","title":"WARNING!"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/06-Torque_Vectoring-%28Folder%29/","text":"Torque_Vectoring (Folder) The Torque Vectoring (Folder) is Torque_Vectoring PI Controller To set active impose pi_or_fuzzy = 1 in the main.m file All the most important informations are inside the Torque Vectoring folder and in the main Executing the optimization of the PI controller: Modify tune_PID_for_TV.m (and save): modify target crossover frequency, phase margin ecc\u2026 (make sure to save a backup of the default file) Run main.m with mod = 3 and set getsimulationparam (control 3, maneuver 12, a good choice for the time of the simulation can be Ts = 10 s) The simulation creates a new file TV_PI_PM%%_COF%%.txt that has all the gain for the desired filter (inside the folder Torque_Vectoring_test). If the optimization results are very good (good tracking of the step) update the main in the section Parameters for Torque Vectoring : use the name of the new file .txt, but make sure to keep the default version safe somewhere else because the file that is there now has already good results. Useful files and possible changes: main.m: under section \u2018Simulation parameters\u2019 you can change the parameters of the simulation/optimization. You can also set the mod = 3 to start optimization or mod = 1 for a standard simulation Fenice_VehicleModel.slx: in Vehicle Controller/Torque Vectoring there is the whole controller logic and there are different controllers. Inside the PI controller the parameters of the integral and proportional gains are taken from a table which is the result of the optimization of the performances at different velocities. Torque_Vectoring: is the folder that contains all the files for the optimization. For trying new parameters open the file tune_PID_for_TV.m in which you can modify target crossover frequency, phase margin ecc\u2026 1) Then run the simulation with main.m and mod = 3 (it\u2019s connected to Fenice_VehicleModel.slx a Simulink model of the car for tuning). 2) The simulation creates a new file TV_PI_PM%%_COF%%_test.txt that has all the gain for the desired filter. This file is stored in the subfolder Torque_Vectoring/PI/PI_Test. If you want to use these results, correct the main file in the section Parameters for Torque Vectoring (as described above in the optimization section). Fuzzy Controller to set active impose pi_or_fuzzy = 2; in the main.m file The fuzzy logic takes membership function to describe i/o relation. In particular the membership functions are in TV_fuzzy.fis or TV_fuzzy_sideslip.fis (the second file contains also a relation with the side slip angle, the first file is a simplified version of the second). To see or modify them, use from command window the command fuzzyLogicDesigner and import the file in it. Then you can modify membership function shape and also, I/O relation using the rules option. There is a paper in the library of google drive in which are described the membership function and the rules chosen Handling curves (k_us folder inside Torque_Vectoring) To analyze the handling curves and the understeering gradient Kus use mod == 6 in the main.m file. Definition of understeer and oversteer: https://www.youtube.com/watch?v=EQWPumtDXk0 The variable \"handling_curves\" is the difference between the steer angle (\"delta_des\" variable in the script) and the Ackermann steer (the angle needed for the same manoeuvre at low speed, so without understeer or oversteer, which in the small angle approximation is simply R/L and R is calculated with the formula ang vel / tang vel). Defining this difference is useful because it can be found in the underseer gradient (K) definition: The vehicle has a positive understeer gradient if the difference between required steer and the Ackermann steer increases with respect to incremental increases in lateral acceleration. The vehicle has a negative gradient if the difference in steer decreases with respect to incremental increases in lateral acceleration. (from wikipedia) More precisely K is the derivative of the steer angle - lateral acceleration graph (see figure), which can be approximated with a straight line y = Kx + c, where y = steer angle, x = lateral acceleration and K (the pendence of the line) is the understeer gradient. The linear model isn't perfect but it's simple and effective on averaging the behaviour over different steering angles. The script uses the variable \"handling_curves\" instead of the steering angle, which are the same things except an additive costant, but using \"handling_curves\" can be useful for referring to the wikipedia definition. regarding this line of code: [handling_curve_sel,acceleration_ss_sel] = SelectHandlingZone(handling_curve,acceleration_ss,0.5 9.81,0.1 9.81); Here we are removing the elements of the lateral acceleration array which are outside the range 0.1 g < a_l < 0.5 g. The condition 0.1 g < a_l is useful to avoid weird behaviours while the condition a_l < 0.5 g should not allow the car to spin or something along this line. The array \"handling_curves\" is cropped in the same way so the data can be plotted.","title":"Torque_Vectoring (Folder)"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/06-Torque_Vectoring-%28Folder%29/#torque_vectoring-folder","text":"The Torque Vectoring (Folder) is Torque_Vectoring","title":"Torque_Vectoring (Folder)"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/06-Torque_Vectoring-%28Folder%29/#pi-controller","text":"To set active impose pi_or_fuzzy = 1 in the main.m file All the most important informations are inside the Torque Vectoring folder and in the main Executing the optimization of the PI controller: Modify tune_PID_for_TV.m (and save): modify target crossover frequency, phase margin ecc\u2026 (make sure to save a backup of the default file) Run main.m with mod = 3 and set getsimulationparam (control 3, maneuver 12, a good choice for the time of the simulation can be Ts = 10 s) The simulation creates a new file TV_PI_PM%%_COF%%.txt that has all the gain for the desired filter (inside the folder Torque_Vectoring_test). If the optimization results are very good (good tracking of the step) update the main in the section Parameters for Torque Vectoring : use the name of the new file .txt, but make sure to keep the default version safe somewhere else because the file that is there now has already good results. Useful files and possible changes: main.m: under section \u2018Simulation parameters\u2019 you can change the parameters of the simulation/optimization. You can also set the mod = 3 to start optimization or mod = 1 for a standard simulation Fenice_VehicleModel.slx: in Vehicle Controller/Torque Vectoring there is the whole controller logic and there are different controllers. Inside the PI controller the parameters of the integral and proportional gains are taken from a table which is the result of the optimization of the performances at different velocities. Torque_Vectoring: is the folder that contains all the files for the optimization. For trying new parameters open the file tune_PID_for_TV.m in which you can modify target crossover frequency, phase margin ecc\u2026 1) Then run the simulation with main.m and mod = 3 (it\u2019s connected to Fenice_VehicleModel.slx a Simulink model of the car for tuning). 2) The simulation creates a new file TV_PI_PM%%_COF%%_test.txt that has all the gain for the desired filter. This file is stored in the subfolder Torque_Vectoring/PI/PI_Test. If you want to use these results, correct the main file in the section Parameters for Torque Vectoring (as described above in the optimization section).","title":"PI Controller"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/06-Torque_Vectoring-%28Folder%29/#fuzzy-controller","text":"to set active impose pi_or_fuzzy = 2; in the main.m file The fuzzy logic takes membership function to describe i/o relation. In particular the membership functions are in TV_fuzzy.fis or TV_fuzzy_sideslip.fis (the second file contains also a relation with the side slip angle, the first file is a simplified version of the second). To see or modify them, use from command window the command fuzzyLogicDesigner and import the file in it. Then you can modify membership function shape and also, I/O relation using the rules option. There is a paper in the library of google drive in which are described the membership function and the rules chosen","title":"Fuzzy Controller"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/06-Torque_Vectoring-%28Folder%29/#handling-curves","text":"(k_us folder inside Torque_Vectoring) To analyze the handling curves and the understeering gradient Kus use mod == 6 in the main.m file. Definition of understeer and oversteer: https://www.youtube.com/watch?v=EQWPumtDXk0 The variable \"handling_curves\" is the difference between the steer angle (\"delta_des\" variable in the script) and the Ackermann steer (the angle needed for the same manoeuvre at low speed, so without understeer or oversteer, which in the small angle approximation is simply R/L and R is calculated with the formula ang vel / tang vel). Defining this difference is useful because it can be found in the underseer gradient (K) definition: The vehicle has a positive understeer gradient if the difference between required steer and the Ackermann steer increases with respect to incremental increases in lateral acceleration. The vehicle has a negative gradient if the difference in steer decreases with respect to incremental increases in lateral acceleration. (from wikipedia) More precisely K is the derivative of the steer angle - lateral acceleration graph (see figure), which can be approximated with a straight line y = Kx + c, where y = steer angle, x = lateral acceleration and K (the pendence of the line) is the understeer gradient. The linear model isn't perfect but it's simple and effective on averaging the behaviour over different steering angles. The script uses the variable \"handling_curves\" instead of the steering angle, which are the same things except an additive costant, but using \"handling_curves\" can be useful for referring to the wikipedia definition. regarding this line of code: [handling_curve_sel,acceleration_ss_sel] = SelectHandlingZone(handling_curve,acceleration_ss,0.5 9.81,0.1 9.81); Here we are removing the elements of the lateral acceleration array which are outside the range 0.1 g < a_l < 0.5 g. The condition 0.1 g < a_l is useful to avoid weird behaviours while the condition a_l < 0.5 g should not allow the car to spin or something along this line. The array \"handling_curves\" is cropped in the same way so the data can be plotted.","title":"Handling curves"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/07-Velocity-estimation-%28Folder%29/","text":"Velocity estimation (Folder) The Velocity Estimation Folder is Velocity estimation Algorithms for velocity estimation Three different algorithms have been developed for the velocity estimation: Panzani algorithm : to take the most reliable information from different sensors (encoders and accelerometers) we have implemented a complementary filter in the frequency domain. The main idea is to take the velocity of the tires and rely on them for the low frequency information (using a low pass filter), instead for the high frequency (using a high pass filter) can rely on the longitudinal acceleration of the car. The estimated speed is the sum of high and low frequency components. Savaresi algorithm : The algorithm considers 4 states of the car: very low speed, accelerating, constant speed (or softly braking) and braking. Each one relies on different data to estimate the velocity. This algorithm considers the angular velocity of all the wheel. NEED A REVIEW Raw algorithm : simply the angular velocity radius of the front wheels. The default algorithm used in the simulation is the Panzani algorithm because it is more reliable in terms of following the data collected with the GPS in the different tests. Velocity estimation algorithm in the main file: Selection of the velocity estimation algorithm: In the file main.m in the section \u201c Parameter initialization for the velocity estimation \u201d you can set a different value for the variable \u201c vel_alg \u201d which is taken as an input from the function \u201c choose_velocity_est_algorithm \u201d. In the section for velocity estimation of the main, it\u2019s also called a function velocity_filter in which are defined the filters for Panzani and Savaresi alg. Also, in this section you find S_prev = - 2 which set the initial state for the Savaresi algorithm. Comparison of the algorithms: At the beginning of main.m, selecting mod = 5 , you perform the comparison between the 3 different algorithms for V.E. (it automatically calls the function velocity_est_test ) Velocity estimation folder choose_velocity_est_algorithm : uncomments only the algorithm chosen in the main file with the variable vel_alg velocity_est_test : file launched with mod = 5: compares the algorithms estimation velocity_filter : definition of the filter for Panzani and Savaresi, used both in velocity_est_test and in standard simulations. Notes: The cut of frequency of the transfer functions H for the complementary filter (Panzani) and the one for the smoothing of the acceleration data for Savaresi, defined in velocity_filter can be tuned again as soon as we will have other tests. Open work Savaresi must be filtered more accurately","title":"Velocity estimation (Folder)"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/07-Velocity-estimation-%28Folder%29/#velocity-estimation-folder","text":"The Velocity Estimation Folder is Velocity estimation","title":"Velocity estimation (Folder)"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/07-Velocity-estimation-%28Folder%29/#algorithms-for-velocity-estimation","text":"Three different algorithms have been developed for the velocity estimation: Panzani algorithm : to take the most reliable information from different sensors (encoders and accelerometers) we have implemented a complementary filter in the frequency domain. The main idea is to take the velocity of the tires and rely on them for the low frequency information (using a low pass filter), instead for the high frequency (using a high pass filter) can rely on the longitudinal acceleration of the car. The estimated speed is the sum of high and low frequency components. Savaresi algorithm : The algorithm considers 4 states of the car: very low speed, accelerating, constant speed (or softly braking) and braking. Each one relies on different data to estimate the velocity. This algorithm considers the angular velocity of all the wheel. NEED A REVIEW Raw algorithm : simply the angular velocity radius of the front wheels. The default algorithm used in the simulation is the Panzani algorithm because it is more reliable in terms of following the data collected with the GPS in the different tests. Velocity estimation algorithm in the main file: Selection of the velocity estimation algorithm: In the file main.m in the section \u201c Parameter initialization for the velocity estimation \u201d you can set a different value for the variable \u201c vel_alg \u201d which is taken as an input from the function \u201c choose_velocity_est_algorithm \u201d. In the section for velocity estimation of the main, it\u2019s also called a function velocity_filter in which are defined the filters for Panzani and Savaresi alg. Also, in this section you find S_prev = - 2 which set the initial state for the Savaresi algorithm. Comparison of the algorithms: At the beginning of main.m, selecting mod = 5 , you perform the comparison between the 3 different algorithms for V.E. (it automatically calls the function velocity_est_test )","title":"Algorithms for velocity estimation"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/07-Velocity-estimation-%28Folder%29/#velocity-estimation-folder_1","text":"choose_velocity_est_algorithm : uncomments only the algorithm chosen in the main file with the variable vel_alg velocity_est_test : file launched with mod = 5: compares the algorithms estimation velocity_filter : definition of the filter for Panzani and Savaresi, used both in velocity_est_test and in standard simulations. Notes: The cut of frequency of the transfer functions H for the complementary filter (Panzani) and the one for the smoothing of the acceleration data for Savaresi, defined in velocity_filter can be tuned again as soon as we will have other tests. Open work Savaresi must be filtered more accurately","title":"Velocity estimation folder"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/08-Performance-Comparison/","text":"Performance Comparison The Peformance comparison folder is Performance_comparison The performance comparison simulation runs two different simulations with two different control system setups choosen with interactive tent menu The comparison runs the selected maneuver for both setups and elaborate a different comparison according to the type of maneuver (straight (man 3) or steering (manuevers from 5 to 9 and maneuver 12). Control comparison Straigth maneuver For straight maneuver the only useful maneuver is the 3 (acceleration), to test the quality of the slip control. Steeering maneuvers For steering maneuver the useful maneuvers are 5-6-7-8-9-12,to test the quality of the torque vectoring control. PI/Fuzzy comparison for Toque Vectoring With this comparison you can study the performance of Pi or Fuzzy Controller for Torque Vectoring with all control active or with only Torque Vectoring. ( only for steering maneuvers ) Inertia simulation Simulation used to test the performance of on-board brakes and motors. Aero kit comparison Simulation used to test the performance of the car with different aero kits. A brief explanation on the simulation: we put as input the desired profile velocity u and the desired steering behavior delta, then the model calculates everything: on this model point of view you will find that there is an improvement in position reached (because time of simulation is fixed). Check in Vehicle_data.mat the aero coefficient (these will be given to you by MT team) Run main.m having in mind: What type of coefficient you have on vehicle data ( with or without kit) What type of maneuver you want (in this case you will find the step corner maneuver without any type of control -> you can change it by main.m parameter, see further explanations on that file or the relative report) Once you have run the maneuver, save the workspace with the data of the simulation ( for ex. without kit) After you change the coefficients in vehicle_data, repeat the maneuver and save again the workspace (for ex .with kit) Note: at the end you have to get the files senzakit.mat and conkit.mat into the folder Performance_comparison/Aero_comparison Open main.m and select mod = 4 in order to be able to select this type of comparison. Run and you will obtain the graphics you want. P.S. in this folder you will find also some images of the inputs (u and delta of the step corner maneuver used) and the real paths coming from main ( they are the same you will obtain as trajectory in the comparison, but this time coming from main).","title":"Performance Comparison"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/08-Performance-Comparison/#performance-comparison","text":"The Peformance comparison folder is Performance_comparison The performance comparison simulation runs two different simulations with two different control system setups choosen with interactive tent menu The comparison runs the selected maneuver for both setups and elaborate a different comparison according to the type of maneuver (straight (man 3) or steering (manuevers from 5 to 9 and maneuver 12).","title":"Performance Comparison"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/08-Performance-Comparison/#control-comparison","text":"","title":"Control comparison"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/08-Performance-Comparison/#straigth-maneuver","text":"For straight maneuver the only useful maneuver is the 3 (acceleration), to test the quality of the slip control.","title":"Straigth maneuver"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/08-Performance-Comparison/#steeering-maneuvers","text":"For steering maneuver the useful maneuvers are 5-6-7-8-9-12,to test the quality of the torque vectoring control.","title":"Steeering maneuvers"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/08-Performance-Comparison/#pifuzzy-comparison-for-toque-vectoring","text":"With this comparison you can study the performance of Pi or Fuzzy Controller for Torque Vectoring with all control active or with only Torque Vectoring. ( only for steering maneuvers )","title":"PI/Fuzzy comparison for Toque Vectoring"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/08-Performance-Comparison/#inertia-simulation","text":"Simulation used to test the performance of on-board brakes and motors.","title":"Inertia simulation"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/08-Performance-Comparison/#aero-kit-comparison","text":"Simulation used to test the performance of the car with different aero kits. A brief explanation on the simulation: we put as input the desired profile velocity u and the desired steering behavior delta, then the model calculates everything: on this model point of view you will find that there is an improvement in position reached (because time of simulation is fixed). Check in Vehicle_data.mat the aero coefficient (these will be given to you by MT team) Run main.m having in mind: What type of coefficient you have on vehicle data ( with or without kit) What type of maneuver you want (in this case you will find the step corner maneuver without any type of control -> you can change it by main.m parameter, see further explanations on that file or the relative report) Once you have run the maneuver, save the workspace with the data of the simulation ( for ex. without kit) After you change the coefficients in vehicle_data, repeat the maneuver and save again the workspace (for ex .with kit) Note: at the end you have to get the files senzakit.mat and conkit.mat into the folder Performance_comparison/Aero_comparison Open main.m and select mod = 4 in order to be able to select this type of comparison. Run and you will obtain the graphics you want. P.S. in this folder you will find also some images of the inputs (u and delta of the step corner maneuver used) and the real paths coming from main ( they are the same you will obtain as trajectory in the comparison, but this time coming from main).","title":"Aero kit comparison"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/09-Vehicle_Modules/","text":"Vehicle_Modules (folder) In this folder there are all the Matlab functions and/or data that are used in the vehicle model block in the Simulink file (see below), if you want to modify some parts of the vehicle modelling (such as tire behaviour, model of aerodynamic forces, model of contact forces, motor model, vehicle data, ecc.). vehicle_data.m In this file we have all the data of the car needed for the simulation . After every car change, they must be updated. Some values can be obtained only by doing some tests on the physical car. load... .m files In the loadControlData.m file we simply load the values from the vehicle_data.m file needed for the control. In the loadInitialConditions.m file we load the initial conditions. ... model.m files For the different parts of the vehicle, we have some models including the model of the tire. For the description of these models, you can refer to the pdf file \"10 Dof Vehicle Model Updating\". All these equations are exported from Maple\u2019s files. getSimualtionParams\u2026 see maneuvers description Git submodules The folder Vehicle_modules is common to all the repo of the DMT team. So we built a submodule in order to have all the files updated in all the repo. The submodule is an external small-repo in which is contained the folder Vehicle Modules and it is linked to all our repo. After having done some changes to this folder during your work on a big repository, you will need to open the terminal in the folder of the big-repo you were working on. For those working with Windows, you will need to open the terminal inside the folder of the big repository by right-clicking with the mouse inside the folder and selecting Git Bash to open it. Alternatively, you can open the folder inside Visual Studio Code and select Git Bash as terminal and work directly in there. Then it will be necessary to insert the type of operation you want to perform with this scrip (BOTH FOR MAC AND WINDOWS). If you want to upload the changes you will need to type ./submodule_script push Then after compliting the push operation the small-repo for the vehicle modules is up to date and automatically pulled also in the other big repo of the team DMT. Every day before starting with your work type in a terminal (MAC) or in GitBash windows to pull remote changes. ./submodule_script pull","title":"Vehicle_Modules (folder)"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/09-Vehicle_Modules/#vehicle_modules-folder","text":"In this folder there are all the Matlab functions and/or data that are used in the vehicle model block in the Simulink file (see below), if you want to modify some parts of the vehicle modelling (such as tire behaviour, model of aerodynamic forces, model of contact forces, motor model, vehicle data, ecc.). vehicle_data.m In this file we have all the data of the car needed for the simulation . After every car change, they must be updated. Some values can be obtained only by doing some tests on the physical car. load... .m files In the loadControlData.m file we simply load the values from the vehicle_data.m file needed for the control. In the loadInitialConditions.m file we load the initial conditions. ... model.m files For the different parts of the vehicle, we have some models including the model of the tire. For the description of these models, you can refer to the pdf file \"10 Dof Vehicle Model Updating\". All these equations are exported from Maple\u2019s files. getSimualtionParams\u2026 see maneuvers description","title":"Vehicle_Modules (folder)"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/09-Vehicle_Modules/#git-submodules","text":"The folder Vehicle_modules is common to all the repo of the DMT team. So we built a submodule in order to have all the files updated in all the repo. The submodule is an external small-repo in which is contained the folder Vehicle Modules and it is linked to all our repo. After having done some changes to this folder during your work on a big repository, you will need to open the terminal in the folder of the big-repo you were working on. For those working with Windows, you will need to open the terminal inside the folder of the big repository by right-clicking with the mouse inside the folder and selecting Git Bash to open it. Alternatively, you can open the folder inside Visual Studio Code and select Git Bash as terminal and work directly in there. Then it will be necessary to insert the type of operation you want to perform with this scrip (BOTH FOR MAC AND WINDOWS). If you want to upload the changes you will need to type ./submodule_script push Then after compliting the push operation the small-repo for the vehicle modules is up to date and automatically pulled also in the other big repo of the team DMT. Every day before starting with your work type in a terminal (MAC) or in GitBash windows to pull remote changes. ./submodule_script pull","title":"Git submodules"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/10-Exportation-of-C-code/","text":"C Code In the folder C Code we can find useful files for the conversion of data and exportation to C code. We can find a file to convert matlab data (.m) in (.csv) data. DatacomparisonS_C to compare response from the model and from the controller implemented in C. In this folder the C code generated by building the simulink blocks is placed automatically during the exportation phase. Exportation of C Code The C Code exportation allows us to convert our controls and velocity estimation blocks from Simulink, in order to use the code in the ECU of our car. The whole model has been organised in such a way to allow an easy exportation of the control code that follows has to be implemented on the controller. It has been decided to organise the code with dynamic libraries which are only called when necessary. To do this, the control section in the Simulink model was revised by creating four separate blocks within it. The important thing is that each block takes the same data as input and output to create interchangeable libraries. In order to successfully export the C code from Simulink model for the controller follow these instructions: From Matlab, open the main .m file and run a simulation with mod=1 keeping all control active (always remember to run a simulation before exporting the code!) Open the Simulink .slx file with the model In Apps select Embedded Coder and in the section that opens go to Settings and set the following parameters: In the Code Generation section set: System target file = ert.tlc ; Language = C ; Prioritised objectives = Execution efficiency, Traceability In the Hardware Implementation section set: Device vendor = ARM Compatible ; Device type = ARM7 Every time before exporting the code, check that the input and output variables are correctly defined as ExportedGlobal Select the control block from which we want to extract the code, right-click on the block, C/C++ Code -> Build This Subsystem This process generates a folder with the name of the block that contains several files .c and .h files. If the model is modified, the code generation procedure must be repeated. .CSV files The .csv files are used for testing the C CODE exportation and the for the repo data-analysis: 1st method: Run main.m file with mode 1 imposing manuevre and control type. The main file will execute the script m_to_csv.mlx that will generate .csv files for testing the controls behaviour in the ECU of the car if you allow it at the end of the simulation. You can decide also to export them for data analysis (the other repo) 2nd method (17/03/2021 update) - Plot method You can use in C_simulink_comp folder the script DatacomparisonS_C.mlx, to import data from Simulink simulation (control_gen_x.mat) and data from C and analyse the plot","title":"C Code"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/10-Exportation-of-C-code/#c-code","text":"In the folder C Code we can find useful files for the conversion of data and exportation to C code. We can find a file to convert matlab data (.m) in (.csv) data. DatacomparisonS_C to compare response from the model and from the controller implemented in C. In this folder the C code generated by building the simulink blocks is placed automatically during the exportation phase.","title":"C Code"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/10-Exportation-of-C-code/#exportation-of-c-code","text":"The C Code exportation allows us to convert our controls and velocity estimation blocks from Simulink, in order to use the code in the ECU of our car. The whole model has been organised in such a way to allow an easy exportation of the control code that follows has to be implemented on the controller. It has been decided to organise the code with dynamic libraries which are only called when necessary. To do this, the control section in the Simulink model was revised by creating four separate blocks within it. The important thing is that each block takes the same data as input and output to create interchangeable libraries. In order to successfully export the C code from Simulink model for the controller follow these instructions: From Matlab, open the main .m file and run a simulation with mod=1 keeping all control active (always remember to run a simulation before exporting the code!) Open the Simulink .slx file with the model In Apps select Embedded Coder and in the section that opens go to Settings and set the following parameters: In the Code Generation section set: System target file = ert.tlc ; Language = C ; Prioritised objectives = Execution efficiency, Traceability In the Hardware Implementation section set: Device vendor = ARM Compatible ; Device type = ARM7 Every time before exporting the code, check that the input and output variables are correctly defined as ExportedGlobal Select the control block from which we want to extract the code, right-click on the block, C/C++ Code -> Build This Subsystem This process generates a folder with the name of the block that contains several files .c and .h files. If the model is modified, the code generation procedure must be repeated.","title":"Exportation of C Code"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/10-Exportation-of-C-code/#csv-files","text":"The .csv files are used for testing the C CODE exportation and the for the repo data-analysis: 1st method: Run main.m file with mode 1 imposing manuevre and control type. The main file will execute the script m_to_csv.mlx that will generate .csv files for testing the controls behaviour in the ECU of the car if you allow it at the end of the simulation. You can decide also to export them for data analysis (the other repo) 2nd method (17/03/2021 update) - Plot method You can use in C_simulink_comp folder the script DatacomparisonS_C.mlx, to import data from Simulink simulation (control_gen_x.mat) and data from C and analyse the plot","title":".CSV files"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/11-Other-Folders/","text":"Other Folders Longit_Controller and Lateral_Controller These folders are required to model the longitudinal and lateral dynamics of the car. Inside the Lateral_Controller folder there are all the Clothoid\u2019s functions for the computation of the trajectory of the car. Instead, in the Longit_Controller there are the files for loading the PID coefficients used to describe the behaviour of the driver. This PID controller is implemented inside the \u2018Inputs/Driver/Cruise control/Dynamic cruise control\u2019 block of the simulink model and rules the cruise control to provide the right throttle and brake to the model. These parameters are provided only on a set of discrete values and up to 27 m/s but this is not a problem as Simulink will interpolate these values creating a continuous dynamic even for higher speed values. Utilities In this folder you will find some .m files of functions, the ones most used and to put in evidence are the dataAnalysis.m, antislipplot.m the torquevectoringplot.m that are the files in which are defined the plots selectable in the Graphic part of the main (1, 2, 3) and the function to plot the trajectory of the car (car2D). The other files are used for the verification and data analysis.","title":"Other Folders"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/11-Other-Folders/#other-folders","text":"","title":"Other Folders"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/11-Other-Folders/#longit_controller-and-lateral_controller","text":"These folders are required to model the longitudinal and lateral dynamics of the car. Inside the Lateral_Controller folder there are all the Clothoid\u2019s functions for the computation of the trajectory of the car. Instead, in the Longit_Controller there are the files for loading the PID coefficients used to describe the behaviour of the driver. This PID controller is implemented inside the \u2018Inputs/Driver/Cruise control/Dynamic cruise control\u2019 block of the simulink model and rules the cruise control to provide the right throttle and brake to the model. These parameters are provided only on a set of discrete values and up to 27 m/s but this is not a problem as Simulink will interpolate these values creating a continuous dynamic even for higher speed values.","title":"Longit_Controller and Lateral_Controller"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/11-Other-Folders/#utilities","text":"In this folder you will find some .m files of functions, the ones most used and to put in evidence are the dataAnalysis.m, antislipplot.m the torquevectoringplot.m that are the files in which are defined the plots selectable in the Graphic part of the main (1, 2, 3) and the function to plot the trajectory of the car (car2D). The other files are used for the verification and data analysis.","title":"Utilities"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/12-Release-Notes/","text":"Release Notes In this section you will find the updates of the model 28/07/2022: Tested the exportation of C code and fixed the simulink model to allows a better exportation Performan comparison GitHub instead of Google drive for keeping track of the evolution of the model Fixed the csv exportation for testing the c code 14/04/2022: Updated Simulink schematic and removal of useless things (you can find them in the previous version of the model in google drive) Created a new main that allows to perform simulation, optimization, velocity estimation test with the same file and the same Simulink model Changed the pacejka curves Introduced the motor curves, maps for motors and maps for controls Redefined the manuevres Creation of this readme guide 14/03/2022: Updated Fenice\u2019s data Updated Load Transfer Model in order to consider the nonlinear behaviour of the dampers Updated Simulink schematic and removal of useless things","title":"Release Notes"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/12-Release-Notes/#release-notes","text":"In this section you will find the updates of the model 28/07/2022: Tested the exportation of C code and fixed the simulink model to allows a better exportation Performan comparison GitHub instead of Google drive for keeping track of the evolution of the model Fixed the csv exportation for testing the c code 14/04/2022: Updated Simulink schematic and removal of useless things (you can find them in the previous version of the model in google drive) Created a new main that allows to perform simulation, optimization, velocity estimation test with the same file and the same Simulink model Changed the pacejka curves Introduced the motor curves, maps for motors and maps for controls Redefined the manuevres Creation of this readme guide 14/03/2022: Updated Fenice\u2019s data Updated Load Transfer Model in order to consider the nonlinear behaviour of the dampers Updated Simulink schematic and removal of useless things","title":"Release Notes"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/Home/","text":"Repo Usage Welcome to the fenice-vehicle-model-2022 wiki! To modify the model, open Fenice_VehicleModel.slx To start a simulation, open main.m TABLE OF CONTENTS How to get started main.m initialization.m Fenice_VehicleModel.slx Slip_Control (Folder) Torque_Vectoring (Folder) Velocity Estimation (Folder) Performance Comparison Vehicle_Modules Exportation of C Code Other Folders Release Notes","title":"Repo Usage"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/Home/#repo-usage","text":"Welcome to the fenice-vehicle-model-2022 wiki! To modify the model, open Fenice_VehicleModel.slx To start a simulation, open main.m","title":"Repo Usage"},{"location":"fenice-vehicle-model-DMT/Repo%20Usage/Home/#table-of-contents","text":"How to get started main.m initialization.m Fenice_VehicleModel.slx Slip_Control (Folder) Torque_Vectoring (Folder) Velocity Estimation (Folder) Performance Comparison Vehicle_Modules Exportation of C Code Other Folders Release Notes","title":"TABLE OF CONTENTS"},{"location":"fenice-vehicle-model-DMT/Theory/Home_Theory/","text":"Vehicle Model+Control Theory Welcome to the fenice-vehicle-model-2022 theory section! TABLE OF CONTENTS Vehicle Model Equations Torque Vectoring Slip Control Velocity Estimation Motor Maps","title":"Vehicle Model+Control Theory"},{"location":"fenice-vehicle-model-DMT/Theory/Home_Theory/#vehicle-modelcontrol-theory","text":"Welcome to the fenice-vehicle-model-2022 theory section!","title":"Vehicle Model+Control Theory"},{"location":"fenice-vehicle-model-DMT/Theory/Home_Theory/#table-of-contents","text":"Vehicle Model Equations Torque Vectoring Slip Control Velocity Estimation Motor Maps","title":"TABLE OF CONTENTS"},{"location":"fenice-vehicle-model-DMT/Theory/Motor_Maps/","text":"Electric Motor Curve and Maps Documentation of the implementation of motor maps and curves on the vehicle controls Introduction The controls of the vehicle received as input different variables including the requested torque from the pilot and gave as output the adjusted torque that we want the motor to erogate. Previously only a saturation block was used to guarantee the safety of the pilot. Preventing that the adjusted torque diverges as a consequence of some unmodelled disturbances, the torque after the controls pass through a saturation block that limits its intensity to a maximum target value which is equal to \\(55 \\mathrm{~N}^{*} \\mathrm{~m}\\) for both the electric motors. The improvement consists in adding in the control model a new saturation of the erogated torque that takes into account the maximum power erogated from the battery pack. Motor Curve Motor curve are needed because we take as input in the controls the requested torque by the pilot while the input of the motor is the power erogated by the battery pack which can be seen as \\(P=\\) torque \\(*\\) angular velocity. The computation of the torque becomes a sequence of if-else cycle that takes into account: the transmission parameters (transmission ratio of the gearbox and transmission efficiency of the gearbox) which are needed to compute the angular velocity of the motors starting from the angular velocity of the wheels. The electric motor data: max torque that the motor can provide, motor rotational speed at which torque is decreased a lot and also the maximum rotational speed of the motor. The limitation is no more directly on the maximum torque but on the maximum power, which consists in a limitation in both torque, angular velocity and so the product between them. The following plots describe the relationship between motor torque and angular velocity. We can clearly see that until a certain threshold in omega the maximum torque is not affected by the velocity, while after this threshold which is the \"omega_motTorqueCut\" the torque decreases linearly until we reach the maximum angular velocity permitted by the power of the battery pack. Figure 1-2 - Motor and Wheel torque - Emrax 188 with FSAE Fenice powertrain. Motor Maps Motor maps are a further improvement that we want to add on the steering wheel in order to give to the pilot the possibility to decide which is the maximum torque that the vehicle can obtain from the motors. Selecting the number of the map is related to a penalty coefficient that is applied to the maximum torque through a look-up table in the model. The following curves represent the 6 different maps that could be selected. It will be useful for example the usage of low maps when the battery pack has low battery and high maps when we need the best performance of the vehicle. As follows I have reported both motor and wheel torque where the difference is just in the transmission ratio. The transmission acts as a torque amplifier, converting the low torque high angular velocity power from the motor to the high torque low angular velocity of the wheels. Figure 3-4 - Motor and Wheel torque - Emrax 188 with FSAE Fenice powertrain for all the maps. Implementation in the model In the following picture we can see how the motor curves and the motor maps are implemented in the model. This part of the algorithm has been implemented in simulink in the velocity estimation block end has as output the maximum torque that the motor can erogate. The output will be inserted in the control subsystems like an upper limit in the torque which varies considering the different conditions in each time step. Figure 5 - Implementation of motor curves and maps in the velocity estimation subsystem The same concept of the motor maps has been applied for the controls. This gives the possibility to the pilot to decide the intensity of the control action of both the traction control and the torque vectoring separately. The pilot selects a map which applies a coefficient which is in the interval \\([0,1]\\) that multiplies the torque reduction due to the controls. Figure 6 - Implementation of the modulation of intensity of the traction control action in the antislip subsystem Figure 7 - Implementation of the modulation of intensity of the torque vectoring action in the torque vectoring subsystem Revision History V1.0 22/06/2022: Initial release (Matteo Da Re)","title":"Electric Motor Curve and Maps"},{"location":"fenice-vehicle-model-DMT/Theory/Motor_Maps/#electric-motor-curve-and-maps","text":"Documentation of the implementation of motor maps and curves on the vehicle controls","title":"Electric Motor Curve and Maps"},{"location":"fenice-vehicle-model-DMT/Theory/Motor_Maps/#introduction","text":"The controls of the vehicle received as input different variables including the requested torque from the pilot and gave as output the adjusted torque that we want the motor to erogate. Previously only a saturation block was used to guarantee the safety of the pilot. Preventing that the adjusted torque diverges as a consequence of some unmodelled disturbances, the torque after the controls pass through a saturation block that limits its intensity to a maximum target value which is equal to \\(55 \\mathrm{~N}^{*} \\mathrm{~m}\\) for both the electric motors. The improvement consists in adding in the control model a new saturation of the erogated torque that takes into account the maximum power erogated from the battery pack.","title":"Introduction"},{"location":"fenice-vehicle-model-DMT/Theory/Motor_Maps/#motor-curve","text":"Motor curve are needed because we take as input in the controls the requested torque by the pilot while the input of the motor is the power erogated by the battery pack which can be seen as \\(P=\\) torque \\(*\\) angular velocity. The computation of the torque becomes a sequence of if-else cycle that takes into account: the transmission parameters (transmission ratio of the gearbox and transmission efficiency of the gearbox) which are needed to compute the angular velocity of the motors starting from the angular velocity of the wheels. The electric motor data: max torque that the motor can provide, motor rotational speed at which torque is decreased a lot and also the maximum rotational speed of the motor. The limitation is no more directly on the maximum torque but on the maximum power, which consists in a limitation in both torque, angular velocity and so the product between them. The following plots describe the relationship between motor torque and angular velocity. We can clearly see that until a certain threshold in omega the maximum torque is not affected by the velocity, while after this threshold which is the \"omega_motTorqueCut\" the torque decreases linearly until we reach the maximum angular velocity permitted by the power of the battery pack. Figure 1-2 - Motor and Wheel torque - Emrax 188 with FSAE Fenice powertrain.","title":"Motor Curve"},{"location":"fenice-vehicle-model-DMT/Theory/Motor_Maps/#motor-maps","text":"Motor maps are a further improvement that we want to add on the steering wheel in order to give to the pilot the possibility to decide which is the maximum torque that the vehicle can obtain from the motors. Selecting the number of the map is related to a penalty coefficient that is applied to the maximum torque through a look-up table in the model. The following curves represent the 6 different maps that could be selected. It will be useful for example the usage of low maps when the battery pack has low battery and high maps when we need the best performance of the vehicle. As follows I have reported both motor and wheel torque where the difference is just in the transmission ratio. The transmission acts as a torque amplifier, converting the low torque high angular velocity power from the motor to the high torque low angular velocity of the wheels. Figure 3-4 - Motor and Wheel torque - Emrax 188 with FSAE Fenice powertrain for all the maps.","title":"Motor Maps"},{"location":"fenice-vehicle-model-DMT/Theory/Motor_Maps/#implementation-in-the-model","text":"In the following picture we can see how the motor curves and the motor maps are implemented in the model. This part of the algorithm has been implemented in simulink in the velocity estimation block end has as output the maximum torque that the motor can erogate. The output will be inserted in the control subsystems like an upper limit in the torque which varies considering the different conditions in each time step. Figure 5 - Implementation of motor curves and maps in the velocity estimation subsystem The same concept of the motor maps has been applied for the controls. This gives the possibility to the pilot to decide the intensity of the control action of both the traction control and the torque vectoring separately. The pilot selects a map which applies a coefficient which is in the interval \\([0,1]\\) that multiplies the torque reduction due to the controls. Figure 6 - Implementation of the modulation of intensity of the traction control action in the antislip subsystem Figure 7 - Implementation of the modulation of intensity of the torque vectoring action in the torque vectoring subsystem","title":"Implementation in the model"},{"location":"fenice-vehicle-model-DMT/Theory/Motor_Maps/#revision-history","text":"V1.0 22/06/2022: Initial release (Matteo Da Re)","title":"Revision History"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/","text":"Slip Control Theory The purpose of this report is to explain the basic principles which are behind the dynamics of an accelerating car and a first sketch of the design of a Slip Controller for the E-Agle Trento Racing Team racing vehicle, Fenice. The vehicle is still not complete so the structure of the controller and its first analysis was done for now on the model of Chimera Evoluzione, the previous E-Agle Trento Racing Team vehicle. Once Fenice will be completed, a series of tests will be performed to identify the parameters and update the model, at this point the controller will be tuned and optimized. Summary of the previous work When I started working on the slip control, a simple control strategy was already implemented and it consisted on a proportional controller that used the error between the real and reference slip to reduce the torque request to the motor in order to minimize the vehicle slip during accelerations. The wheel slip estimators were already present but had problems at low velocities and during braking. The vehicle model which was used for the simulation also had problems and was not validated with experimental data, so the controllers were not tuned and properly designed. This year, some tests on Chimera Evoluzione could be performed and, from the measured data, it could be possible to estimate the vehicle main parameters and to validate the model. For this reason, we could implement a better simulation environment which gave us the opportunity to start testing the controllers on the updated vehicle dynamical model. Introduction The Slip Control (or Traction Control) System is a controller which helps limiting the tire slip in acceleration to prevent loss of traction with the consequent loss of vehicle performances and stability. Indeed, when a vehicle accelerates on a slippery surface, the wheels lose the grip on the ground and start to slip. Consequently, the vehicle loses traction and the ability to steer. To prevent this, the controller uses sensors data to detect when the wheels are slipping and reduces the torques applied by the motors to allow the wheels to slow down and regain traction. Fast overview on vehicle dynamics To design a slip controller, first of all we have to understand the basic principles that rule the vehicle dynamics and the effects of the wheel slipping. The tire behaviour is particularly important because the car accelerates thanks to the longitudinal forces that the driven wheels can exert on the road surface. These forces depend on the loads (vertical forces) on the wheels and the friction coefficients between the wheels and the road surface. The wheel slip happens when the longitudinal forces (for lateral forces the behaviour is equivalent) saturates the maximum friction forces of the contact surface. Pacejka tire model In our vehicle model the tire behaviour has been represented using the so-called simplified Pacejka model, a semi-empirical model that permits to relate the traction forces with the wheel slip ratio through the following formulation, called Magic Formula (simplified version), which can represent both the longitudinal and lateral behaviour: \\[ y=D \\sin [C \\arctan (B x)] \\] where \\(y\\) corresponds to the longitudinal (or lateral) force and \\(\\mathrm{x}\\) to the longitudinal (or lateral) wheel slip, \\(D=\\) \\(\\mu F_{z}\\) , meanwhile \\(\\mu, \\mathrm{C}\\) and \\(\\mathrm{B}\\) are parameters that need to be tuned to fit the experimental data. This model is particularly useful to design a slip controller because the control purpose is to keep the slip to its optimal value to maximise the acceleration performances, and, through this model, we can easily estimate this value by identifying the peak of the graph. Note: this optimal slip approach still presents some difficulties since the optimal slip value depends on many conditions. As we can see in the next pictures, the parameters of the magic formula depend on the asphalt conditions and the lateral slip, so the optimal slip value is not a constant. Influence of the asphalt conditions on the Pacejka model Influence of the side slip on the Pacejka model Controller design Optimal slip ratio The first step to design the controller is to identify the optimal wheel slip value to be used as a reference. As I previously introduced, there is not a univocal optimal value, because it depends on many conditions. Unfortunately, the tire model that we used was estimated using just a few raw experiments on track due to the COVID-19 pandemic restrictions. A complete tire model estimation should be performed using data from very expensive tests which would properly evaluate the tire behaviour for all the slip values and in presence of lateral slip and with different road conditions. Our tire model was identified only in case of dry asphalt and only with \\(\\lambda \\leq \\approx 0.05\\) and no lateral slip. For this reason, this model does not cover all the real tire behaviour, but it could still be useful in to have a general idea of the optimal slip. Moreover, the most standard driving conditions are on dry asphalt and the optimal value in case of wet asphalt does not usually significantly differ. Given these assumptions, the optimal value that has been estimated with the available data could be considered as the reference value for the slip control. This value has been estimated by extracting the vehicle and tire parameters from the vehicle model, calculating the Pacejka model and finding its maximum. The result is showed in the next picture, where the peak value is reached for \\(\\lambda \\approx 0.097\\) , value that was then chosen to be the reference for the slip controller. Pacejka tire model PI controller design The already implemented controller worked with a simple proportional gain: the estimated current slip value was subtracted from the reference value and the result was multiplied by a constant to calculate the torque reduction. The main problem of this controller was that, by simulating an acceleration manoeuvre, the performances of the vehicle, the final distance and velocity reached at the end of the simulation, with the control active were lower than the ones without control. The main reasons for this result were that the controller was not properly tuned and the only proportional feedback could not stabilize the slip to the desired optimal value. Moreover, the shape of the estimated wheel characteristic makes it difficult to detect significant improvements in the performances if the optimal slip value is not accurately reached. Since the proportional gain was not enough, I decided to take into consideration a PID controller, so also an integral and a derivative action. PID controllers are widely used in and well-established thanks to their high accuracy and stability properties. This type of controller calculates the error between the reference and actual value to control and applies a correction based on proportional, integral, and derivative terms in to minimize this error. The addition of and integral and derivative part could be particularly useful when a simple proportional gain fails: the integral term makes the control action increasing over so it reduces the steady state error, meanwhile the derivative part tries to reduce the rate of change of the error, so it flatters the error trajectory by damping the control signal and reducing the overshoots. The main disadvantage of the derivative part is that it is very sensible to noises so it could not be used for the presence of measurement noises, because in this case it could lead to system instability and significant performance reduction. So, given that the estimation of the wheels slip is very noisy, I had to exclude this term and the final choice has been to design a PI controller. A first version of the control logic was implemented as follows: As in the old version, the controller calculates the error between the reference and the current slip value and the PI controller uses that value to apply a torque reduction to the wheels in order to reduce the slip. Note: since the controller should never increase the torque demanded by the driver, a saturation has been introduced to limit the output of the Discrete PI Controller block. Moreover, to avoid the saturation of the PI controller integrator during a strong acceleration and to make the controller faster to react, the Discrete PI Controller block has also been configured for Anti-windup based on integrator clamping. Tuning The tuning procedure consists of finding the optimal values of the proportional and integral gains to balance their effects. This procedure was set to exploit optimization, so trying to maximize the final velocity, reached by the vehicle at the end of the simulation at different starting velocities, to find a table of optimal values of proportional and integral gains. In this way, the controller can be set to also adapt his gains at different velocities to further improve the vehicle performances. Estimators limits and switching logic The estimation of the wheels slip is done by using the data from the encoders that are placed on the four wheels. The measurements of the angular velocity of the front wheels is used to estimate the vehicle speed and the difference between the angular velocities of front and rear wheels is used to estimate the slip. This type of estimator works with the assumption that the front wheels, not driven by any motors, have a pure rolling motion, so their angular velocity well represent the vehicle speed. This assumption is valid only in case of traction, meanwhile, since the vehicle brakes are placed on every wheel, this assumption is not yet valid if these wheels start slipping due to the brake action. In this case the vehicle speed and the slip estimation could be highly imprecise and could lead to a wrong intervention of the slip controller. For this reason, and because a traction controller is not even intended to work in case of braking, I have decided to automatically turn off and reset the controller in that situation. Implementation The current version of the control logic was then implemented as follows: As we can see, the proportional and integral gains are taken from lookup tables that gives different optimal values depending on the current vehicle speed, the brake signal is used to reset the integrator and to automatically switch from the reduced torque (slip control on) and original requested torque (slip control off). Conclusions First Observations The first analysis on this new controller shows that this design works much better than before, in particular its behaviour is now more stable and reliable. The use of the controller in a simulation with a strong acceleration leads to better performances of the vehicle, higher final velocity and stability. Further optimizations and a proper testing will follow as soon as the new vehicle will be completed and tested. Design difficulties The main difficulties that I had in designing this controller have been especially related with the problems of the vehicle model. Even if, during the validation process of Chimera Evoluzione and during further debugging sessions that we have performed, many problems and errors have been solved, the model still presents some inaccuracies at low speed. Moreover, the tire model fitting is a quite difficult procedure that would involve data from very expensive tests on the tire (TTC, Tire Test Consortium, would allow us to do some of these tests for our tire but they suspended these experiments due to COVID-19 pandemic) but could only be done using data taken from a very limited number of test, so the available experimental data were very limited and this had a strong influence on the final estimated model which presents many inaccuracies. Moreover, the controller is intended to be implemented for the new E-Agle Trento Racing Team vehicle Fenice which is still not completed. Tests will then be performed to update the Simulink model with the new data to tune the controller and optimize the behaviour of our new vehicle. Further work If we would be able to perform tests on the new vehicle and more accurate tests on the wheels, we could estimate a more precise model of our tire to improve our control design and perform more realistic simulations to test and optimize it for different driving conditions. For example, the choice of the reference slip ratio could be revisited by considering how the optimal slip changes from dry to wet asphalt and by having a correct estimation on how it is influenced by the side slip. Moreover, a more precise model of the tire behaviour for different slip conditions could help to improve the tuning results and simulations. Release Notes 09/2021: First Release (Asia La Rocca)","title":"Slip Control Theory"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/#slip-control-theory","text":"The purpose of this report is to explain the basic principles which are behind the dynamics of an accelerating car and a first sketch of the design of a Slip Controller for the E-Agle Trento Racing Team racing vehicle, Fenice. The vehicle is still not complete so the structure of the controller and its first analysis was done for now on the model of Chimera Evoluzione, the previous E-Agle Trento Racing Team vehicle. Once Fenice will be completed, a series of tests will be performed to identify the parameters and update the model, at this point the controller will be tuned and optimized.","title":"Slip Control Theory"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/#summary-of-the-previous-work","text":"When I started working on the slip control, a simple control strategy was already implemented and it consisted on a proportional controller that used the error between the real and reference slip to reduce the torque request to the motor in order to minimize the vehicle slip during accelerations. The wheel slip estimators were already present but had problems at low velocities and during braking. The vehicle model which was used for the simulation also had problems and was not validated with experimental data, so the controllers were not tuned and properly designed. This year, some tests on Chimera Evoluzione could be performed and, from the measured data, it could be possible to estimate the vehicle main parameters and to validate the model. For this reason, we could implement a better simulation environment which gave us the opportunity to start testing the controllers on the updated vehicle dynamical model.","title":"Summary of the previous work"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/#introduction","text":"The Slip Control (or Traction Control) System is a controller which helps limiting the tire slip in acceleration to prevent loss of traction with the consequent loss of vehicle performances and stability. Indeed, when a vehicle accelerates on a slippery surface, the wheels lose the grip on the ground and start to slip. Consequently, the vehicle loses traction and the ability to steer. To prevent this, the controller uses sensors data to detect when the wheels are slipping and reduces the torques applied by the motors to allow the wheels to slow down and regain traction.","title":"Introduction"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/#fast-overview-on-vehicle-dynamics","text":"To design a slip controller, first of all we have to understand the basic principles that rule the vehicle dynamics and the effects of the wheel slipping. The tire behaviour is particularly important because the car accelerates thanks to the longitudinal forces that the driven wheels can exert on the road surface. These forces depend on the loads (vertical forces) on the wheels and the friction coefficients between the wheels and the road surface. The wheel slip happens when the longitudinal forces (for lateral forces the behaviour is equivalent) saturates the maximum friction forces of the contact surface.","title":"Fast overview on vehicle dynamics"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/#pacejka-tire-model","text":"In our vehicle model the tire behaviour has been represented using the so-called simplified Pacejka model, a semi-empirical model that permits to relate the traction forces with the wheel slip ratio through the following formulation, called Magic Formula (simplified version), which can represent both the longitudinal and lateral behaviour: \\[ y=D \\sin [C \\arctan (B x)] \\] where \\(y\\) corresponds to the longitudinal (or lateral) force and \\(\\mathrm{x}\\) to the longitudinal (or lateral) wheel slip, \\(D=\\) \\(\\mu F_{z}\\) , meanwhile \\(\\mu, \\mathrm{C}\\) and \\(\\mathrm{B}\\) are parameters that need to be tuned to fit the experimental data. This model is particularly useful to design a slip controller because the control purpose is to keep the slip to its optimal value to maximise the acceleration performances, and, through this model, we can easily estimate this value by identifying the peak of the graph. Note: this optimal slip approach still presents some difficulties since the optimal slip value depends on many conditions. As we can see in the next pictures, the parameters of the magic formula depend on the asphalt conditions and the lateral slip, so the optimal slip value is not a constant. Influence of the asphalt conditions on the Pacejka model Influence of the side slip on the Pacejka model","title":"Pacejka tire model"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/#controller-design","text":"","title":"Controller design"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/#optimal-slip-ratio","text":"The first step to design the controller is to identify the optimal wheel slip value to be used as a reference. As I previously introduced, there is not a univocal optimal value, because it depends on many conditions. Unfortunately, the tire model that we used was estimated using just a few raw experiments on track due to the COVID-19 pandemic restrictions. A complete tire model estimation should be performed using data from very expensive tests which would properly evaluate the tire behaviour for all the slip values and in presence of lateral slip and with different road conditions. Our tire model was identified only in case of dry asphalt and only with \\(\\lambda \\leq \\approx 0.05\\) and no lateral slip. For this reason, this model does not cover all the real tire behaviour, but it could still be useful in to have a general idea of the optimal slip. Moreover, the most standard driving conditions are on dry asphalt and the optimal value in case of wet asphalt does not usually significantly differ. Given these assumptions, the optimal value that has been estimated with the available data could be considered as the reference value for the slip control. This value has been estimated by extracting the vehicle and tire parameters from the vehicle model, calculating the Pacejka model and finding its maximum. The result is showed in the next picture, where the peak value is reached for \\(\\lambda \\approx 0.097\\) , value that was then chosen to be the reference for the slip controller. Pacejka tire model","title":"Optimal slip ratio"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/#pi-controller-design","text":"The already implemented controller worked with a simple proportional gain: the estimated current slip value was subtracted from the reference value and the result was multiplied by a constant to calculate the torque reduction. The main problem of this controller was that, by simulating an acceleration manoeuvre, the performances of the vehicle, the final distance and velocity reached at the end of the simulation, with the control active were lower than the ones without control. The main reasons for this result were that the controller was not properly tuned and the only proportional feedback could not stabilize the slip to the desired optimal value. Moreover, the shape of the estimated wheel characteristic makes it difficult to detect significant improvements in the performances if the optimal slip value is not accurately reached. Since the proportional gain was not enough, I decided to take into consideration a PID controller, so also an integral and a derivative action. PID controllers are widely used in and well-established thanks to their high accuracy and stability properties. This type of controller calculates the error between the reference and actual value to control and applies a correction based on proportional, integral, and derivative terms in to minimize this error. The addition of and integral and derivative part could be particularly useful when a simple proportional gain fails: the integral term makes the control action increasing over so it reduces the steady state error, meanwhile the derivative part tries to reduce the rate of change of the error, so it flatters the error trajectory by damping the control signal and reducing the overshoots. The main disadvantage of the derivative part is that it is very sensible to noises so it could not be used for the presence of measurement noises, because in this case it could lead to system instability and significant performance reduction. So, given that the estimation of the wheels slip is very noisy, I had to exclude this term and the final choice has been to design a PI controller. A first version of the control logic was implemented as follows: As in the old version, the controller calculates the error between the reference and the current slip value and the PI controller uses that value to apply a torque reduction to the wheels in order to reduce the slip. Note: since the controller should never increase the torque demanded by the driver, a saturation has been introduced to limit the output of the Discrete PI Controller block. Moreover, to avoid the saturation of the PI controller integrator during a strong acceleration and to make the controller faster to react, the Discrete PI Controller block has also been configured for Anti-windup based on integrator clamping.","title":"PI controller design"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/#tuning","text":"The tuning procedure consists of finding the optimal values of the proportional and integral gains to balance their effects. This procedure was set to exploit optimization, so trying to maximize the final velocity, reached by the vehicle at the end of the simulation at different starting velocities, to find a table of optimal values of proportional and integral gains. In this way, the controller can be set to also adapt his gains at different velocities to further improve the vehicle performances.","title":"Tuning"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/#estimators-limits-and-switching-logic","text":"The estimation of the wheels slip is done by using the data from the encoders that are placed on the four wheels. The measurements of the angular velocity of the front wheels is used to estimate the vehicle speed and the difference between the angular velocities of front and rear wheels is used to estimate the slip. This type of estimator works with the assumption that the front wheels, not driven by any motors, have a pure rolling motion, so their angular velocity well represent the vehicle speed. This assumption is valid only in case of traction, meanwhile, since the vehicle brakes are placed on every wheel, this assumption is not yet valid if these wheels start slipping due to the brake action. In this case the vehicle speed and the slip estimation could be highly imprecise and could lead to a wrong intervention of the slip controller. For this reason, and because a traction controller is not even intended to work in case of braking, I have decided to automatically turn off and reset the controller in that situation.","title":"Estimators limits and switching logic"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/#implementation","text":"The current version of the control logic was then implemented as follows: As we can see, the proportional and integral gains are taken from lookup tables that gives different optimal values depending on the current vehicle speed, the brake signal is used to reset the integrator and to automatically switch from the reduced torque (slip control on) and original requested torque (slip control off).","title":"Implementation"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/#conclusions","text":"","title":"Conclusions"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/#first-observations","text":"The first analysis on this new controller shows that this design works much better than before, in particular its behaviour is now more stable and reliable. The use of the controller in a simulation with a strong acceleration leads to better performances of the vehicle, higher final velocity and stability. Further optimizations and a proper testing will follow as soon as the new vehicle will be completed and tested.","title":"First Observations"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/#design-difficulties","text":"The main difficulties that I had in designing this controller have been especially related with the problems of the vehicle model. Even if, during the validation process of Chimera Evoluzione and during further debugging sessions that we have performed, many problems and errors have been solved, the model still presents some inaccuracies at low speed. Moreover, the tire model fitting is a quite difficult procedure that would involve data from very expensive tests on the tire (TTC, Tire Test Consortium, would allow us to do some of these tests for our tire but they suspended these experiments due to COVID-19 pandemic) but could only be done using data taken from a very limited number of test, so the available experimental data were very limited and this had a strong influence on the final estimated model which presents many inaccuracies. Moreover, the controller is intended to be implemented for the new E-Agle Trento Racing Team vehicle Fenice which is still not completed. Tests will then be performed to update the Simulink model with the new data to tune the controller and optimize the behaviour of our new vehicle.","title":"Design difficulties"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/#further-work","text":"If we would be able to perform tests on the new vehicle and more accurate tests on the wheels, we could estimate a more precise model of our tire to improve our control design and perform more realistic simulations to test and optimize it for different driving conditions. For example, the choice of the reference slip ratio could be revisited by considering how the optimal slip changes from dry to wet asphalt and by having a correct estimation on how it is influenced by the side slip. Moreover, a more precise model of the tire behaviour for different slip conditions could help to improve the tuning results and simulations.","title":"Further work"},{"location":"fenice-vehicle-model-DMT/Theory/Slip_Control/#release-notes","text":"09/2021: First Release (Asia La Rocca)","title":"Release Notes"},{"location":"fenice-vehicle-model-DMT/Theory/Torque_Vectoring/","text":"Torque Vectoring Theory Introduction to Lateral Dynamics The control system VDC (Vehicle Dynamic Control), also known as ESP, VDS or DSC, is an active security system used to correct the vehicle trajectory in emergency conditions and with low adherence. In particular, the main two conditions that this control wants to reduce are understeer and oversteer. Both the behaviours can be compensated by generating a proper yawing or anti-yawing torque. For vehicles endowed with active differential, the implementation of this control is mainly realized with Torque Vectoring. Reference system The reference systems adopted for the dynamic behaviour analysis are shown in Figure 1. The origin of the mobile system is positioned at the intersection between the roll and the symmetry axis. Furthermore, the \\(\\mathrm{x}\\) -axis is always longitudinal to the vehicle. The velocities along \\(\\mathrm{x}\\) and \\(\\mathrm{y}\\) are called respectively \\(u\\) and \\(v\\) (for the moveable system), whereas the side-slip angle \\(\\beta\\) describes the direction of the resultant vector for the moveable triad. The other parameter necessary for the moment-by-moment analysis of the position and direction of the vehicle is the yaw angle \\(\\varphi\\) between the fixed X-axis and the x-axis of the mobile system. The steering angle, instead, is called \\(\\delta\\) . Figure 1 - Reference System Lateral Dynamics Control For a perfect turning behaviour of the vehicle is necessary to split in a different way the torque of the motors between the two rear driving wheels avoiding both under and oversteer. Because of dissimilar longitudinal forces on the rear tires \\(\\left(\\mathrm{F}_{\\mathrm{drl}}\\right.\\) and \\(\\left.\\mathrm{F}_{\\mathrm{drr}}\\right)\\) is generated a yaw couple \\(\\left(\\mathrm{N}_{\\mathrm{z}}\\right)\\) object of the Torque Vectoring Control (TV). The goal of this control is to maximize the longitudinal properties of the vehicle, allowing high manoeuvrability of the car while cornering. Figure 2 - Torque Vectoring Principle The modelling of the TV control is based on the yaw rate (yaw velocity) \\(\\Omega\\) instead of the side-slip angle \\(\\beta\\) because \\(\\Omega\\) is: easier to measure; nearest to the drive perception. Yaw Rate Estimation For estimating the yaw rate, the team has connected the inputs given by the pilot, like the steering angle and the accelerator, with the car's behaviour. For the construction of the transfer function, it is possible to start from the single-track linear model of the vehicle, analyzing its dynamic behaviour (Equation 1) depending on the mass of the system \\((\\mathrm{m})\\) , the lateral forces \\(\\left(\\mathrm{F}_{\\mathrm{y}}\\right)\\) and the harms of the front/rear axles from the centre of gravity \\(\\left(L_{f}-L_{r}\\right)\\) . \\[ \\left\\{\\begin{array}{l} m a_{y}=F_{y r}+F_{y f} \\\\ I_{z z} \\dot{\\Omega}=-L_{r} F_{y r}+L_{f} F_{y f} \\end{array}\\right. \\] Equation 1 - Dynamic behaviour of the vehicle It is possible to rewrite the equations depending on \\(\\mathrm{C}\\) (lateral stiffness of the tires) and \\(\\rho\\) (curvature), considering a linear behaviour of the vehicle in a stationary regime. Solving these equations can be found a relationship between the side-slip angle of the tires (Equation 2 and Equation 3). \\[ \\left\\{\\begin{array}{l} F_{y r}=C_{r} \\alpha_{r} \\\\ F_{y f}=C_{f} \\alpha_{f} \\\\ m a_{y s s}=\\rho u^{2} \\end{array}\\right. \\] Equation 2 - Rewriting of the equations \\[ \\alpha_{f}-\\alpha_{r}=\\frac{m \\rho+u^{2}}{L}(\\frac{L_{r}}{C_{f}}-\\frac{L_{f}}{C_{r}}) \\] Equation 3 - Relation between side-slip angles It is also possible to define the understeering coefficient \\((\\mathrm{K}_{\\mathrm{us}})\\) and the general expression of the side-slip angles (Equation 4 and Equation 5), function of the side-slip angle of the chassis \\((\\beta)\\) . \\[ K_{us}=\\frac{m}{L}(\\frac{L_{r}}{C_{f}}-\\frac{L_{f}}{C_{r}}) \\\\ \\] Equation 4 - Understeering coefficien \\[ \\begin{array}{l} \\alpha_{f}=\\beta+\\frac{\\Omega}{u} L_{f}-\\delta \\\\ \\alpha_{r}=\\beta-\\frac{\\Omega}{u} L_{r}-\\delta \\end{array}. \\] Equation 5 - General expression for side-slip angles Combining the previous equations can be found a direct relationship between the steering angle \\(\\delta\\) and the yaw rate (Equation 6). \\[ \\frac{L+K_{u s} u^{2}}{u}=\\frac{\\delta}{\\Omega} \\] Equation 6 - Relation between the steering angle and the yaw rate It is possible to introduce a first-order system with a \\(\\tau_{\\text {driver }}=0.1\\) (Equation 7), considering the slight delay in the driver's response (especially during steering maneuvers) due to his reflexes and the nonlinearity of the real world. The \\(\\Omega_{\\text {des }}\\) becomes: \\[ \\Omega=\\frac{\\frac{u}{L+K_{u s} u^{2}}}{\\tau_{\\text {driver }} s+1} \\delta \\] Equation 7 - Yaw rate expression with the adding of a first-order filter The filter for the driver response has been modelled in the block of the vehicle model in which the simulated inputs of the driver (brake, throttle, and steering angle) are computed for different manoeuvres. With this model, the pilot will be able to generate the desired yaw rate, acting directly on the steering angle and indirectly on the longitudinal velocity of the vehicle. The transfer function, by the way, depends on the lateral behaviour of the car through the parameter \\(\\mathrm{K}_{\\mathrm{us}}\\) , which can affect the vehicle response: Understeering Vehicle \\((K>\\mathbf{0})\\) : the vehicle curves less than desired. This behaviour is often applied to commercial cars; Neutral Vehicle \\((K=0)\\) Oversteering Vehicle \\((K<\\mathbf{0})\\) : the car tends to curve more than desired. This behaviour is usually employed in racing cars. For modelling the \\(\\mathrm{K}_{\\text {us }}\\) of the vehicle is possible to test this parameter with a fixed steering angle and a variable velocity of the car and building also the handling curves. The resulting Simulink model, employed for Fenice, is described in Figure 3. Figure 3 - Yaw rate estimation in the Simulink model of Fenice Realization of the TV Control For the designing of the control system, the team has adopted two different solutions: PID (proportional-integral-derivative) controller; Fuzzy logic controller. PID The PID controller is the first type of control implemented by the team, also in the former car (Chimera) model, to compensate for the error of the reference yaw rate compared with the one measured in practice. For the development of the system, it is possible to start from a linearized singletrack model described with Equation 8. It is possible to build a simplified model (Equation 9): the linear bicycle model (single axel and front steering wheel). \\[ \\left\\{\\begin{array}{l}I_{z} \\dot{\\Omega}=\\left(L_{f} C_{f}-L_{r} C_{r}\\right) \\beta+\\frac{\\left(L_{f}^{2} C_{f}-L_{r}^{2} C_{r}\\right) \\Omega}{u}-L_{f} C_{f} \\delta \\\\m u(\\Omega+\\dot{\\beta})=C_{f}\\left(\\beta+\\frac{\\Omega L_{f}}{u}-\\delta\\right)+C_{r}\\left(\\beta-\\frac{\\Omega L_{r}}{u}\\right)\\end{array}\\right. \\\\ \\] Equation 8 - Linearized single-track model \\[ \\left\\{\\begin{array}{l}\\dot{x}=A x+B u \\\\y=C x+D u\\end{array} \\quad x=\\left[\\begin{array}{l}\\beta \\\\\\Omega\\end{array}\\right], u=\\left[\\begin{array}{c}\\delta \\\\N_{z}\\end{array}\\right]\\right. \\\\ \\] \\[ A=\\left[\\begin{array}{cc}\\frac{C_{r}+C_{f}}{m u} & \\frac{-C_{r} L_{r}+C_{f} L_{f}}{m u^{2}}-1 \\\\\\frac{-C_{r} L_{r}+C_{f} L_{f}}{I_{z}} & \\frac{C_{r} L_{r}^{2}+C_{f} L_{f}^{2}}{u I_{z}}\\end{array}\\right] \\quad B=\\left[\\begin{array}{cc}0 & 0 \\\\1 / I_{z} & 0\\end{array}\\right] \\quad C=\\left[\\begin{array}{ll}0 & 1\\end{array}\\right] \\quad D=\\left[\\begin{array}{ll}0 & 0\\end{array}\\right] \\] Equation 9 - Linear Model The state matrix A depends on the velocity, so the control must modify its action following the speed variation. The team has chosen a PI controller (the derivative of the yaw-rate is already present in the model itself) with variable gain, a first crossover frequency of \\(13 \\mathrm{rad} / \\mathrm{s}\\) , and a phase margin of 70 degrees with particular attention to disturbances rejection. The tuning procedure is performed using the MATLAB tools, linearizing the model at different speeds, and tuning a PI controller for the step response. The linearization is made around a steadystate configuration and gives out the transfer functions between the yaw-moment - output of the PI and the yaw-rate. The steering angle must be small \\(\\left(\\sim 5^{\\circ}\\right)\\) to be considered a disturbance. It is possible to tune a reference controller on the linearized system, respecting some design parameters. The stability requirements are: - Phase margin \\(=70^{\\circ}:\\) it is a large value of phase margin - close to \\(90^{\\circ}\\) - which makes the system stable also with disturbances but delays the response of the controller; Crossover frequency \\(=13 \\mathrm{rad} / \\mathrm{s}\\) : after some tuning using different crossover frequencies, it is the most appropriate for the application; Disturbance rejection: to reject model linearization errors or the disturbance from the steering angle, the PID must be tuned for a robust closed-loop system to disturb. For the gain of the PI, it is possible, in conclusion, to develop a look-up table (Figure 4, Figure 5) for each different set-point velocity, that for Fenice's controller are eigth (Equation 10). \\[ \\begin{aligned} & u_{c t r}=\\left[\\begin{array}{llllllll}20 & 30 & 40 & 50 & 60 & 70 & 80 & 90\\end{array}\\right] \\mathrm{km} / \\mathrm{h} \\\\ \\end{aligned} \\] Equation 10 - Set-point velocities Figure 4 - Look-up table of the proportional variable gain Figure 5 - Look-up table of the integral variable gain The lock-up tables found with the tuning are then used as inputs for the PI regulator that controls in closed-loop the error between desired and measured yaw rate (Figure 6) Figure 6 - PI controller The output of the PI controller is saturated, imposing a limit to the ammissible values of \\(\\mathrm{N}_{\\mathrm{Z}}(\\) Equation \\(11)\\) in which \\(w_{r}\\) is rear track width, \\(\\Delta T_{m_{\\max }}\\) the maximum torque difference of the motors, \\(r_{r}\\) the rear wheels radius, \\(\\tau_{\\text {red }}\\) the transmission ratio of the gearbox and \\(e f f_{\\text {red }}\\) the efficiency of the gearbox. The \\(\\Delta T_{m_{\\text {max }}}\\) is then regulated by the driver on the steering wheel with TV maps, setting a percentage of the maximum \\(\\Delta T_{m_{\\max }}\\) (which is equal to \\(55 \\mathrm{Nm}\\) with full TV action active and \\(0 \\mathrm{Nm}\\) with \\(\\mathrm{TV}\\) deactivated). \\[ \\left|N_{z_{\\max }}\\right|=\\frac{\\Delta T_{m_{\\max }} \\cdot w_{r} \\cdot \\tau_{\\text {red }} \\cdot e f f_{r e d}}{2 r_{r}} \\\\ \\] Equation 11 - Saturation of the PI controller In reality, as described above, the actuators can be saturated. Consequently, the action of the integral control would continue to grow with an accumulation of error. For this reason, it is possible to introduce an anti-windup system embedded in the PI controller (clamping method). At the output of the yaw rate controller, inverting the Equation 11 is possible to compute the value of \\(\\Delta \\mathrm{T}_{\\mathrm{m}}\\) for computing the torque that the motors need to apply. The motor torques curves used are also chosen by the driver at the steering wheel, with 6 possible different maps (map 6 is the one that allows the higher longitudinal performances). The team has decided to modify the torque motor saturation favouring cornering behaviour at the expense of longitudinal performances, considering the desired \\(\\Omega\\) not always perfectly reachable (for example, when the motors are saturated). The pre-existing version gave priority to the longitudinal performance keeping constant the sum of the torque of the two actuators. For example, if the driver request was \\(70 \\mathrm{Nm}\\) for each motor with saturation torque of \\(80 \\mathrm{Nm}\\) and differential torque of \\(15 \\mathrm{Nm}\\) , a wheel should have \\(85 \\mathrm{Nm}(5 \\mathrm{Nm}\\) more than \\(80 \\mathrm{Nm}\\) of the saturation). To keep \\(140 \\mathrm{Nm}\\) of total torque, the other motor must generate \\(60 \\mathrm{Nm}\\) with a resulting differential torque equal to \\(10 \\mathrm{Nm}(5 \\mathrm{Nm}\\) less than the desired differential torque). Since the torque vectoring is a lateral controller, this strategy could negatively affect the cornering performance of the controller. So, it is preferable to privilege the differential torque, following the driver's request. For the same previous example, to maintain \\(15 \\mathrm{Nm}\\) of differential torque, one motor must be saturated, and the other must generate \\(50 \\mathrm{Nm}\\) . In this way, the total torque is \\(130 \\mathrm{Nm}\\) (previously \\(140 \\mathrm{Nm}\\) ), reducing the longitudinal acceleration but allowing for better cornering behaviour. In conclusion, it is possible to also limit the errors due to the noise influence that can activate torque vectoring when the driver is not cornering. So, for this reason, the team has decided that torque vectoring control will be active only with steering angle of the front wheels \\(|\\delta|>2^{\\circ}\\) and with a longitudinal velocity greater than \\(5 \\mathrm{~m} / \\mathrm{s}\\) (for the PI controller). Slip control combined with PI controller with torque The team has connected the slip controller outputs as a saturation of the torque vectoring to combine the two controllers (Figure 7). The saturation block limits the torque considering the differential torque output from the torque vectoring: if the higher torque wheel starts to slide, the slip controller reduces the torque for that wheel. In addition, at the same time, it limits the torque at the other wheel too, to maintain the differential torque. Figure 7 - Slip control combined with torque vectoring PI regulator Fuzzy The second type of control, based on fuzzy logic, has been developed recently. In this case, the percentage of torque applied to each wheel has been computed based on the yaw rate and the sideslip angle. The fuzzy logic is an extension of Boolean logic, allowing to obtain results also between 0 and 1. The fuzzy controller use the same yaw rate estimator of the PI regulator, but implement a totally different yaw-rate tracking technique. The fuzzy yaw moment controller manages the lateral torque distribution ( \\(\\tau_{\\text {lat }}\\) ) for the vehicle. If \\(\\tau_{\\text {lat }}=-1\\) , the maximum torque difference will be added to the rear right wheel torque request of the driver and subtracted to the rear wheel of the left side. The design of the system has been developed with the following structure for the input (Figure 8): 5 membership functions for the yaw rate error (computed as for the PI); 5 membership functions for the derivative of the yaw rate error (this derivative has a gain lower than 1 to give much importance to the yaw rate error); Figure 8 - Computation of the torque percentage (fuzzy logic) Then has been developed also the membership functions for the output (nine), representing the percentage of torque that each motor has to apply to the corresponding rear wheel. At the end, the rules of this decisional logic of the controller have been written (file TV fuzzy) to establish the I/O behaviour (Figure 9). Figure 9 - Membership functions The trapezoidal membership functions have been selected for the boundaries of each variable since the proposed controller tries to minimize each variable and, therefore, accuracy is not the highest priority. The triangular ones have been used for the rest of the functions, as they provide computationally efficient calculations maintaining acceptable smoothness on the response. The membership functions have been converted in a look-up table to increase the speed in the response [1]. Testing and Tuning Once the control is tuned, its performances can be evaluated to analyze if it works properly. With all controls active can be shown that the vehicle can anticipate the trajectory thanks to the torque vectoring control developed and described above. In Figure 10 it is described a ramp steer manouvre with and without controls. Figure 10 - Ramp steer manoeuvre with and without controls Conclusions In conclusion, the team has decided to not implement the control for the race, until some robust tests will be performed in a safety track, validating both model and controls. In particular, it\u2019s necessary to understand the influence of the delays due to pilot response, controls and data elaborations and the behaviour in the real word. Furthermore, more tests will be necessary to compare the behaviour of PI controller and fuzzy logic, to understand which is more suitable for the application to a Formula SAE vehicle. From the simulation the PI control is slightly better, both for performances and elaboration time. Revision History V1.0 27/10/2021 - Initial release (Francesco Meneghin)","title":"Torque Vectoring Theory"},{"location":"fenice-vehicle-model-DMT/Theory/Torque_Vectoring/#torque-vectoring-theory","text":"","title":"Torque Vectoring Theory"},{"location":"fenice-vehicle-model-DMT/Theory/Torque_Vectoring/#introduction-to-lateral-dynamics","text":"The control system VDC (Vehicle Dynamic Control), also known as ESP, VDS or DSC, is an active security system used to correct the vehicle trajectory in emergency conditions and with low adherence. In particular, the main two conditions that this control wants to reduce are understeer and oversteer. Both the behaviours can be compensated by generating a proper yawing or anti-yawing torque. For vehicles endowed with active differential, the implementation of this control is mainly realized with Torque Vectoring.","title":"Introduction to Lateral Dynamics"},{"location":"fenice-vehicle-model-DMT/Theory/Torque_Vectoring/#reference-system","text":"The reference systems adopted for the dynamic behaviour analysis are shown in Figure 1. The origin of the mobile system is positioned at the intersection between the roll and the symmetry axis. Furthermore, the \\(\\mathrm{x}\\) -axis is always longitudinal to the vehicle. The velocities along \\(\\mathrm{x}\\) and \\(\\mathrm{y}\\) are called respectively \\(u\\) and \\(v\\) (for the moveable system), whereas the side-slip angle \\(\\beta\\) describes the direction of the resultant vector for the moveable triad. The other parameter necessary for the moment-by-moment analysis of the position and direction of the vehicle is the yaw angle \\(\\varphi\\) between the fixed X-axis and the x-axis of the mobile system. The steering angle, instead, is called \\(\\delta\\) . Figure 1 - Reference System","title":"Reference system"},{"location":"fenice-vehicle-model-DMT/Theory/Torque_Vectoring/#lateral-dynamics-control","text":"For a perfect turning behaviour of the vehicle is necessary to split in a different way the torque of the motors between the two rear driving wheels avoiding both under and oversteer. Because of dissimilar longitudinal forces on the rear tires \\(\\left(\\mathrm{F}_{\\mathrm{drl}}\\right.\\) and \\(\\left.\\mathrm{F}_{\\mathrm{drr}}\\right)\\) is generated a yaw couple \\(\\left(\\mathrm{N}_{\\mathrm{z}}\\right)\\) object of the Torque Vectoring Control (TV). The goal of this control is to maximize the longitudinal properties of the vehicle, allowing high manoeuvrability of the car while cornering. Figure 2 - Torque Vectoring Principle The modelling of the TV control is based on the yaw rate (yaw velocity) \\(\\Omega\\) instead of the side-slip angle \\(\\beta\\) because \\(\\Omega\\) is: easier to measure; nearest to the drive perception.","title":"Lateral Dynamics Control"},{"location":"fenice-vehicle-model-DMT/Theory/Torque_Vectoring/#yaw-rate-estimation","text":"For estimating the yaw rate, the team has connected the inputs given by the pilot, like the steering angle and the accelerator, with the car's behaviour. For the construction of the transfer function, it is possible to start from the single-track linear model of the vehicle, analyzing its dynamic behaviour (Equation 1) depending on the mass of the system \\((\\mathrm{m})\\) , the lateral forces \\(\\left(\\mathrm{F}_{\\mathrm{y}}\\right)\\) and the harms of the front/rear axles from the centre of gravity \\(\\left(L_{f}-L_{r}\\right)\\) . \\[ \\left\\{\\begin{array}{l} m a_{y}=F_{y r}+F_{y f} \\\\ I_{z z} \\dot{\\Omega}=-L_{r} F_{y r}+L_{f} F_{y f} \\end{array}\\right. \\] Equation 1 - Dynamic behaviour of the vehicle It is possible to rewrite the equations depending on \\(\\mathrm{C}\\) (lateral stiffness of the tires) and \\(\\rho\\) (curvature), considering a linear behaviour of the vehicle in a stationary regime. Solving these equations can be found a relationship between the side-slip angle of the tires (Equation 2 and Equation 3). \\[ \\left\\{\\begin{array}{l} F_{y r}=C_{r} \\alpha_{r} \\\\ F_{y f}=C_{f} \\alpha_{f} \\\\ m a_{y s s}=\\rho u^{2} \\end{array}\\right. \\] Equation 2 - Rewriting of the equations \\[ \\alpha_{f}-\\alpha_{r}=\\frac{m \\rho+u^{2}}{L}(\\frac{L_{r}}{C_{f}}-\\frac{L_{f}}{C_{r}}) \\] Equation 3 - Relation between side-slip angles It is also possible to define the understeering coefficient \\((\\mathrm{K}_{\\mathrm{us}})\\) and the general expression of the side-slip angles (Equation 4 and Equation 5), function of the side-slip angle of the chassis \\((\\beta)\\) . \\[ K_{us}=\\frac{m}{L}(\\frac{L_{r}}{C_{f}}-\\frac{L_{f}}{C_{r}}) \\\\ \\] Equation 4 - Understeering coefficien \\[ \\begin{array}{l} \\alpha_{f}=\\beta+\\frac{\\Omega}{u} L_{f}-\\delta \\\\ \\alpha_{r}=\\beta-\\frac{\\Omega}{u} L_{r}-\\delta \\end{array}. \\] Equation 5 - General expression for side-slip angles Combining the previous equations can be found a direct relationship between the steering angle \\(\\delta\\) and the yaw rate (Equation 6). \\[ \\frac{L+K_{u s} u^{2}}{u}=\\frac{\\delta}{\\Omega} \\] Equation 6 - Relation between the steering angle and the yaw rate It is possible to introduce a first-order system with a \\(\\tau_{\\text {driver }}=0.1\\) (Equation 7), considering the slight delay in the driver's response (especially during steering maneuvers) due to his reflexes and the nonlinearity of the real world. The \\(\\Omega_{\\text {des }}\\) becomes: \\[ \\Omega=\\frac{\\frac{u}{L+K_{u s} u^{2}}}{\\tau_{\\text {driver }} s+1} \\delta \\] Equation 7 - Yaw rate expression with the adding of a first-order filter The filter for the driver response has been modelled in the block of the vehicle model in which the simulated inputs of the driver (brake, throttle, and steering angle) are computed for different manoeuvres. With this model, the pilot will be able to generate the desired yaw rate, acting directly on the steering angle and indirectly on the longitudinal velocity of the vehicle. The transfer function, by the way, depends on the lateral behaviour of the car through the parameter \\(\\mathrm{K}_{\\mathrm{us}}\\) , which can affect the vehicle response: Understeering Vehicle \\((K>\\mathbf{0})\\) : the vehicle curves less than desired. This behaviour is often applied to commercial cars; Neutral Vehicle \\((K=0)\\) Oversteering Vehicle \\((K<\\mathbf{0})\\) : the car tends to curve more than desired. This behaviour is usually employed in racing cars. For modelling the \\(\\mathrm{K}_{\\text {us }}\\) of the vehicle is possible to test this parameter with a fixed steering angle and a variable velocity of the car and building also the handling curves. The resulting Simulink model, employed for Fenice, is described in Figure 3. Figure 3 - Yaw rate estimation in the Simulink model of Fenice","title":"Yaw Rate Estimation"},{"location":"fenice-vehicle-model-DMT/Theory/Torque_Vectoring/#realization-of-the-tv-control","text":"For the designing of the control system, the team has adopted two different solutions: PID (proportional-integral-derivative) controller; Fuzzy logic controller.","title":"Realization of the TV Control"},{"location":"fenice-vehicle-model-DMT/Theory/Torque_Vectoring/#pid","text":"The PID controller is the first type of control implemented by the team, also in the former car (Chimera) model, to compensate for the error of the reference yaw rate compared with the one measured in practice. For the development of the system, it is possible to start from a linearized singletrack model described with Equation 8. It is possible to build a simplified model (Equation 9): the linear bicycle model (single axel and front steering wheel). \\[ \\left\\{\\begin{array}{l}I_{z} \\dot{\\Omega}=\\left(L_{f} C_{f}-L_{r} C_{r}\\right) \\beta+\\frac{\\left(L_{f}^{2} C_{f}-L_{r}^{2} C_{r}\\right) \\Omega}{u}-L_{f} C_{f} \\delta \\\\m u(\\Omega+\\dot{\\beta})=C_{f}\\left(\\beta+\\frac{\\Omega L_{f}}{u}-\\delta\\right)+C_{r}\\left(\\beta-\\frac{\\Omega L_{r}}{u}\\right)\\end{array}\\right. \\\\ \\] Equation 8 - Linearized single-track model \\[ \\left\\{\\begin{array}{l}\\dot{x}=A x+B u \\\\y=C x+D u\\end{array} \\quad x=\\left[\\begin{array}{l}\\beta \\\\\\Omega\\end{array}\\right], u=\\left[\\begin{array}{c}\\delta \\\\N_{z}\\end{array}\\right]\\right. \\\\ \\] \\[ A=\\left[\\begin{array}{cc}\\frac{C_{r}+C_{f}}{m u} & \\frac{-C_{r} L_{r}+C_{f} L_{f}}{m u^{2}}-1 \\\\\\frac{-C_{r} L_{r}+C_{f} L_{f}}{I_{z}} & \\frac{C_{r} L_{r}^{2}+C_{f} L_{f}^{2}}{u I_{z}}\\end{array}\\right] \\quad B=\\left[\\begin{array}{cc}0 & 0 \\\\1 / I_{z} & 0\\end{array}\\right] \\quad C=\\left[\\begin{array}{ll}0 & 1\\end{array}\\right] \\quad D=\\left[\\begin{array}{ll}0 & 0\\end{array}\\right] \\] Equation 9 - Linear Model The state matrix A depends on the velocity, so the control must modify its action following the speed variation. The team has chosen a PI controller (the derivative of the yaw-rate is already present in the model itself) with variable gain, a first crossover frequency of \\(13 \\mathrm{rad} / \\mathrm{s}\\) , and a phase margin of 70 degrees with particular attention to disturbances rejection. The tuning procedure is performed using the MATLAB tools, linearizing the model at different speeds, and tuning a PI controller for the step response. The linearization is made around a steadystate configuration and gives out the transfer functions between the yaw-moment - output of the PI and the yaw-rate. The steering angle must be small \\(\\left(\\sim 5^{\\circ}\\right)\\) to be considered a disturbance. It is possible to tune a reference controller on the linearized system, respecting some design parameters. The stability requirements are: - Phase margin \\(=70^{\\circ}:\\) it is a large value of phase margin - close to \\(90^{\\circ}\\) - which makes the system stable also with disturbances but delays the response of the controller; Crossover frequency \\(=13 \\mathrm{rad} / \\mathrm{s}\\) : after some tuning using different crossover frequencies, it is the most appropriate for the application; Disturbance rejection: to reject model linearization errors or the disturbance from the steering angle, the PID must be tuned for a robust closed-loop system to disturb. For the gain of the PI, it is possible, in conclusion, to develop a look-up table (Figure 4, Figure 5) for each different set-point velocity, that for Fenice's controller are eigth (Equation 10). \\[ \\begin{aligned} & u_{c t r}=\\left[\\begin{array}{llllllll}20 & 30 & 40 & 50 & 60 & 70 & 80 & 90\\end{array}\\right] \\mathrm{km} / \\mathrm{h} \\\\ \\end{aligned} \\] Equation 10 - Set-point velocities Figure 4 - Look-up table of the proportional variable gain Figure 5 - Look-up table of the integral variable gain The lock-up tables found with the tuning are then used as inputs for the PI regulator that controls in closed-loop the error between desired and measured yaw rate (Figure 6) Figure 6 - PI controller The output of the PI controller is saturated, imposing a limit to the ammissible values of \\(\\mathrm{N}_{\\mathrm{Z}}(\\) Equation \\(11)\\) in which \\(w_{r}\\) is rear track width, \\(\\Delta T_{m_{\\max }}\\) the maximum torque difference of the motors, \\(r_{r}\\) the rear wheels radius, \\(\\tau_{\\text {red }}\\) the transmission ratio of the gearbox and \\(e f f_{\\text {red }}\\) the efficiency of the gearbox. The \\(\\Delta T_{m_{\\text {max }}}\\) is then regulated by the driver on the steering wheel with TV maps, setting a percentage of the maximum \\(\\Delta T_{m_{\\max }}\\) (which is equal to \\(55 \\mathrm{Nm}\\) with full TV action active and \\(0 \\mathrm{Nm}\\) with \\(\\mathrm{TV}\\) deactivated). \\[ \\left|N_{z_{\\max }}\\right|=\\frac{\\Delta T_{m_{\\max }} \\cdot w_{r} \\cdot \\tau_{\\text {red }} \\cdot e f f_{r e d}}{2 r_{r}} \\\\ \\] Equation 11 - Saturation of the PI controller In reality, as described above, the actuators can be saturated. Consequently, the action of the integral control would continue to grow with an accumulation of error. For this reason, it is possible to introduce an anti-windup system embedded in the PI controller (clamping method). At the output of the yaw rate controller, inverting the Equation 11 is possible to compute the value of \\(\\Delta \\mathrm{T}_{\\mathrm{m}}\\) for computing the torque that the motors need to apply. The motor torques curves used are also chosen by the driver at the steering wheel, with 6 possible different maps (map 6 is the one that allows the higher longitudinal performances). The team has decided to modify the torque motor saturation favouring cornering behaviour at the expense of longitudinal performances, considering the desired \\(\\Omega\\) not always perfectly reachable (for example, when the motors are saturated). The pre-existing version gave priority to the longitudinal performance keeping constant the sum of the torque of the two actuators. For example, if the driver request was \\(70 \\mathrm{Nm}\\) for each motor with saturation torque of \\(80 \\mathrm{Nm}\\) and differential torque of \\(15 \\mathrm{Nm}\\) , a wheel should have \\(85 \\mathrm{Nm}(5 \\mathrm{Nm}\\) more than \\(80 \\mathrm{Nm}\\) of the saturation). To keep \\(140 \\mathrm{Nm}\\) of total torque, the other motor must generate \\(60 \\mathrm{Nm}\\) with a resulting differential torque equal to \\(10 \\mathrm{Nm}(5 \\mathrm{Nm}\\) less than the desired differential torque). Since the torque vectoring is a lateral controller, this strategy could negatively affect the cornering performance of the controller. So, it is preferable to privilege the differential torque, following the driver's request. For the same previous example, to maintain \\(15 \\mathrm{Nm}\\) of differential torque, one motor must be saturated, and the other must generate \\(50 \\mathrm{Nm}\\) . In this way, the total torque is \\(130 \\mathrm{Nm}\\) (previously \\(140 \\mathrm{Nm}\\) ), reducing the longitudinal acceleration but allowing for better cornering behaviour. In conclusion, it is possible to also limit the errors due to the noise influence that can activate torque vectoring when the driver is not cornering. So, for this reason, the team has decided that torque vectoring control will be active only with steering angle of the front wheels \\(|\\delta|>2^{\\circ}\\) and with a longitudinal velocity greater than \\(5 \\mathrm{~m} / \\mathrm{s}\\) (for the PI controller).","title":"PID"},{"location":"fenice-vehicle-model-DMT/Theory/Torque_Vectoring/#slip-control-combined-with-pi-controller-with-torque","text":"The team has connected the slip controller outputs as a saturation of the torque vectoring to combine the two controllers (Figure 7). The saturation block limits the torque considering the differential torque output from the torque vectoring: if the higher torque wheel starts to slide, the slip controller reduces the torque for that wheel. In addition, at the same time, it limits the torque at the other wheel too, to maintain the differential torque. Figure 7 - Slip control combined with torque vectoring PI regulator","title":"Slip control combined with PI controller with torque"},{"location":"fenice-vehicle-model-DMT/Theory/Torque_Vectoring/#fuzzy","text":"The second type of control, based on fuzzy logic, has been developed recently. In this case, the percentage of torque applied to each wheel has been computed based on the yaw rate and the sideslip angle. The fuzzy logic is an extension of Boolean logic, allowing to obtain results also between 0 and 1. The fuzzy controller use the same yaw rate estimator of the PI regulator, but implement a totally different yaw-rate tracking technique. The fuzzy yaw moment controller manages the lateral torque distribution ( \\(\\tau_{\\text {lat }}\\) ) for the vehicle. If \\(\\tau_{\\text {lat }}=-1\\) , the maximum torque difference will be added to the rear right wheel torque request of the driver and subtracted to the rear wheel of the left side. The design of the system has been developed with the following structure for the input (Figure 8): 5 membership functions for the yaw rate error (computed as for the PI); 5 membership functions for the derivative of the yaw rate error (this derivative has a gain lower than 1 to give much importance to the yaw rate error); Figure 8 - Computation of the torque percentage (fuzzy logic) Then has been developed also the membership functions for the output (nine), representing the percentage of torque that each motor has to apply to the corresponding rear wheel. At the end, the rules of this decisional logic of the controller have been written (file TV fuzzy) to establish the I/O behaviour (Figure 9). Figure 9 - Membership functions The trapezoidal membership functions have been selected for the boundaries of each variable since the proposed controller tries to minimize each variable and, therefore, accuracy is not the highest priority. The triangular ones have been used for the rest of the functions, as they provide computationally efficient calculations maintaining acceptable smoothness on the response. The membership functions have been converted in a look-up table to increase the speed in the response [1].","title":"Fuzzy"},{"location":"fenice-vehicle-model-DMT/Theory/Torque_Vectoring/#testing-and-tuning","text":"Once the control is tuned, its performances can be evaluated to analyze if it works properly. With all controls active can be shown that the vehicle can anticipate the trajectory thanks to the torque vectoring control developed and described above. In Figure 10 it is described a ramp steer manouvre with and without controls. Figure 10 - Ramp steer manoeuvre with and without controls","title":"Testing and Tuning"},{"location":"fenice-vehicle-model-DMT/Theory/Torque_Vectoring/#conclusions","text":"In conclusion, the team has decided to not implement the control for the race, until some robust tests will be performed in a safety track, validating both model and controls. In particular, it\u2019s necessary to understand the influence of the delays due to pilot response, controls and data elaborations and the behaviour in the real word. Furthermore, more tests will be necessary to compare the behaviour of PI controller and fuzzy logic, to understand which is more suitable for the application to a Formula SAE vehicle. From the simulation the PI control is slightly better, both for performances and elaboration time.","title":"Conclusions"},{"location":"fenice-vehicle-model-DMT/Theory/Torque_Vectoring/#revision-history","text":"V1.0 27/10/2021 - Initial release (Francesco Meneghin)","title":"Revision History"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/","text":"Vehicle Model for Simulation In this report, the theory behind the vehicle model is briefly explained. This allows us to understand how the simulation environment works and how to define some of the most important characteristics of the vehicle kinematics and dynamics. The model parameters are selected in order to simulate the behaviour of the Trento Formula SAE racing vehicle, called Chimera Evoluzione (figure 11). In the original model, the tires behaviour is simulated using the Pacejka formulation. However, in the validated version of the model, the tires characteristics will be modelled using a simplified tire model, defined in a dedicated paper. The description follows the works done by Piccinini M. in his thesis [16]. In order to extract equation of motion, the symbolic computation software Maple \\(^{\\circledR}\\) is used, with the multibody library MBSymba \\(^{\\circledR}\\) [13]. Figure 1: Photo of Chimera Evoluzione (Tests of 09-11-2020) Vehicle kinematics As first, we have to define the vehicle reference frame \\(\\left(R F_{V}\\right)\\) with respect to an absolute fixed reference frame \\(\\left(R F_{0}\\right)\\) . The vehicle reference frame has its origin in the projection of the vehicle Centre of Mass (CoM) in the xy absolute plane, the \\(\\mathrm{x}\\) -axis points in the vehicle forward direction and the z-axis points upward. The transformation from \\(R F_{0}\\) to \\(R F_{V}\\) is a translation of \\(\\{\\mathrm{x}, \\mathrm{y}, 0\\}\\) and a rotation of the yaw angle \\((\\psi)\\) around the z-axis, as depicted in figure 2 . Figure 2: 2D representation of the vehicle reference frames With reference to figure \\(2, R F_{V}\\) moves with a linear velocity \\(\\left\\{v_{x}, v_{y}, 0\\right\\}\\) and an angular velocity along the z-axis of \\(\\Omega=\\dot{\\psi}\\) . Projecting these components in the vehicle reference frame, the longitudinal and the lateral velocity \\((u\\) and \\(v)\\) can be defined. For definition, the angle \\(\\beta\\) , called Body Side Slip Angle, is the angle between the absolute velocity vector \\(\\left(\\bar{V}_{G}\\right)\\) and the \\(x_{V}\\) axis. Until now, the vehicle is shown as a rigid body that moves in the absolute ground plane. To proceed with the kinematic analysis, it is useful to distinguish between the Spring and Un-Spring masses. The Un-Spring masses correspond to the parts of the vehicle \"constrained\" to the ground - i.e. the tires, the wheels, the hub and part of the suspensions assembly -. The spring masses, instead, are the vehicle parts above the suspensions, namely that parts of the vehicle that can moves under the effects of suspensions deformation - for example, the remaining part of the suspensions, the chassis, the motors, the inverters or the driver \\(-\\) . The spring masses have 3 additional Degrees of Freedom that corresponds to the Roll \\((\\phi)\\) the Pitch \\((\\theta)\\) and the Heave \\((z)\\) motion. These are the components of the so-called internal kinematics. In particular, the Roll Axis has to be modelled. It is the axis around which the vehicle rolls and depends on the suspension geometry. Specifically, assuming the vehicle as symmetric, the Roll Axis lives in the \\(\\mathrm{xz}\\) vehicle plane and pass through the front and rear Roll Centres: points with a height of \\(h_{R F}\\) and \\(h_{R R}\\) respectively. The angle between the Roll Axis and the \\(x_{V}\\) axis, in static case, is called \\(\\alpha_{r a}\\) . The geometric representation of the internal kinematics geometry is depicted in figure 3 Figure 3: Roll axis position \\[ \\alpha_{r a}=\\operatorname{atan}\\left(\\frac{h_{R R}-h_{R F}}{L_{R}+L_{F}}\\right) \\quad ; \\quad h_{R}=h_{R F}+\\alpha_{r a} L_{F} \\] In order to mathematically define the internal kinematics, an auxiliary reference frame \\(\\left(R F_{S, a}\\right)\\) is defined, starting from the vehicle reference frame. In the static condition, this new frame has the origin in the point \\(P_{R}\\) , depicted in figure 3. The \\(\\mathrm{x}\\) axis that coincides with the roll axis and points in the vehicle forward direction. The \\(\\mathrm{z}\\) axis points upward. Besides, the auxiliary reference frame is free to move along the \\(z_{V}\\) axis to model the heave motion. From \\(R F_{S, a}\\) , the others internal kinematic motion can be defined in order to find the Spring masses reference frame \\(\\left(R F_{S}\\right)\\) : firstly, the pitch along y and, secondly, the roll motion along \\(\\mathrm{x}\\) . Since the angles are small, the transformation matrix between \\(R F_{S, a}\\) and \\(R F_{S}\\) can be linearized. The result is shown in 2 . \\[ T_{R F_{S, a} \\rightarrow R F_{S}}=\\left[\\begin{array}{cccc} 1 & 0 & \\theta(t) & 0 \\\\ 0 & 1 & -\\phi(t) & 0 \\\\ -\\theta(t) & \\phi(t) & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right] \\] In order to resume the transformations, they are collected in relation 3. \\[ \\begin{gathered} \\left\\{\\begin{array}{l} R F_{V} \\quad=R F_{0} \\cdot T(x(t), y(t), 0) \\cdot R_{Z}(\\psi(t)) \\\\ R F_{S, a}=R F_{V} \\cdot T\\left(0,0, h_{R}+z(t)\\right) \\cdot R_{Y}\\left(\\alpha_{r a}\\right) \\\\ R F_{S}=R F_{S, a} \\cdot R_{Y}(\\theta(t)) \\cdot R_{X}(\\phi(t)) \\approx R F_{S, a} \\cdot T_{R F_{S, a} \\rightarrow R F_{S}} \\end{array}\\right. \\\\ T(a, b, c)=\\left[\\begin{array}{llll} 1 & 0 & 0 & a \\\\ 0 & 1 & 0 & b \\\\ 0 & 0 & 1 & c \\\\ 0 & 0 & 0 & 1 \\end{array}\\right] \\\\ R_{X}(\\alpha)=\\left[\\begin{array}{cccc} 1 & 0 & 0 & 0 \\\\ 0 & \\cos (\\alpha) & -\\sin (\\alpha) & 0 \\\\ 0 & \\sin (\\alpha) & \\cos (\\alpha) & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right] \\\\ R_{Y}(\\alpha)=\\left[\\begin{array}{ccccc} \\cos (\\alpha) & 0 & \\sin (\\alpha) & 0 \\\\ 0 & 1 & 0 & 0 \\\\ -\\sin (\\alpha) & 0 & \\cos (\\alpha) & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right] \\quad R_{Z}(\\alpha)=\\left[\\begin{array}{cccc} \\cos (\\alpha) & -\\sin (\\alpha) & 0 & 0 \\\\ \\sin (\\alpha) & \\cos (\\alpha) & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right] \\end{gathered} \\] Vehicle Dynamics Definition of the Bodies Equations of motion are derived by means of the Newton-Euler method. The bodies definition is necessary to start the dynamic analysis. Vehicle body The vehicle body consists of the whole vehicle body in the static configuration. It has a mass of \\(M\\) and an inertia tensor equal to \\(\\left[I_{V}\\right]\\) . The inertia components \\(I_{x y, V}\\) and \\(I_{y z, V}\\) are negligible with respect to the other terms of the matrix so they can be set equal to zero. The centre of mass of this body is always placed in the point \\(\\left[0,0, h_{G 0}\\right]\\) of the vehicle reference frame \\(\\left(R F_{V}\\right)\\) . \\[ \\left[I_{V}\\right]=\\left[\\begin{array}{ccc} I_{x x, V} & 0 & -I_{x z, V} \\\\ 0 & I_{y y, V} & 0 \\\\ -I_{x z, V} & 0 & I_{z z, V} \\end{array}\\right] \\] Chassis body The chassis body models the spring masses. For this reason, its mass is equal to \\(m_{S}\\) and its inertia tensor is \\(\\left[I_{C}\\right]\\) . Similarly to the vehicle case, \\(\\left[I_{V}\\right]\\) has the \\(x y\\) and \\(y z\\) terms that can be set to zero. The centre of mass of the chassis reference frame is placed in the origin of \\(R F_{S}\\) . \\[ \\left[I_{C}\\right]=\\left[\\begin{array}{ccc} I_{x x, C} & 0 & -I_{x z, C} \\\\ 0 & I_{y y, C} & 0 \\\\ -I_{x z, C} & 0 & I_{z z, C} \\end{array}\\right] \\] Wheels bodies The wheels bodies are four and its mass is \\(m_{W}\\) . Each wheel has an associated reference frame, with the origin in the wheel centre, that is fixed with respect to the wheel. Starting from the vehicle reference frame, the applied transformations are shown in relation 6. \\[ \\left\\{\\begin{array}{l} R F_{W, R R}=T\\left(-L_{R},-W_{R} / 2, R_{R}\\right) \\cdot R_{Y}\\left(\\xi_{R R}(t)\\right) \\\\ R F_{W, R L}=T\\left(-L_{R}, W_{R} / 2, R_{R}\\right) \\cdot R_{Y}\\left(\\xi_{R L}(t)\\right) \\\\ R F_{W, F R}=T\\left(L_{F},-W_{F} / 2, R_{F}\\right) \\cdot R_{Z}\\left(\\delta_{F R}\\right) \\cdot R_{Y}\\left(\\xi_{F R}(t)\\right) \\\\ R F_{W, F L}=T\\left(L_{F}, W_{F} / 2, R_{F}\\right) \\cdot R_{Z}\\left(\\delta_{F L}\\right) \\cdot R_{Y}\\left(\\xi_{F L}(t)\\right) \\end{array}\\right. \\] The suffix of the reference frames corresponds to the wheel position: \\(R R\\) rear-right, \\(R L\\) real-left, \\(F R\\) front-right and \\(F L\\) front-left. This notation will be used to label the position of different quantities during this work. \\(W_{F}\\) and \\(W_{R}\\) are the front and the rear track-width respectively while \\(R_{F}\\) and \\(R_{R}\\) are the front and rear wheel radii. The angles \\(\\delta\\) are the steering angle at the wheels. Since the vehicle is front wheel steering, the associated rotation is performed only to the front wheels. The angles \\(\\xi\\) , instead, model the wheel spin. The inertia tensor is diagonal and it is equal to \\(\\left[I_{W}\\right]\\) . \\[ \\left[I_{W}\\right]=\\left[\\begin{array}{ccc} I_{d, W} & 0 & 0 \\\\ 0 & I_{a, W} & 0 \\\\ 0 & 0 & I_{d, W} \\end{array}\\right] \\] Anti-bodies In equation of motion, the main vehicle motion \\((x(t), y(t)\\) and \\(\\psi(t))\\) are associated to the vehicle, while the other Degrees of Freedom, called also relative, are associated to the chassis and to the wheels. In order to neglect the static term from the chassis and from the wheels - the static term is already addressed by the vehicle body - special constructs are named anti-bodies. They are virtual bodies with the inertia components negative with respect to the associated body and placed in the static position of the related body, i.e. their relative DoF are set equal to zero. Tire model In the model of Piccinini [16], an high fidelity semi-empirica) tire model is used in order to model the tire characteristics. In particular, the Pacejka tire model allows us to have a precise steady-state representation of the tire behaviour. The tire model returns the longitudinal and lateral tire force \\(\\left(F_{x}\\right.\\) and \\(\\left.F_{y}\\right)\\) and the self-aligning moment \\(\\left(M_{z}\\right)\\) as a function of the practical slip \\((\\bar{\\kappa})\\) , the tire vertical load \\(\\left(F_{z}\\right)\\) and the wheel camber \\((\\gamma)\\) . The camber is the angle between the wheel middle plane and the xz-vehicle plane. This angle is not fixed but varies with the suspension deflection. Using the suspension kinematic model, a roll-to-camber map is fitted in order to address the angle variation as a function of the roll angle. The tire slip is computed starting from the wheel speeds with reference to figure 4 . Figure 4: Tire top view: the wheel speeds are highlighted The rolling velocity is equal to the product between the wheel angular velocity and the wheel radius \\(-\\bar{v}_{r}=[\\omega R, 0,0]^{T}-\\) . The contact point velocity \\(\\left(\\bar{v}_{c}\\right)\\) depends on the vehicle velocity and is a \\(2 \\mathrm{D}\\) vector that lives in the ground plane. The sliding velocity is the vectorial difference between the contact point and the rolling velocity \\(-\\bar{v}_{s}=\\bar{v}_{c}-\\bar{v}_{r}\\) \\({ }^{1}\\) The semi-empirical models uses physical based information in order to fit very sophisticated behaviour with a simpler mathematical function. This approach makes the computation cheaper and the simulation faster. -. Then, the practical slip can be defined as reported in 8 . \\[ \\bar{\\kappa}=\\left[\\begin{array}{c} \\lambda \\\\ \\tan (\\alpha) \\end{array}\\right]=-\\frac{\\bar{v}_{s}}{\\left|v_{c, x}\\right|}=\\left[\\begin{array}{c} -\\left(v_{c, x}-\\omega R\\right) /\\left|v_{c, x}\\right| \\\\ -v_{c, y} /\\left|v_{c, x}\\right| \\end{array}\\right] \\] The longitudinal slip can be also called \\(\\kappa\\) . In conclusion, the tire model evaluates the following functions. \\[ \\begin{cases}F_{x} & =F_{x}\\left(\\lambda, \\alpha, F_{z}, \\gamma\\right) \\\\ F_{y} & =F_{y}\\left(\\lambda, \\alpha, F_{z}, \\gamma\\right) \\\\ M_{z} & =M_{z}\\left(\\lambda, \\alpha, F_{z}, \\gamma\\right)\\end{cases} \\] Slip transient model In order to consider also the transient in the tire model, a first-order dynamical equation can be applied to the slip. Experimentally, it is possible to observe that this assumption well approximates the real tire behaviour. The time constant of the dynamical equation can be written as a function of the vehicle longitudinal speed and of the tire relaxation length \\(-l_{i}\\) with \\(i=\\{x, y\\}-\\) . The latter is assumed to be constant and describes the distance, covered by the rolling tire, at which the transient finishes. \\[ \\left\\{\\begin{array}{l} \\frac{l_{x}}{|u(t)|} \\frac{d \\lambda(t)}{d t}+\\lambda(t)=\\lambda_{S S}(t) \\\\ \\frac{l_{y}}{|u(t)|} \\frac{d \\alpha(t)}{d t}+\\alpha(t)=\\alpha_{S S}(t) \\end{array}\\right. \\] The terms with the lowercase \\(S S\\) represents the steady-state slip value, computed using equation 8, while, the terms without the \\(S S\\) corresponds to the transient slip. Low speed slip correction The steady-state slip definition, defined in 8 , becomes singular when the longitudinal vehicle speed tends to zero. Besides, the longitudinal transient slip 10 may oscillate under the effects of a step input torque at low vehicle speed. These non-physical oscillations may remain for a relatively long time. In order to address the singularity problem, a smooth function is introduced in order to avoid the annulment of the slip denominator - ref. to expression 8 and figure 5 -. \\[ \\left|v_{c, x}\\right| \\longrightarrow \\operatorname{smooth}\\left(\\left|v_{c, x}\\right|\\right)=\\frac{1}{2}\\left(V_{\\text {low }}+\\frac{v_{c, x}^{2}}{V_{\\text {low }}}\\right) \\] Figure 5: Smooth Function \\(V_{\\text {low }}\\) is a threshold velocity that allows us to split the high and low speed. The smooth function is applied only if \\(V_{\\text {low }} \\geq\\left|v_{c, x}\\right|\\) . Usually, this threshold is set to \\(1 \\mathrm{~m} / \\mathrm{s}\\) . In order to cancel the oscillation phenomenon, instead, it is possible to introduce a virtual damping factor \\(\\left(K_{V_{\\text {low }}}\\right)\\) that aims to smooth these oscillations. \\[ \\lambda \\longrightarrow \\lambda-\\frac{K_{V_{\\text {low }}}}{C_{F_{\\lambda}}} v_{s, x} \\] In 12, \\(C_{F_{\\lambda}}\\) is the longitudinal tire stiffness, i.e. the slope of the tire characteristic when \\(\\lambda=0\\) and \\(v_{s, x}\\) is the longitudinal component of the sliding velocity with reference to figure 4 This correction is applied only for low speed. For this reason, it is needed a function that smoothly goes to zero when the speed tends to \\(V_{\\text {low }}\\) . \\[ K_{V_{\\text {low }}}= \\begin{cases}\\frac{1}{2} K_{V_{\\text {low }}, 0}\\left[1+\\cos \\left(\\pi \\frac{|u(t)| \\mid}{V_{\\text {low }}}\\right)\\right] & \\text { if }|u| \\leq V_{\\text {low }} \\\\ 0 & \\text { if }|u|>V_{\\text {low }}\\end{cases} \\] With a proper tuning of \\(K_{V_{\\text {low }, 0}}\\) , the non-physical oscillations can completely disappear. However, this correction may introduce instability problems around the threshold velocity \\(V_{\\text {low }}\\) . Powertrain model The powertrain of the considered electric vehicle is composed of two permanent magnets three-phase electric motors - model Emrax 208 -, two inverters, the speed reducers and the battery pack - \\(6.5 \\mathrm{kWh}-\\) . From Formula SAE rules, the maximum power of the battery pack is \\(80 \\mathrm{~kW}\\) . This is computed as follow. \\[ P_{\\text {batt }}=V_{\\text {batt }} I_{\\text {batt }} \\] Where \\(P_{\\text {batt }}\\) is the battery power, in watt, \\(V_{\\text {batt }}\\) is the voltage supply, in volt, and \\(I_{\\text {batt }}\\) is the provided current, in ampere. The maximum voltage is \\(E_{\\text {batt }}=450 \\mathrm{~V}\\) . \\(V_{\\text {batt }}\\) can be computed starting from \\(E_{\\text {batt }}\\) and subtracting the potential drop due to the internal battery cells resistance \\(-V_{\\text {batt }}=E_{\\text {batt }}-I_{\\text {batt }} R_{\\text {tot }}\\) with \\(R_{\\text {tot }} \\approx 0.46 \\Omega-\\) . Knowing that the inverters convert the DC voltage into an AC three-phase voltage and assuming that the power is split in a symmetric way between the two motors, it is possible to compute the effective motor current \\(\\left(I_{m o t, r m s}\\right)\\) . This current is used to compute the motor torque by means of the motor characteristic. The motors are connected to an ordinary single-stage gearbox with transmission ratio \\(\\tau_{\\text {red }}=52 / 15\\) and with efficiency \\(\\left(\\eta_{\\text {red }}\\right)\\) around \\(0.93\\) . Each motor is able to provide \\(80 \\mathrm{Nm}\\) when the battery pack is fully charge. This torque is almost constant in the entire velocity range, from 0 to \\(\\omega_{\\text {mot,Max }}\\) - for this motors, \\(\\omega_{\\text {mot }, \\text { Max }} \\approx 5200 \\mathrm{rpm}-\\) . The torque cutting speed \\(\\left(\\omega_{\\text {motTorqueCut }}\\right)\\) is set equal to \\(4800 \\mathrm{rpm}\\) and represents the speed from which the torque decreases linearly until \\(\\omega_{\\text {mot,Max }}\\) , where the torque is equal to zero. However, the maximum motor speed is not the only limit at which the motors are subjected. There is also a power limit that cuts the torque when it is larger than \\(T_{m, \\text { MaxSpeed }}=P_{\\text {batt }} /\\left(2 \\omega_{\\text {mot }}\\right)\\) . To sum up: If \\(T_{m, r e q} \\omega_{\\text {mot }} \\leq P_{\\text {batt }}\\) and \\(\\omega_{\\text {mot }} \\leq \\omega_{\\text {maxTorqueCut }}\\) \\[ T_{w, \\text { mot }}=T_{m, \\text { req }} \\tau_{\\text {red }} \\theta_{\\text {red }} \\] If \\(T_{m, r e q} \\omega_{m o t}>P_{\\text {batt }}\\) and \\(\\omega_{\\text {mot }} \\leq \\omega_{\\text {maxTorqueCut }}\\) \\[ T_{w, \\text { mot }}=\\frac{P_{\\text {batt }}}{2 \\omega_{\\text {mot }}} \\tau_{\\text {red }} \\theta_{\\text {red }} \\] If \\(\\omega_{\\text {mot }}>\\omega_{\\operatorname{maxTorqueCut}}\\) \\[ T_{w, \\text { mot }}=\\left[T_{m, \\text { maxSpeed }}+\\frac{T_{m, \\text { max Speed }}}{\\omega_{\\text {maxTorqueCut }}-\\omega_{\\text {mot,Max }}}\\left(\\omega_{\\text {mot }}-\\omega_{\\text {motTorqueCut }}\\right)\\right] \\tau_{\\text {red }} \\theta_{\\text {red }} \\] where \\(T_{m, \\text { req }}\\) is the motor required torque and \\(T_{w, m o t}\\) is the torque available at the wheel. In order to consider also the actuation delay, a first-order differential equation is applied to the required motor torque. \\[ \\tau_{\\text {mot }} \\dot{T}_{m, \\text { req }}=\\left(p_{D r} T_{\\text {mot,Max }}-T_{m, r e q}\\right) \\] \\(p_{D r}\\) is the throttle pedal level that can vary from zero to one \\(-p_{D r} \\in[0,1]-\\) . Aerodynamic model The aerodynamic forces are applied to a virtual point called centre of pressure \\(\\left(P_{A}\\right)\\) placed in \\(\\left[x_{A}, 0, z_{A}\\right]^{T}\\) . The lift \\(\\left(F_{z A}\\right)\\) is the vertical component of the aerodynamic force while the \\(\\operatorname{drag}\\left(F_{x A}\\right)\\) is the longitudinal one. An equivalent set of forces can be computed in such a way that the aerodynamic lift is divided between the front and the rear axle and the drag is applied to the projection of the centre of mass to the ground. Figure 6: Application scheme of aerodynamic forces \\[ \\left\\{\\begin{array}{l} F_{A D}=F_{x A} \\\\ F_{z A R}+F_{z A F}=F_{z A} \\\\ F_{z A F} L_{F}-F_{z A R} L_{R}=F_{z A} z_{A}-F_{x A} z_{A} \\end{array}\\right. \\] Since the aerodynamic forces have a quadratic dependency on the longitudinal velocity, we can write as follow. \\[ \\left\\{\\begin{array}{l} F_{A D}=C_{A x} u^{2}=C_{D} u^{2} \\\\ F_{z A R}=C_{A z R} u^{2}=C_{L}\\left(1-\\epsilon_{A}\\right) u^{2} \\\\ F_{z A F}=C_{A z F} u^{2}=C_{L} \\epsilon_{A} u^{2} \\end{array}\\right. \\] \\(C_{D}\\) and \\(C_{L}\\) are the real drag and lift coefficients, respectively. \\(C_{A D}, C_{A z R}\\) and \\(C_{A z F}\\) are the transformed drag and axle-lift coefficients. \\(\\epsilon_{A}\\) is the aero-balance and is defined as \\(F_{z A F} / F_{z A}\\) . It quantifies the amount of total downforce applied at the front axle. Load transfer model In the double-track vehicle model, the tire vertical load can be divided into two terms: the first - \\(F_{z i}\\) with \\(i=\\{R, F\\}\\) - considers the static force, the aerodynamic forces and the longitudinal load transfer - generated by the longitudinal acceleration \\(a_{x}\\) -; the second - \\(\\Delta F_{z i}\\) with \\(i=\\{R, F\\}\\) - corresponds to the lateral load transfer. \\[ \\left\\{\\begin{array}{l} F_{z R R}=F_{z R} / 2+\\Delta F_{z R} \\\\ F_{z R L}=F_{z R} / 2-\\Delta F_{z R} \\\\ F_{z F R}=F_{z F} / 2+\\Delta F_{z F} \\\\ F_{z F L}=F_{z F} / 2-\\Delta F_{z F} \\end{array}\\right. \\] The following computation shows how the two components of the vertical force are computed. \\(F_{y i}, i=\\{R, F\\}\\) are the axle lateral force and \\(K_{\\phi i}, i=\\{R, F\\}\\) are the rear and front roll stiffness. \\[ \\begin{array}{ll} F_{z R}=M g \\frac{L_{F}}{L}+M a_{x} \\frac{h_{G s}}{L}+\\left|F_{z A R}\\right| & \\Delta F_{z R}=F_{y R} \\frac{h_{R R}}{W_{R}}+\\frac{K_{\\phi R}}{W_{R}} \\phi \\\\ F_{z F}=M g \\frac{L_{R}}{L}-M a_{x} \\frac{h_{G s}}{L}+\\left|F_{z A F}\\right| & \\Delta F_{z F}=F_{y F} \\frac{h_{R F}}{W_{F}}+\\frac{K_{\\phi F}}{W_{F}} \\phi \\end{array} \\] From equations 22, it is possible to distinguish two components in the load transfer. The first component, called transient load transfer, involves the roll stiffness. It means that it is generated from the suspension/tire deformation. The second term, named instantaneous load transfer, is absorbed by the suspension structure and does not cause suspension deflection. In the vehicle model taken into consideration, the spring mass is seen as a rigid body that is suspended by four springs, representing the suspension/tire systems. From the model kinematics, it is possible to find the coordinates of the spring anchor points \\({ }^{0} S_{i j}, i=\\{R, F\\}, j=\\{R, L\\}\\) - and compute their height variation \\(\\left(\\Delta z_{i j}\\right)\\) . \\[ { }^{0} S_{i j}=R F_{S} \\cdot\\left[\\pm L_{i}, \\pm W_{i} / 2,0,1\\right]^{T} \\quad \\rightarrow \\quad \\Delta z_{i j}=h_{R i}-{ }^{0} S_{i j}(3) \\] \\(R F_{S}\\) is defined in the expression 3. The sign of the coordinates \\((\\pm)\\) depends on the indices \\(i\\) and \\(j\\) . The supra-script \\({ }^{0}\\) means that the considered point must be projected in the ground plane. For the computation of \\(\\Delta z_{i j}\\) , the third component of the point \\({ }^{0} S_{i j}\\) is needed \\(\\left({ }^{0} S_{i j}(3)\\right)\\) . Then, using the definition of the spring anchor points, the load transfer can be computed as follow. \\[ F_{z R R}=M g \\frac{L_{F}}{2 L}+\\frac{\\left|F_{z A R}\\right|}{2}+F_{y R} \\frac{h_{R R}}{W_{R}}+K_{s R} \\Delta z_{R R}+ +C_{s R} \\frac{d\\left(\\Delta z_{R R}\\right)}{d t}-K_{A R B, R}\\left(z_{R R}-z_{R L}\\right) \\\\ F_{z R L}=M g \\frac{L_{F}}{2 L}+\\frac{\\left|F_{z A R}\\right|}{2}-F_{y R} \\frac{h_{R R}}{W_{R}}+K_{s R} \\Delta z_{R L}+ +C_{s R} \\frac{d\\left(\\Delta z_{R L}\\right)}{d t}+K_{A R B, R}\\left(z_{R R}-z_{R L}\\right) \\\\ F_{z F R}=M g \\frac{L_{R}}{2 L}+\\frac{\\left|F_{z A F}\\right|}{2}+F_{y F} \\frac{h_{R F}}{W_{F}}+K_{s F} \\Delta z_{F R}+ +C_{s F} \\frac{d\\left(\\Delta z_{F R}\\right)}{d t}-K_{A R B, F}\\left(z_{F R}-z_{F L}\\right) \\\\ F_{z F L}=M g \\frac{L_{R}}{2 L}+\\frac{\\left|F_{z A F}\\right|}{2}-F_{y F} \\frac{h_{R F}}{W_{F}}+K_{s F} \\Delta z_{F L}+ +C_{s F} \\frac{d\\left(\\Delta z_{F L}\\right)}{d t}+K_{A R B, F}\\left(z_{F R}-z_{F L}\\right) \\] In equation 24, the terms with \\(K_{s}\\) are the stiffness of the suspension and tire subsystem - \\(K_{s}=\\left(K_{susp}^{-1}+K_{\\text {tire}}^{-1}\\right)^{-1}\\) -. The same for the damping factor \\(\\left(C_{s}\\right) . K_{ARB}\\) is the front or rear anti-roll bar stiffness. These expressions can be generalized introducing non-linear damping effects or introducing a differential stiffness in case of a shock absorber. For the specific case of non-linear dampers, a case function can be implemented in to select the proper coefficients in relation to the effective speed of the damper itself. \\[ dl_{fr} = -(atan2(-((h_rc_{f} ^ 2 - 2 * h_rc_{f} * h_rc_{r} + h_rc_{r} ^ 2 + (Lf + Lr) ^ 2) ^{-0.1e1 / 0.2e1} * (h_rc_{f} - h_rc_{r})), \\\\((h_rc_{f} ^ 2 - 2 * h_rc_{f} * h_rc_{r} + h_rc_{r} ^ 2 + (Lf + Lr) ^ 2) ^{-0.1e1 / 0.2e1} * (Lf + Lr))) * sin(mu) - cos(mu)) * Lf * mu_{dot} + (-0.2e1 * sin(mu) * phi * Lf + Wf) * phi_{dot} / 0.2e1 - z_{dot}\\\\ \\] \\[ dl_{fl} = -(atan2(-((h_rc_{f} ^ 2 - 2 * h_rc_{f} * h_rc_{r} + h_rc_{r} ^ 2 + (Lf + Lr) ^ 2) ^{-0.1e1 / 0.2e1} * (h_rc_{f} - h_rc_{r})), \\\\((h_rc_{f} ^ 2 - 2 * h_rc_{f} * h_rc_{r} + h_rc_{r} ^ 2 + (Lf + Lr) ^ 2) ^{-0.1e1 / 0.2e1} * (Lf + Lr))) * sin(mu) - cos(mu)) * Lf * mu_{dot} + (-0.2e1 * sin(mu) * phi * Lf - Wf) * phi_{dot} / 0.2e1 - z_{dot}\\\\ \\] \\[ dl_{rr} = (atan2(-((h_rc_{f} ^ 2 - 2 * h_rc_{f} * h_rc_{r} + h_rc_{r} ^ 2 + (Lf + Lr) ^ 2) ^{-0.1e1 / 0.2e1} * (h_rc_{f} - h_rc_{r})), \\\\((h_rc_{f} ^ 2 - 2 * h_rc_{f} * h_rc_{r} + h_rc_{r} ^ 2 + (Lf + Lr) ^ 2) ^{-0.1e1 / 0.2e1} * (Lf + Lr))) * sin(mu) - cos(mu)) * Lr * mu_{dot} + (0.2e1 * sin(mu) * Lr * phi + Wr) * phi_{dot} / 0.2e1 - z_{dot}\\\\ \\] \\[ dl_{rl} = (atan2(-((h_rc_{f} ^ 2 - 2 * h_rc_{f} * h_rc_{r} + h_rc_{r}^ 2 + (Lf + Lr) ^ 2) ^{-0.1e1 / 0.2e1} * (h_rc_{f} - h_rc_{r})), \\\\((h_rc_{f} ^ 2 - 2 * h_rc_{f} * h_rc_{r} + h_rc_{r} ^ 2 + (Lf + Lr) ^ 2) ^{-0.1e1 / 0.2e1} * (Lf + Lr))) * sin(mu) - cos(mu)) * Lr * mu_{dot} + (0.2e1 * sin(mu) * Lr * phi - Wr) * phi_{dot} / 0.2e1 - z_{dot}\\\\ \\] Brake model The brake behaviour can be reduced to friction phenomenon and, for this reason, can result difficult to be accurately modelled. It can be argued that the friction forces aim to minimize the object speed under the constraint of the friction cone or, in practice, of the maximum friction force. Christian Studer [20] presents the time-stepping method in order to model a non-smooth dynamical mode \\(4^{2}\\) In order to model the brake system behaviour, a time-stepping technique is used to smooth the model outputs. The time-stepping version used in our model is based on the wheels rolling dynamical equation, reported in 25 \\[ I_{a, W} \\dot{\\omega}(t)=T_{w, m o t}-T_{w, b r k}-F_{x} R \\] \\({ }^{2}\\) A non-smooth dynamical model is a model in which the generalized positions \\(\\bar{q}\\) or velocities \\(\\bar{u}\\) jump. In the jump instant, the acceleration can not be defined. where \\(T_{w, m o t}\\) and \\(T_{w, b r k}\\) are the torque at the wheel from the motor and from the braking system respectively, \\(F_{x}\\) is the longitudinal tire force, \\(R\\) is the tire radius and \\(\\omega\\) is the wheel spin velocity. Assuming an explicit Euler integration scheme, it is possible to substitute the acceleration term with equation 25 \\[ \\begin{aligned} \\omega(t+\\Delta t) & =\\omega(t)+\\dot{\\omega} \\Delta t \\\\ & =\\omega(t)+\\frac{T_{w, \\text { mot }}-T_{w, b r k}-F_{x} R}{I_{a, W}} \\Delta t \\\\ & =\\frac{s-T_{w, b r k} \\Delta t}{I_{a, W}} \\end{aligned} \\] where \\(\\Delta t\\) is the integration time-step and \\(s=I_{a, W} \\omega(t)+\\left(T_{w, m o t}-F_{x} R\\right) \\Delta t\\) . As previously mentioned, the friction forces acting on the disk aim to minimize the wheel speed. For this reason, to find the friction forces, we need to solve a minimization problem. \\[ \\begin{array}{lc} \\underset{T_{w, b r k}}{\\operatorname{minimize}} & {\\left[\\frac{s-T_{w, b r k} \\Delta t}{I_{a, W}}\\right]^{2}} \\\\ \\text { subject to } & -T_{w, b r k}^{M a x} \\leq T_{w, b r k} \\leq T_{w, b r k}^{\\text {Max }} \\end{array} \\] The minimization problem presented in 27 is simple to solve because the cost function is quadratic. The solution is reported in 28 . \\[ T_{w, b r k}= \\begin{cases}s / \\Delta t & \\text { if }|s / \\Delta t| \\leq T_{w, b r k}^{M a x} \\\\ T_{w, b r k}^{\\text {Max }} \\operatorname{sign}(s) & \\text { otherwise }\\end{cases} \\] The maximum braking torque \\(\\left(T_{w, b r k}^{M a x}\\right)\\) is defined starting from the brake pedal input \\(p_{b r k} \\epsilon[0,1]\\) -. Moreover, a first-order dynamical equation is applied in order to consider the actuation delay. \\[ \\begin{gathered} \\left\\{\\begin{array}{l} T_{b r k, R e q, F}=p_{b r k} T_{b r k}^{M a x} \\epsilon_{b r k} \\\\ T_{b r k, R e q, R}=p_{b r k} T_{b r k}^{M a x}\\left(1-\\epsilon_{b r k}\\right) \\end{array}\\right. \\\\ \\left\\{\\begin{array}{l} \\tau_{b r k}\\,\\dot{T}_{w, b r k, F}^{M a x}=\\left(T_{b r k, R e q, F}-T_{w, b r k, F}\\right) \\\\ \\tau_{b r k}\\,\\dot{T}_{w, b r k, R}^{M a x}=\\left(T_{b r k, R e q, R}-T_{w, b r k, R}\\right) \\end{array}\\right. \\end{gathered} \\] where \\(T_{b r k}^{\\text {Max }}\\) is the maximum braking torque that the hydraulic system can generate, \\(\\epsilon_{b r k}\\) is the braking ratio that refers to the percentage of the braking torque available at the front and \\(\\tau_{b r k}\\) is the actuator time constant. Steering system model The vehicle is front wheel steering. Studying the steering system model, the steering system kinematic behaviour is fitted with polynomials that connect the Hand-Wheel steering angle \\(\\left(\\delta_{H W}\\right)\\) with the front wheels steering angles \\(\\left(\\left\\{\\delta_{F L}, \\delta_{F R}\\right\\}\\right)\\) . This polynomial can be derived from the fenice-steering-system-DMT repository. Figure 7: Representation of half steering model built in Maple The polynomial function is relatively computationally cheap but, at the same time, it allows us to consider also the non-linear behaviour of the steering system. The steering kinematics may change with the suspension deformation. However, the changing due to the suspension deflection does not have a main contribute and can be neglected. Figure 8: Steering model fitting results computed in Maple The actuation delay is considered by means of a first-order differential equation where \\(\\tau_{H}\\) is the steering system time constant. \\[ \\tau_{H} \\dot{\\delta}_{H W}=\\left(\\delta_{r e q}-\\delta_{H W}\\right) \\] First order reduction The dynamical equations, in general, are of order 2. This problem is partially solved by the use of the quasi-coordinates 3 , however, in equations of motions, the second-order derivatives of \\(z, \\theta\\) and \\(\\phi\\) appear. In order to neglect these terms, three additionally differential equations (equation 32) can be added in order to solve the second-order derivation and simplify the numerical solution process. \\[ \\left\\{\\begin{array}{l} \\dot{z}(t)=z_{\\text {dot }}(t) \\\\ \\dot{\\phi}(t)=\\phi_{\\text {dot }}(t) \\\\ \\dot{\\theta}(t)=\\theta_{\\text {dot }}(t) \\end{array}\\right. \\] \\({ }^{3}\\) For the vehicle description, \\(u, v\\) and \\(\\Omega\\) are usually employed, substituting the classical coordinates \\(x, y\\) and \\(\\psi\\) . Since they are not actually coordinates but velocities, they are named quasi-coordinates. Equation of Motion The full set of Dynamical equations can be found in [16] (pp. 47-50). Here, the system equations are listed only: 3 Newton equations; 3 Euler equations; 1 equation for the steering dynamics; 2 equations for the motor actuation dynamics; 2 equations for the brake actuation dynamics; 4 equations for the longitudinal slip dynamics; 4 equations for the lateral slip dynamics; 4 equations for the wheel spin dynamics; 3 equations for the first order reduction Hence, the total number of differential equations is 26 . Moreover, the system has other 26 equations: 2 equations for the steering system kinematics; 4 equations for the steady-state longitudinal slip computation; 4 equations for the steady-state lateral slip computation; 4 equations for the load transfer computation; 12 equations for the tire forces and self-aligning torque computation The system states are divided into differential \\((\\bar{X})\\) and algebraic \\(\\left(\\bar{X}_{a l g}\\right)\\) and are reported in the expressions 33 and 34 . \\[ \\begin{aligned} \\bar{X}=\\{ & u, v, \\Omega, z, \\phi, \\theta, \\delta, T_{m o t, R R}, T_{m o t, R L}, T_{b r k, R}, T_{b r k, F}, \\alpha_{R R}, \\alpha_{R L}, \\alpha_{F R}, \\alpha_{F L}, \\\\ & \\left.\\lambda_{R R}, \\lambda_{R L}, \\lambda_{F R}, \\lambda_{F L}, \\omega_{R R}, \\omega_{R L}, \\omega_{F R}, \\omega_{F L}, z_{\\text {dot }}, \\phi_{\\text {dot }}, \\theta_{\\text {dot }}\\right\\} \\end{aligned} \\] \\[ \\begin{aligned} \\bar{X}_{a l g}=\\{ & \\delta_{F R}, \\delta_{F L}, \\lambda_{S S, R R}, \\lambda_{S S, R L}, \\lambda_{S S, F R}, \\lambda_{S S, F L}, \\alpha_{S S, R R}, \\alpha_{S S, R L}, \\alpha_{S S, F R}, \\alpha_{S S, F L}, \\\\ & F_{z R R}, F_{z R L}, F_{z F R}, F_{z F L}, F_{x R R}, F_{x R L}, F_{x F R}, F_{x F L}, \\\\ & \\left.F_{y R R}, F_{y R L}, F_{y F R}, F_{y F L} M_{y R R}, M_{y R L}, M_{y F R}, M_{y F L}\\right\\} \\end{aligned} \\] The 10 degrees of freedom (DoF) of the model are composed by: 3 DoF are related to the planar motion in the absolute ground plane. They are given by the vehicle \\(\\{x, y\\}\\) coordinates and by the yaw-angle \\(\\psi\\) . Alternatively, these three DoF can be associated to the quasi-coordinates \\(\\{u, v, \\Omega\\}\\) . 3 DoF are given by the internal dynamics \\(\\{z, \\phi, \\theta\\}\\) . 4 DoF are given by the wheels spin \\(\\left\\{\\omega_{R R}, \\omega_{R L}, \\omega_{F R}, \\omega_{F L}\\right\\}\\) . The inputs of the model are the hand-wheel steering angle \\(\\left(\\delta_{H W}\\right)\\) and the throttle and brake pedal \\(\\left(\\left\\{p_{D r}, p_{b r k}\\right\\}\\right)\\) . However, a longitudinal velocity tracker is implemented using a PID controller. It takes as input the desired velocity profile and returns the value of the throttle and of the brake pedals needed to track that speed profile. References [1] Acosta, M., Kanarachos, S. - Tire lateral force estimation and grip potential identification using Neural Networks, Extended Kalman Filter, and Recursive Least Squares. Neural Comput \\& Applic 30, 3445-3465 (2018). https://doi.org/10.1007/s00521-017-2932-9 [2] Acosta M., Kanarachos S. and Fitzpatrick M. E., \"Robust Virtual Sensing for Vehicle Agile Manoeuvring: A Tyre-Model-Less Approach,\" in IEEE Transactions on Vehicular Technology, vol. 67, no. 3, pp. 1894-1908, March 2018, doi: 10.1109/TVT.2017.2767942. [3] \u00c5kesson B. M., J\u00f8rgensen J. B., Poulsen N. K., J\u00f8rgensen S. B., A tool for kalman filter tuning, Editor(s): Valentin Ple\u015fu, Paul \u015eerban Agachi, Computer Aided Chemical Engineering, Elsevier, Volume 24, 2007, ISBN 9780444531575, https://doi.org/10.1016/S1570-7946(07)80166-0. [4] Alatorre A. G., Charara A. and Victorino A., \"Sideslip estimation algorithm comparison between Euler angles and quaternion approaches with black box vehicle model,\" 2018 IEEE 15th International Workshop on Advanced Motion Control (AMC), Tokyo, 2018, pp. 553-559, doi: 10.1109/AMC.2019.8371153. [5] Da Lio M., Bortoluzzi D. \\& Rosati Papini G. P. (2020) Modelling longitudinal vehicle dynamics with neural networks, Vehicle System Dynamics, 58:11, 1675-1693, DOI: \\(10.1080 / 00423114.2019 .1638947\\) [6] De Pascali L., Biral F., Cocetti M., Zaccarian L. and Tarbouriech S., \"A kinematic observer with adaptive dead-zone for vehicles lateral velocity estimation,\" 2018 IEEE 15th International Workshop on Advanced Motion Control (AMC), Tokyo, 2018, pp. 511-516, doi: 10.1109/AMC.2019.8371146. [7] Farrelly J. and Wellstead P., \"Estimation of vehicle lateral velocity,\" Proceeding of the 1996 IEEE International Conference on Control Applications IEEE International Conference on Control Applications held together with IEEE International Symposium on Intelligent Contro, Dearborn, MI, USA, 1996, pp. 552-557, doi: 10.1109/CCA.1996.558920. [8] Fern\u00e1ndez J. G. (2012) - A Vehicle Dynamics Model for Driving Simulators Chalmers University of Technology [9] Gelen A. G. and Atasoy A., \"A New Method for Kalman Filter Tuning,\" 2018 International Conference on Artificial Intelligence and Data Processing (IDAP), Malatya, Turkey, 2018, pp. 1-6, doi: 10.1109/IDAP.2018.8620863. [10] Guiggiani M. (2014) \"The science of vehicle dynamics\", Springer Netherlands, pp: 137-144 [11] James S. S., Anderson S. R. and Da Lio M., \"Longitudinal Vehicle Dynamics: A Comparison of Physical and Data-Driven Models Under Large-Scale RealWorld Driving Conditions,\" in IEEE Access, vol. 8, pp. 73714-73729, 2020, doi: 10.1109/ACCESS.2020.2988592. [12] Larcher M. (2019) - Development of a 14 Degrees of Freedom Vehicle Model for Realtime Simulations in 3D Environment - Universit\u00e0 di Trento [13] Lot R. and Da Lio M. \"A symbolic approach for automatic generation of the equations of motion of multibody systems\", 2004, Multibody System Dynamics, 12(2): \\(147-172\\) [14] Oshaman Y., Shaviv I. \"Optimal tuning of a Kalman Filter using Genetic Algorithm\" Technion - Israel Institute of Technology (2000), doi: https://doi.org/10.2514/6.2000-4558 [15] Panzani G., Corno M., Savaresi S.M., \"Longitudinal Velocity Estimation in SingleTrack Vehicles\", IFAC Proceedings Volumes, Volume 45, Issue 16, 2012, Pages 17011706, https://doi.org/10.3182/20120711-3-BE-2027.00164. [16] Piccinini M. (2019) - Path Planning and Control of Self Driving Vehicles at the Limit of Handling - Universit\u00e0 di Trento - Ch: 2 [17] Regolin E., Alatorre A., Zambelli M., Victorino A., Charara A. and Ferrara A., \"A Sliding-Mode Virtual Sensor for Wheel Forces Estimation With Accuracy Enhancement via EKF,\" in IEEE Transactions on Vehicular Technology, vol. 68, no. 4, pp. 3457-3471, April 2019, doi: 10.1109/TVT.2019.2903598. [18] Ryu J., Nardi F., \\& Moshchuk N. \"Vehicle Sideslip Angle Estimation and Experimental Validation.\" Proceedings of the ASME 2013 International Mechanical Engineering Congress and Exposition. Volume 4A: Dynamics, Vibration and Control. San Diego, California, USA. November 15-21, 2013. V04AT04A052. ASME. https://doi.org/10.1115/IMECE2013-64466 [19] Ru\u017einskas A., Sivilevi\u010dius H., \"Magic Formula Tyre Model Application for a Tyre-Ice Interaction\", Procedia Engineering, Volume 187, 2017, https://doi.org/10.1016/j.proeng.2017.04.383. [20] Studer C. (2009) \"Numerics of Unilateral Contacts and Friction - Modeling and Numerical Time Integration in Non-Smooth Dynamics\", Springer-Verlag Berlin Heidelberg, pp. 59-127 [21] Viehweger M., Vaseur C., van Aalst S., Acosta M., Regolin E., Alatorre A., Desmet W., Naets F., Ivanov V., Ferrara A. \\& Victorino A. (2020) Vehicle state and tyre force estimation: demonstrations and guidelines, Vehicle System Dynamics, DOI: \\(10.1080 / 00423114.2020 .1714672\\) [22] Enciclopedia Treccani - https://www.treccani.it/enciclopedia/metodo-montecarlo/ [23] Enciclopedia Treccani - https://www.treccani.it/enciclopedia/gradi-di-liberta/ Release Notes V1.0: 12/2020: Initial Release (Matteo Tomasi) V1.1: 10/12/2022: Added suspension velocities for non linear dampers and steering map (Luca Dalle Sasse)","title":"Vehicle Model for Simulation"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#vehicle-model-for-simulation","text":"In this report, the theory behind the vehicle model is briefly explained. This allows us to understand how the simulation environment works and how to define some of the most important characteristics of the vehicle kinematics and dynamics. The model parameters are selected in order to simulate the behaviour of the Trento Formula SAE racing vehicle, called Chimera Evoluzione (figure 11). In the original model, the tires behaviour is simulated using the Pacejka formulation. However, in the validated version of the model, the tires characteristics will be modelled using a simplified tire model, defined in a dedicated paper. The description follows the works done by Piccinini M. in his thesis [16]. In order to extract equation of motion, the symbolic computation software Maple \\(^{\\circledR}\\) is used, with the multibody library MBSymba \\(^{\\circledR}\\) [13]. Figure 1: Photo of Chimera Evoluzione (Tests of 09-11-2020)","title":"Vehicle Model for Simulation"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#vehicle-kinematics","text":"As first, we have to define the vehicle reference frame \\(\\left(R F_{V}\\right)\\) with respect to an absolute fixed reference frame \\(\\left(R F_{0}\\right)\\) . The vehicle reference frame has its origin in the projection of the vehicle Centre of Mass (CoM) in the xy absolute plane, the \\(\\mathrm{x}\\) -axis points in the vehicle forward direction and the z-axis points upward. The transformation from \\(R F_{0}\\) to \\(R F_{V}\\) is a translation of \\(\\{\\mathrm{x}, \\mathrm{y}, 0\\}\\) and a rotation of the yaw angle \\((\\psi)\\) around the z-axis, as depicted in figure 2 . Figure 2: 2D representation of the vehicle reference frames With reference to figure \\(2, R F_{V}\\) moves with a linear velocity \\(\\left\\{v_{x}, v_{y}, 0\\right\\}\\) and an angular velocity along the z-axis of \\(\\Omega=\\dot{\\psi}\\) . Projecting these components in the vehicle reference frame, the longitudinal and the lateral velocity \\((u\\) and \\(v)\\) can be defined. For definition, the angle \\(\\beta\\) , called Body Side Slip Angle, is the angle between the absolute velocity vector \\(\\left(\\bar{V}_{G}\\right)\\) and the \\(x_{V}\\) axis. Until now, the vehicle is shown as a rigid body that moves in the absolute ground plane. To proceed with the kinematic analysis, it is useful to distinguish between the Spring and Un-Spring masses. The Un-Spring masses correspond to the parts of the vehicle \"constrained\" to the ground - i.e. the tires, the wheels, the hub and part of the suspensions assembly -. The spring masses, instead, are the vehicle parts above the suspensions, namely that parts of the vehicle that can moves under the effects of suspensions deformation - for example, the remaining part of the suspensions, the chassis, the motors, the inverters or the driver \\(-\\) . The spring masses have 3 additional Degrees of Freedom that corresponds to the Roll \\((\\phi)\\) the Pitch \\((\\theta)\\) and the Heave \\((z)\\) motion. These are the components of the so-called internal kinematics. In particular, the Roll Axis has to be modelled. It is the axis around which the vehicle rolls and depends on the suspension geometry. Specifically, assuming the vehicle as symmetric, the Roll Axis lives in the \\(\\mathrm{xz}\\) vehicle plane and pass through the front and rear Roll Centres: points with a height of \\(h_{R F}\\) and \\(h_{R R}\\) respectively. The angle between the Roll Axis and the \\(x_{V}\\) axis, in static case, is called \\(\\alpha_{r a}\\) . The geometric representation of the internal kinematics geometry is depicted in figure 3 Figure 3: Roll axis position \\[ \\alpha_{r a}=\\operatorname{atan}\\left(\\frac{h_{R R}-h_{R F}}{L_{R}+L_{F}}\\right) \\quad ; \\quad h_{R}=h_{R F}+\\alpha_{r a} L_{F} \\] In order to mathematically define the internal kinematics, an auxiliary reference frame \\(\\left(R F_{S, a}\\right)\\) is defined, starting from the vehicle reference frame. In the static condition, this new frame has the origin in the point \\(P_{R}\\) , depicted in figure 3. The \\(\\mathrm{x}\\) axis that coincides with the roll axis and points in the vehicle forward direction. The \\(\\mathrm{z}\\) axis points upward. Besides, the auxiliary reference frame is free to move along the \\(z_{V}\\) axis to model the heave motion. From \\(R F_{S, a}\\) , the others internal kinematic motion can be defined in order to find the Spring masses reference frame \\(\\left(R F_{S}\\right)\\) : firstly, the pitch along y and, secondly, the roll motion along \\(\\mathrm{x}\\) . Since the angles are small, the transformation matrix between \\(R F_{S, a}\\) and \\(R F_{S}\\) can be linearized. The result is shown in 2 . \\[ T_{R F_{S, a} \\rightarrow R F_{S}}=\\left[\\begin{array}{cccc} 1 & 0 & \\theta(t) & 0 \\\\ 0 & 1 & -\\phi(t) & 0 \\\\ -\\theta(t) & \\phi(t) & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right] \\] In order to resume the transformations, they are collected in relation 3. \\[ \\begin{gathered} \\left\\{\\begin{array}{l} R F_{V} \\quad=R F_{0} \\cdot T(x(t), y(t), 0) \\cdot R_{Z}(\\psi(t)) \\\\ R F_{S, a}=R F_{V} \\cdot T\\left(0,0, h_{R}+z(t)\\right) \\cdot R_{Y}\\left(\\alpha_{r a}\\right) \\\\ R F_{S}=R F_{S, a} \\cdot R_{Y}(\\theta(t)) \\cdot R_{X}(\\phi(t)) \\approx R F_{S, a} \\cdot T_{R F_{S, a} \\rightarrow R F_{S}} \\end{array}\\right. \\\\ T(a, b, c)=\\left[\\begin{array}{llll} 1 & 0 & 0 & a \\\\ 0 & 1 & 0 & b \\\\ 0 & 0 & 1 & c \\\\ 0 & 0 & 0 & 1 \\end{array}\\right] \\\\ R_{X}(\\alpha)=\\left[\\begin{array}{cccc} 1 & 0 & 0 & 0 \\\\ 0 & \\cos (\\alpha) & -\\sin (\\alpha) & 0 \\\\ 0 & \\sin (\\alpha) & \\cos (\\alpha) & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right] \\\\ R_{Y}(\\alpha)=\\left[\\begin{array}{ccccc} \\cos (\\alpha) & 0 & \\sin (\\alpha) & 0 \\\\ 0 & 1 & 0 & 0 \\\\ -\\sin (\\alpha) & 0 & \\cos (\\alpha) & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right] \\quad R_{Z}(\\alpha)=\\left[\\begin{array}{cccc} \\cos (\\alpha) & -\\sin (\\alpha) & 0 & 0 \\\\ \\sin (\\alpha) & \\cos (\\alpha) & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right] \\end{gathered} \\]","title":"Vehicle kinematics"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#vehicle-dynamics","text":"","title":"Vehicle Dynamics"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#definition-of-the-bodies","text":"Equations of motion are derived by means of the Newton-Euler method. The bodies definition is necessary to start the dynamic analysis.","title":"Definition of the Bodies"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#vehicle-body","text":"The vehicle body consists of the whole vehicle body in the static configuration. It has a mass of \\(M\\) and an inertia tensor equal to \\(\\left[I_{V}\\right]\\) . The inertia components \\(I_{x y, V}\\) and \\(I_{y z, V}\\) are negligible with respect to the other terms of the matrix so they can be set equal to zero. The centre of mass of this body is always placed in the point \\(\\left[0,0, h_{G 0}\\right]\\) of the vehicle reference frame \\(\\left(R F_{V}\\right)\\) . \\[ \\left[I_{V}\\right]=\\left[\\begin{array}{ccc} I_{x x, V} & 0 & -I_{x z, V} \\\\ 0 & I_{y y, V} & 0 \\\\ -I_{x z, V} & 0 & I_{z z, V} \\end{array}\\right] \\]","title":"Vehicle body"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#chassis-body","text":"The chassis body models the spring masses. For this reason, its mass is equal to \\(m_{S}\\) and its inertia tensor is \\(\\left[I_{C}\\right]\\) . Similarly to the vehicle case, \\(\\left[I_{V}\\right]\\) has the \\(x y\\) and \\(y z\\) terms that can be set to zero. The centre of mass of the chassis reference frame is placed in the origin of \\(R F_{S}\\) . \\[ \\left[I_{C}\\right]=\\left[\\begin{array}{ccc} I_{x x, C} & 0 & -I_{x z, C} \\\\ 0 & I_{y y, C} & 0 \\\\ -I_{x z, C} & 0 & I_{z z, C} \\end{array}\\right] \\]","title":"Chassis body"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#wheels-bodies","text":"The wheels bodies are four and its mass is \\(m_{W}\\) . Each wheel has an associated reference frame, with the origin in the wheel centre, that is fixed with respect to the wheel. Starting from the vehicle reference frame, the applied transformations are shown in relation 6. \\[ \\left\\{\\begin{array}{l} R F_{W, R R}=T\\left(-L_{R},-W_{R} / 2, R_{R}\\right) \\cdot R_{Y}\\left(\\xi_{R R}(t)\\right) \\\\ R F_{W, R L}=T\\left(-L_{R}, W_{R} / 2, R_{R}\\right) \\cdot R_{Y}\\left(\\xi_{R L}(t)\\right) \\\\ R F_{W, F R}=T\\left(L_{F},-W_{F} / 2, R_{F}\\right) \\cdot R_{Z}\\left(\\delta_{F R}\\right) \\cdot R_{Y}\\left(\\xi_{F R}(t)\\right) \\\\ R F_{W, F L}=T\\left(L_{F}, W_{F} / 2, R_{F}\\right) \\cdot R_{Z}\\left(\\delta_{F L}\\right) \\cdot R_{Y}\\left(\\xi_{F L}(t)\\right) \\end{array}\\right. \\] The suffix of the reference frames corresponds to the wheel position: \\(R R\\) rear-right, \\(R L\\) real-left, \\(F R\\) front-right and \\(F L\\) front-left. This notation will be used to label the position of different quantities during this work. \\(W_{F}\\) and \\(W_{R}\\) are the front and the rear track-width respectively while \\(R_{F}\\) and \\(R_{R}\\) are the front and rear wheel radii. The angles \\(\\delta\\) are the steering angle at the wheels. Since the vehicle is front wheel steering, the associated rotation is performed only to the front wheels. The angles \\(\\xi\\) , instead, model the wheel spin. The inertia tensor is diagonal and it is equal to \\(\\left[I_{W}\\right]\\) . \\[ \\left[I_{W}\\right]=\\left[\\begin{array}{ccc} I_{d, W} & 0 & 0 \\\\ 0 & I_{a, W} & 0 \\\\ 0 & 0 & I_{d, W} \\end{array}\\right] \\]","title":"Wheels bodies"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#anti-bodies","text":"In equation of motion, the main vehicle motion \\((x(t), y(t)\\) and \\(\\psi(t))\\) are associated to the vehicle, while the other Degrees of Freedom, called also relative, are associated to the chassis and to the wheels. In order to neglect the static term from the chassis and from the wheels - the static term is already addressed by the vehicle body - special constructs are named anti-bodies. They are virtual bodies with the inertia components negative with respect to the associated body and placed in the static position of the related body, i.e. their relative DoF are set equal to zero.","title":"Anti-bodies"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#tire-model","text":"In the model of Piccinini [16], an high fidelity semi-empirica) tire model is used in order to model the tire characteristics. In particular, the Pacejka tire model allows us to have a precise steady-state representation of the tire behaviour. The tire model returns the longitudinal and lateral tire force \\(\\left(F_{x}\\right.\\) and \\(\\left.F_{y}\\right)\\) and the self-aligning moment \\(\\left(M_{z}\\right)\\) as a function of the practical slip \\((\\bar{\\kappa})\\) , the tire vertical load \\(\\left(F_{z}\\right)\\) and the wheel camber \\((\\gamma)\\) . The camber is the angle between the wheel middle plane and the xz-vehicle plane. This angle is not fixed but varies with the suspension deflection. Using the suspension kinematic model, a roll-to-camber map is fitted in order to address the angle variation as a function of the roll angle. The tire slip is computed starting from the wheel speeds with reference to figure 4 . Figure 4: Tire top view: the wheel speeds are highlighted The rolling velocity is equal to the product between the wheel angular velocity and the wheel radius \\(-\\bar{v}_{r}=[\\omega R, 0,0]^{T}-\\) . The contact point velocity \\(\\left(\\bar{v}_{c}\\right)\\) depends on the vehicle velocity and is a \\(2 \\mathrm{D}\\) vector that lives in the ground plane. The sliding velocity is the vectorial difference between the contact point and the rolling velocity \\(-\\bar{v}_{s}=\\bar{v}_{c}-\\bar{v}_{r}\\) \\({ }^{1}\\) The semi-empirical models uses physical based information in order to fit very sophisticated behaviour with a simpler mathematical function. This approach makes the computation cheaper and the simulation faster. -. Then, the practical slip can be defined as reported in 8 . \\[ \\bar{\\kappa}=\\left[\\begin{array}{c} \\lambda \\\\ \\tan (\\alpha) \\end{array}\\right]=-\\frac{\\bar{v}_{s}}{\\left|v_{c, x}\\right|}=\\left[\\begin{array}{c} -\\left(v_{c, x}-\\omega R\\right) /\\left|v_{c, x}\\right| \\\\ -v_{c, y} /\\left|v_{c, x}\\right| \\end{array}\\right] \\] The longitudinal slip can be also called \\(\\kappa\\) . In conclusion, the tire model evaluates the following functions. \\[ \\begin{cases}F_{x} & =F_{x}\\left(\\lambda, \\alpha, F_{z}, \\gamma\\right) \\\\ F_{y} & =F_{y}\\left(\\lambda, \\alpha, F_{z}, \\gamma\\right) \\\\ M_{z} & =M_{z}\\left(\\lambda, \\alpha, F_{z}, \\gamma\\right)\\end{cases} \\]","title":"Tire model"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#slip-transient-model","text":"In order to consider also the transient in the tire model, a first-order dynamical equation can be applied to the slip. Experimentally, it is possible to observe that this assumption well approximates the real tire behaviour. The time constant of the dynamical equation can be written as a function of the vehicle longitudinal speed and of the tire relaxation length \\(-l_{i}\\) with \\(i=\\{x, y\\}-\\) . The latter is assumed to be constant and describes the distance, covered by the rolling tire, at which the transient finishes. \\[ \\left\\{\\begin{array}{l} \\frac{l_{x}}{|u(t)|} \\frac{d \\lambda(t)}{d t}+\\lambda(t)=\\lambda_{S S}(t) \\\\ \\frac{l_{y}}{|u(t)|} \\frac{d \\alpha(t)}{d t}+\\alpha(t)=\\alpha_{S S}(t) \\end{array}\\right. \\] The terms with the lowercase \\(S S\\) represents the steady-state slip value, computed using equation 8, while, the terms without the \\(S S\\) corresponds to the transient slip.","title":"Slip transient model"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#low-speed-slip-correction","text":"The steady-state slip definition, defined in 8 , becomes singular when the longitudinal vehicle speed tends to zero. Besides, the longitudinal transient slip 10 may oscillate under the effects of a step input torque at low vehicle speed. These non-physical oscillations may remain for a relatively long time. In order to address the singularity problem, a smooth function is introduced in order to avoid the annulment of the slip denominator - ref. to expression 8 and figure 5 -. \\[ \\left|v_{c, x}\\right| \\longrightarrow \\operatorname{smooth}\\left(\\left|v_{c, x}\\right|\\right)=\\frac{1}{2}\\left(V_{\\text {low }}+\\frac{v_{c, x}^{2}}{V_{\\text {low }}}\\right) \\] Figure 5: Smooth Function \\(V_{\\text {low }}\\) is a threshold velocity that allows us to split the high and low speed. The smooth function is applied only if \\(V_{\\text {low }} \\geq\\left|v_{c, x}\\right|\\) . Usually, this threshold is set to \\(1 \\mathrm{~m} / \\mathrm{s}\\) . In order to cancel the oscillation phenomenon, instead, it is possible to introduce a virtual damping factor \\(\\left(K_{V_{\\text {low }}}\\right)\\) that aims to smooth these oscillations. \\[ \\lambda \\longrightarrow \\lambda-\\frac{K_{V_{\\text {low }}}}{C_{F_{\\lambda}}} v_{s, x} \\] In 12, \\(C_{F_{\\lambda}}\\) is the longitudinal tire stiffness, i.e. the slope of the tire characteristic when \\(\\lambda=0\\) and \\(v_{s, x}\\) is the longitudinal component of the sliding velocity with reference to figure 4 This correction is applied only for low speed. For this reason, it is needed a function that smoothly goes to zero when the speed tends to \\(V_{\\text {low }}\\) . \\[ K_{V_{\\text {low }}}= \\begin{cases}\\frac{1}{2} K_{V_{\\text {low }}, 0}\\left[1+\\cos \\left(\\pi \\frac{|u(t)| \\mid}{V_{\\text {low }}}\\right)\\right] & \\text { if }|u| \\leq V_{\\text {low }} \\\\ 0 & \\text { if }|u|>V_{\\text {low }}\\end{cases} \\] With a proper tuning of \\(K_{V_{\\text {low }, 0}}\\) , the non-physical oscillations can completely disappear. However, this correction may introduce instability problems around the threshold velocity \\(V_{\\text {low }}\\) .","title":"Low speed slip correction"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#powertrain-model","text":"The powertrain of the considered electric vehicle is composed of two permanent magnets three-phase electric motors - model Emrax 208 -, two inverters, the speed reducers and the battery pack - \\(6.5 \\mathrm{kWh}-\\) . From Formula SAE rules, the maximum power of the battery pack is \\(80 \\mathrm{~kW}\\) . This is computed as follow. \\[ P_{\\text {batt }}=V_{\\text {batt }} I_{\\text {batt }} \\] Where \\(P_{\\text {batt }}\\) is the battery power, in watt, \\(V_{\\text {batt }}\\) is the voltage supply, in volt, and \\(I_{\\text {batt }}\\) is the provided current, in ampere. The maximum voltage is \\(E_{\\text {batt }}=450 \\mathrm{~V}\\) . \\(V_{\\text {batt }}\\) can be computed starting from \\(E_{\\text {batt }}\\) and subtracting the potential drop due to the internal battery cells resistance \\(-V_{\\text {batt }}=E_{\\text {batt }}-I_{\\text {batt }} R_{\\text {tot }}\\) with \\(R_{\\text {tot }} \\approx 0.46 \\Omega-\\) . Knowing that the inverters convert the DC voltage into an AC three-phase voltage and assuming that the power is split in a symmetric way between the two motors, it is possible to compute the effective motor current \\(\\left(I_{m o t, r m s}\\right)\\) . This current is used to compute the motor torque by means of the motor characteristic. The motors are connected to an ordinary single-stage gearbox with transmission ratio \\(\\tau_{\\text {red }}=52 / 15\\) and with efficiency \\(\\left(\\eta_{\\text {red }}\\right)\\) around \\(0.93\\) . Each motor is able to provide \\(80 \\mathrm{Nm}\\) when the battery pack is fully charge. This torque is almost constant in the entire velocity range, from 0 to \\(\\omega_{\\text {mot,Max }}\\) - for this motors, \\(\\omega_{\\text {mot }, \\text { Max }} \\approx 5200 \\mathrm{rpm}-\\) . The torque cutting speed \\(\\left(\\omega_{\\text {motTorqueCut }}\\right)\\) is set equal to \\(4800 \\mathrm{rpm}\\) and represents the speed from which the torque decreases linearly until \\(\\omega_{\\text {mot,Max }}\\) , where the torque is equal to zero. However, the maximum motor speed is not the only limit at which the motors are subjected. There is also a power limit that cuts the torque when it is larger than \\(T_{m, \\text { MaxSpeed }}=P_{\\text {batt }} /\\left(2 \\omega_{\\text {mot }}\\right)\\) . To sum up: If \\(T_{m, r e q} \\omega_{\\text {mot }} \\leq P_{\\text {batt }}\\) and \\(\\omega_{\\text {mot }} \\leq \\omega_{\\text {maxTorqueCut }}\\) \\[ T_{w, \\text { mot }}=T_{m, \\text { req }} \\tau_{\\text {red }} \\theta_{\\text {red }} \\] If \\(T_{m, r e q} \\omega_{m o t}>P_{\\text {batt }}\\) and \\(\\omega_{\\text {mot }} \\leq \\omega_{\\text {maxTorqueCut }}\\) \\[ T_{w, \\text { mot }}=\\frac{P_{\\text {batt }}}{2 \\omega_{\\text {mot }}} \\tau_{\\text {red }} \\theta_{\\text {red }} \\] If \\(\\omega_{\\text {mot }}>\\omega_{\\operatorname{maxTorqueCut}}\\) \\[ T_{w, \\text { mot }}=\\left[T_{m, \\text { maxSpeed }}+\\frac{T_{m, \\text { max Speed }}}{\\omega_{\\text {maxTorqueCut }}-\\omega_{\\text {mot,Max }}}\\left(\\omega_{\\text {mot }}-\\omega_{\\text {motTorqueCut }}\\right)\\right] \\tau_{\\text {red }} \\theta_{\\text {red }} \\] where \\(T_{m, \\text { req }}\\) is the motor required torque and \\(T_{w, m o t}\\) is the torque available at the wheel. In order to consider also the actuation delay, a first-order differential equation is applied to the required motor torque. \\[ \\tau_{\\text {mot }} \\dot{T}_{m, \\text { req }}=\\left(p_{D r} T_{\\text {mot,Max }}-T_{m, r e q}\\right) \\] \\(p_{D r}\\) is the throttle pedal level that can vary from zero to one \\(-p_{D r} \\in[0,1]-\\) .","title":"Powertrain model"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#aerodynamic-model","text":"The aerodynamic forces are applied to a virtual point called centre of pressure \\(\\left(P_{A}\\right)\\) placed in \\(\\left[x_{A}, 0, z_{A}\\right]^{T}\\) . The lift \\(\\left(F_{z A}\\right)\\) is the vertical component of the aerodynamic force while the \\(\\operatorname{drag}\\left(F_{x A}\\right)\\) is the longitudinal one. An equivalent set of forces can be computed in such a way that the aerodynamic lift is divided between the front and the rear axle and the drag is applied to the projection of the centre of mass to the ground. Figure 6: Application scheme of aerodynamic forces \\[ \\left\\{\\begin{array}{l} F_{A D}=F_{x A} \\\\ F_{z A R}+F_{z A F}=F_{z A} \\\\ F_{z A F} L_{F}-F_{z A R} L_{R}=F_{z A} z_{A}-F_{x A} z_{A} \\end{array}\\right. \\] Since the aerodynamic forces have a quadratic dependency on the longitudinal velocity, we can write as follow. \\[ \\left\\{\\begin{array}{l} F_{A D}=C_{A x} u^{2}=C_{D} u^{2} \\\\ F_{z A R}=C_{A z R} u^{2}=C_{L}\\left(1-\\epsilon_{A}\\right) u^{2} \\\\ F_{z A F}=C_{A z F} u^{2}=C_{L} \\epsilon_{A} u^{2} \\end{array}\\right. \\] \\(C_{D}\\) and \\(C_{L}\\) are the real drag and lift coefficients, respectively. \\(C_{A D}, C_{A z R}\\) and \\(C_{A z F}\\) are the transformed drag and axle-lift coefficients. \\(\\epsilon_{A}\\) is the aero-balance and is defined as \\(F_{z A F} / F_{z A}\\) . It quantifies the amount of total downforce applied at the front axle.","title":"Aerodynamic model"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#load-transfer-model","text":"In the double-track vehicle model, the tire vertical load can be divided into two terms: the first - \\(F_{z i}\\) with \\(i=\\{R, F\\}\\) - considers the static force, the aerodynamic forces and the longitudinal load transfer - generated by the longitudinal acceleration \\(a_{x}\\) -; the second - \\(\\Delta F_{z i}\\) with \\(i=\\{R, F\\}\\) - corresponds to the lateral load transfer. \\[ \\left\\{\\begin{array}{l} F_{z R R}=F_{z R} / 2+\\Delta F_{z R} \\\\ F_{z R L}=F_{z R} / 2-\\Delta F_{z R} \\\\ F_{z F R}=F_{z F} / 2+\\Delta F_{z F} \\\\ F_{z F L}=F_{z F} / 2-\\Delta F_{z F} \\end{array}\\right. \\] The following computation shows how the two components of the vertical force are computed. \\(F_{y i}, i=\\{R, F\\}\\) are the axle lateral force and \\(K_{\\phi i}, i=\\{R, F\\}\\) are the rear and front roll stiffness. \\[ \\begin{array}{ll} F_{z R}=M g \\frac{L_{F}}{L}+M a_{x} \\frac{h_{G s}}{L}+\\left|F_{z A R}\\right| & \\Delta F_{z R}=F_{y R} \\frac{h_{R R}}{W_{R}}+\\frac{K_{\\phi R}}{W_{R}} \\phi \\\\ F_{z F}=M g \\frac{L_{R}}{L}-M a_{x} \\frac{h_{G s}}{L}+\\left|F_{z A F}\\right| & \\Delta F_{z F}=F_{y F} \\frac{h_{R F}}{W_{F}}+\\frac{K_{\\phi F}}{W_{F}} \\phi \\end{array} \\] From equations 22, it is possible to distinguish two components in the load transfer. The first component, called transient load transfer, involves the roll stiffness. It means that it is generated from the suspension/tire deformation. The second term, named instantaneous load transfer, is absorbed by the suspension structure and does not cause suspension deflection. In the vehicle model taken into consideration, the spring mass is seen as a rigid body that is suspended by four springs, representing the suspension/tire systems. From the model kinematics, it is possible to find the coordinates of the spring anchor points \\({ }^{0} S_{i j}, i=\\{R, F\\}, j=\\{R, L\\}\\) - and compute their height variation \\(\\left(\\Delta z_{i j}\\right)\\) . \\[ { }^{0} S_{i j}=R F_{S} \\cdot\\left[\\pm L_{i}, \\pm W_{i} / 2,0,1\\right]^{T} \\quad \\rightarrow \\quad \\Delta z_{i j}=h_{R i}-{ }^{0} S_{i j}(3) \\] \\(R F_{S}\\) is defined in the expression 3. The sign of the coordinates \\((\\pm)\\) depends on the indices \\(i\\) and \\(j\\) . The supra-script \\({ }^{0}\\) means that the considered point must be projected in the ground plane. For the computation of \\(\\Delta z_{i j}\\) , the third component of the point \\({ }^{0} S_{i j}\\) is needed \\(\\left({ }^{0} S_{i j}(3)\\right)\\) . Then, using the definition of the spring anchor points, the load transfer can be computed as follow. \\[ F_{z R R}=M g \\frac{L_{F}}{2 L}+\\frac{\\left|F_{z A R}\\right|}{2}+F_{y R} \\frac{h_{R R}}{W_{R}}+K_{s R} \\Delta z_{R R}+ +C_{s R} \\frac{d\\left(\\Delta z_{R R}\\right)}{d t}-K_{A R B, R}\\left(z_{R R}-z_{R L}\\right) \\\\ F_{z R L}=M g \\frac{L_{F}}{2 L}+\\frac{\\left|F_{z A R}\\right|}{2}-F_{y R} \\frac{h_{R R}}{W_{R}}+K_{s R} \\Delta z_{R L}+ +C_{s R} \\frac{d\\left(\\Delta z_{R L}\\right)}{d t}+K_{A R B, R}\\left(z_{R R}-z_{R L}\\right) \\\\ F_{z F R}=M g \\frac{L_{R}}{2 L}+\\frac{\\left|F_{z A F}\\right|}{2}+F_{y F} \\frac{h_{R F}}{W_{F}}+K_{s F} \\Delta z_{F R}+ +C_{s F} \\frac{d\\left(\\Delta z_{F R}\\right)}{d t}-K_{A R B, F}\\left(z_{F R}-z_{F L}\\right) \\\\ F_{z F L}=M g \\frac{L_{R}}{2 L}+\\frac{\\left|F_{z A F}\\right|}{2}-F_{y F} \\frac{h_{R F}}{W_{F}}+K_{s F} \\Delta z_{F L}+ +C_{s F} \\frac{d\\left(\\Delta z_{F L}\\right)}{d t}+K_{A R B, F}\\left(z_{F R}-z_{F L}\\right) \\] In equation 24, the terms with \\(K_{s}\\) are the stiffness of the suspension and tire subsystem - \\(K_{s}=\\left(K_{susp}^{-1}+K_{\\text {tire}}^{-1}\\right)^{-1}\\) -. The same for the damping factor \\(\\left(C_{s}\\right) . K_{ARB}\\) is the front or rear anti-roll bar stiffness. These expressions can be generalized introducing non-linear damping effects or introducing a differential stiffness in case of a shock absorber. For the specific case of non-linear dampers, a case function can be implemented in to select the proper coefficients in relation to the effective speed of the damper itself. \\[ dl_{fr} = -(atan2(-((h_rc_{f} ^ 2 - 2 * h_rc_{f} * h_rc_{r} + h_rc_{r} ^ 2 + (Lf + Lr) ^ 2) ^{-0.1e1 / 0.2e1} * (h_rc_{f} - h_rc_{r})), \\\\((h_rc_{f} ^ 2 - 2 * h_rc_{f} * h_rc_{r} + h_rc_{r} ^ 2 + (Lf + Lr) ^ 2) ^{-0.1e1 / 0.2e1} * (Lf + Lr))) * sin(mu) - cos(mu)) * Lf * mu_{dot} + (-0.2e1 * sin(mu) * phi * Lf + Wf) * phi_{dot} / 0.2e1 - z_{dot}\\\\ \\] \\[ dl_{fl} = -(atan2(-((h_rc_{f} ^ 2 - 2 * h_rc_{f} * h_rc_{r} + h_rc_{r} ^ 2 + (Lf + Lr) ^ 2) ^{-0.1e1 / 0.2e1} * (h_rc_{f} - h_rc_{r})), \\\\((h_rc_{f} ^ 2 - 2 * h_rc_{f} * h_rc_{r} + h_rc_{r} ^ 2 + (Lf + Lr) ^ 2) ^{-0.1e1 / 0.2e1} * (Lf + Lr))) * sin(mu) - cos(mu)) * Lf * mu_{dot} + (-0.2e1 * sin(mu) * phi * Lf - Wf) * phi_{dot} / 0.2e1 - z_{dot}\\\\ \\] \\[ dl_{rr} = (atan2(-((h_rc_{f} ^ 2 - 2 * h_rc_{f} * h_rc_{r} + h_rc_{r} ^ 2 + (Lf + Lr) ^ 2) ^{-0.1e1 / 0.2e1} * (h_rc_{f} - h_rc_{r})), \\\\((h_rc_{f} ^ 2 - 2 * h_rc_{f} * h_rc_{r} + h_rc_{r} ^ 2 + (Lf + Lr) ^ 2) ^{-0.1e1 / 0.2e1} * (Lf + Lr))) * sin(mu) - cos(mu)) * Lr * mu_{dot} + (0.2e1 * sin(mu) * Lr * phi + Wr) * phi_{dot} / 0.2e1 - z_{dot}\\\\ \\] \\[ dl_{rl} = (atan2(-((h_rc_{f} ^ 2 - 2 * h_rc_{f} * h_rc_{r} + h_rc_{r}^ 2 + (Lf + Lr) ^ 2) ^{-0.1e1 / 0.2e1} * (h_rc_{f} - h_rc_{r})), \\\\((h_rc_{f} ^ 2 - 2 * h_rc_{f} * h_rc_{r} + h_rc_{r} ^ 2 + (Lf + Lr) ^ 2) ^{-0.1e1 / 0.2e1} * (Lf + Lr))) * sin(mu) - cos(mu)) * Lr * mu_{dot} + (0.2e1 * sin(mu) * Lr * phi - Wr) * phi_{dot} / 0.2e1 - z_{dot}\\\\ \\]","title":"Load transfer model"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#brake-model","text":"The brake behaviour can be reduced to friction phenomenon and, for this reason, can result difficult to be accurately modelled. It can be argued that the friction forces aim to minimize the object speed under the constraint of the friction cone or, in practice, of the maximum friction force. Christian Studer [20] presents the time-stepping method in order to model a non-smooth dynamical mode \\(4^{2}\\) In order to model the brake system behaviour, a time-stepping technique is used to smooth the model outputs. The time-stepping version used in our model is based on the wheels rolling dynamical equation, reported in 25 \\[ I_{a, W} \\dot{\\omega}(t)=T_{w, m o t}-T_{w, b r k}-F_{x} R \\] \\({ }^{2}\\) A non-smooth dynamical model is a model in which the generalized positions \\(\\bar{q}\\) or velocities \\(\\bar{u}\\) jump. In the jump instant, the acceleration can not be defined. where \\(T_{w, m o t}\\) and \\(T_{w, b r k}\\) are the torque at the wheel from the motor and from the braking system respectively, \\(F_{x}\\) is the longitudinal tire force, \\(R\\) is the tire radius and \\(\\omega\\) is the wheel spin velocity. Assuming an explicit Euler integration scheme, it is possible to substitute the acceleration term with equation 25 \\[ \\begin{aligned} \\omega(t+\\Delta t) & =\\omega(t)+\\dot{\\omega} \\Delta t \\\\ & =\\omega(t)+\\frac{T_{w, \\text { mot }}-T_{w, b r k}-F_{x} R}{I_{a, W}} \\Delta t \\\\ & =\\frac{s-T_{w, b r k} \\Delta t}{I_{a, W}} \\end{aligned} \\] where \\(\\Delta t\\) is the integration time-step and \\(s=I_{a, W} \\omega(t)+\\left(T_{w, m o t}-F_{x} R\\right) \\Delta t\\) . As previously mentioned, the friction forces acting on the disk aim to minimize the wheel speed. For this reason, to find the friction forces, we need to solve a minimization problem. \\[ \\begin{array}{lc} \\underset{T_{w, b r k}}{\\operatorname{minimize}} & {\\left[\\frac{s-T_{w, b r k} \\Delta t}{I_{a, W}}\\right]^{2}} \\\\ \\text { subject to } & -T_{w, b r k}^{M a x} \\leq T_{w, b r k} \\leq T_{w, b r k}^{\\text {Max }} \\end{array} \\] The minimization problem presented in 27 is simple to solve because the cost function is quadratic. The solution is reported in 28 . \\[ T_{w, b r k}= \\begin{cases}s / \\Delta t & \\text { if }|s / \\Delta t| \\leq T_{w, b r k}^{M a x} \\\\ T_{w, b r k}^{\\text {Max }} \\operatorname{sign}(s) & \\text { otherwise }\\end{cases} \\] The maximum braking torque \\(\\left(T_{w, b r k}^{M a x}\\right)\\) is defined starting from the brake pedal input \\(p_{b r k} \\epsilon[0,1]\\) -. Moreover, a first-order dynamical equation is applied in order to consider the actuation delay. \\[ \\begin{gathered} \\left\\{\\begin{array}{l} T_{b r k, R e q, F}=p_{b r k} T_{b r k}^{M a x} \\epsilon_{b r k} \\\\ T_{b r k, R e q, R}=p_{b r k} T_{b r k}^{M a x}\\left(1-\\epsilon_{b r k}\\right) \\end{array}\\right. \\\\ \\left\\{\\begin{array}{l} \\tau_{b r k}\\,\\dot{T}_{w, b r k, F}^{M a x}=\\left(T_{b r k, R e q, F}-T_{w, b r k, F}\\right) \\\\ \\tau_{b r k}\\,\\dot{T}_{w, b r k, R}^{M a x}=\\left(T_{b r k, R e q, R}-T_{w, b r k, R}\\right) \\end{array}\\right. \\end{gathered} \\] where \\(T_{b r k}^{\\text {Max }}\\) is the maximum braking torque that the hydraulic system can generate, \\(\\epsilon_{b r k}\\) is the braking ratio that refers to the percentage of the braking torque available at the front and \\(\\tau_{b r k}\\) is the actuator time constant.","title":"Brake model"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#steering-system-model","text":"The vehicle is front wheel steering. Studying the steering system model, the steering system kinematic behaviour is fitted with polynomials that connect the Hand-Wheel steering angle \\(\\left(\\delta_{H W}\\right)\\) with the front wheels steering angles \\(\\left(\\left\\{\\delta_{F L}, \\delta_{F R}\\right\\}\\right)\\) . This polynomial can be derived from the fenice-steering-system-DMT repository. Figure 7: Representation of half steering model built in Maple The polynomial function is relatively computationally cheap but, at the same time, it allows us to consider also the non-linear behaviour of the steering system. The steering kinematics may change with the suspension deformation. However, the changing due to the suspension deflection does not have a main contribute and can be neglected. Figure 8: Steering model fitting results computed in Maple The actuation delay is considered by means of a first-order differential equation where \\(\\tau_{H}\\) is the steering system time constant. \\[ \\tau_{H} \\dot{\\delta}_{H W}=\\left(\\delta_{r e q}-\\delta_{H W}\\right) \\]","title":"Steering system model"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#first-order-reduction","text":"The dynamical equations, in general, are of order 2. This problem is partially solved by the use of the quasi-coordinates 3 , however, in equations of motions, the second-order derivatives of \\(z, \\theta\\) and \\(\\phi\\) appear. In order to neglect these terms, three additionally differential equations (equation 32) can be added in order to solve the second-order derivation and simplify the numerical solution process. \\[ \\left\\{\\begin{array}{l} \\dot{z}(t)=z_{\\text {dot }}(t) \\\\ \\dot{\\phi}(t)=\\phi_{\\text {dot }}(t) \\\\ \\dot{\\theta}(t)=\\theta_{\\text {dot }}(t) \\end{array}\\right. \\] \\({ }^{3}\\) For the vehicle description, \\(u, v\\) and \\(\\Omega\\) are usually employed, substituting the classical coordinates \\(x, y\\) and \\(\\psi\\) . Since they are not actually coordinates but velocities, they are named quasi-coordinates.","title":"First order reduction"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#equation-of-motion","text":"The full set of Dynamical equations can be found in [16] (pp. 47-50). Here, the system equations are listed only: 3 Newton equations; 3 Euler equations; 1 equation for the steering dynamics; 2 equations for the motor actuation dynamics; 2 equations for the brake actuation dynamics; 4 equations for the longitudinal slip dynamics; 4 equations for the lateral slip dynamics; 4 equations for the wheel spin dynamics; 3 equations for the first order reduction Hence, the total number of differential equations is 26 . Moreover, the system has other 26 equations: 2 equations for the steering system kinematics; 4 equations for the steady-state longitudinal slip computation; 4 equations for the steady-state lateral slip computation; 4 equations for the load transfer computation; 12 equations for the tire forces and self-aligning torque computation The system states are divided into differential \\((\\bar{X})\\) and algebraic \\(\\left(\\bar{X}_{a l g}\\right)\\) and are reported in the expressions 33 and 34 . \\[ \\begin{aligned} \\bar{X}=\\{ & u, v, \\Omega, z, \\phi, \\theta, \\delta, T_{m o t, R R}, T_{m o t, R L}, T_{b r k, R}, T_{b r k, F}, \\alpha_{R R}, \\alpha_{R L}, \\alpha_{F R}, \\alpha_{F L}, \\\\ & \\left.\\lambda_{R R}, \\lambda_{R L}, \\lambda_{F R}, \\lambda_{F L}, \\omega_{R R}, \\omega_{R L}, \\omega_{F R}, \\omega_{F L}, z_{\\text {dot }}, \\phi_{\\text {dot }}, \\theta_{\\text {dot }}\\right\\} \\end{aligned} \\] \\[ \\begin{aligned} \\bar{X}_{a l g}=\\{ & \\delta_{F R}, \\delta_{F L}, \\lambda_{S S, R R}, \\lambda_{S S, R L}, \\lambda_{S S, F R}, \\lambda_{S S, F L}, \\alpha_{S S, R R}, \\alpha_{S S, R L}, \\alpha_{S S, F R}, \\alpha_{S S, F L}, \\\\ & F_{z R R}, F_{z R L}, F_{z F R}, F_{z F L}, F_{x R R}, F_{x R L}, F_{x F R}, F_{x F L}, \\\\ & \\left.F_{y R R}, F_{y R L}, F_{y F R}, F_{y F L} M_{y R R}, M_{y R L}, M_{y F R}, M_{y F L}\\right\\} \\end{aligned} \\] The 10 degrees of freedom (DoF) of the model are composed by: 3 DoF are related to the planar motion in the absolute ground plane. They are given by the vehicle \\(\\{x, y\\}\\) coordinates and by the yaw-angle \\(\\psi\\) . Alternatively, these three DoF can be associated to the quasi-coordinates \\(\\{u, v, \\Omega\\}\\) . 3 DoF are given by the internal dynamics \\(\\{z, \\phi, \\theta\\}\\) . 4 DoF are given by the wheels spin \\(\\left\\{\\omega_{R R}, \\omega_{R L}, \\omega_{F R}, \\omega_{F L}\\right\\}\\) . The inputs of the model are the hand-wheel steering angle \\(\\left(\\delta_{H W}\\right)\\) and the throttle and brake pedal \\(\\left(\\left\\{p_{D r}, p_{b r k}\\right\\}\\right)\\) . However, a longitudinal velocity tracker is implemented using a PID controller. It takes as input the desired velocity profile and returns the value of the throttle and of the brake pedals needed to track that speed profile.","title":"Equation of Motion"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#references","text":"[1] Acosta, M., Kanarachos, S. - Tire lateral force estimation and grip potential identification using Neural Networks, Extended Kalman Filter, and Recursive Least Squares. Neural Comput \\& Applic 30, 3445-3465 (2018). https://doi.org/10.1007/s00521-017-2932-9 [2] Acosta M., Kanarachos S. and Fitzpatrick M. E., \"Robust Virtual Sensing for Vehicle Agile Manoeuvring: A Tyre-Model-Less Approach,\" in IEEE Transactions on Vehicular Technology, vol. 67, no. 3, pp. 1894-1908, March 2018, doi: 10.1109/TVT.2017.2767942. [3] \u00c5kesson B. M., J\u00f8rgensen J. B., Poulsen N. K., J\u00f8rgensen S. B., A tool for kalman filter tuning, Editor(s): Valentin Ple\u015fu, Paul \u015eerban Agachi, Computer Aided Chemical Engineering, Elsevier, Volume 24, 2007, ISBN 9780444531575, https://doi.org/10.1016/S1570-7946(07)80166-0. [4] Alatorre A. G., Charara A. and Victorino A., \"Sideslip estimation algorithm comparison between Euler angles and quaternion approaches with black box vehicle model,\" 2018 IEEE 15th International Workshop on Advanced Motion Control (AMC), Tokyo, 2018, pp. 553-559, doi: 10.1109/AMC.2019.8371153. [5] Da Lio M., Bortoluzzi D. \\& Rosati Papini G. P. (2020) Modelling longitudinal vehicle dynamics with neural networks, Vehicle System Dynamics, 58:11, 1675-1693, DOI: \\(10.1080 / 00423114.2019 .1638947\\) [6] De Pascali L., Biral F., Cocetti M., Zaccarian L. and Tarbouriech S., \"A kinematic observer with adaptive dead-zone for vehicles lateral velocity estimation,\" 2018 IEEE 15th International Workshop on Advanced Motion Control (AMC), Tokyo, 2018, pp. 511-516, doi: 10.1109/AMC.2019.8371146. [7] Farrelly J. and Wellstead P., \"Estimation of vehicle lateral velocity,\" Proceeding of the 1996 IEEE International Conference on Control Applications IEEE International Conference on Control Applications held together with IEEE International Symposium on Intelligent Contro, Dearborn, MI, USA, 1996, pp. 552-557, doi: 10.1109/CCA.1996.558920. [8] Fern\u00e1ndez J. G. (2012) - A Vehicle Dynamics Model for Driving Simulators Chalmers University of Technology [9] Gelen A. G. and Atasoy A., \"A New Method for Kalman Filter Tuning,\" 2018 International Conference on Artificial Intelligence and Data Processing (IDAP), Malatya, Turkey, 2018, pp. 1-6, doi: 10.1109/IDAP.2018.8620863. [10] Guiggiani M. (2014) \"The science of vehicle dynamics\", Springer Netherlands, pp: 137-144 [11] James S. S., Anderson S. R. and Da Lio M., \"Longitudinal Vehicle Dynamics: A Comparison of Physical and Data-Driven Models Under Large-Scale RealWorld Driving Conditions,\" in IEEE Access, vol. 8, pp. 73714-73729, 2020, doi: 10.1109/ACCESS.2020.2988592. [12] Larcher M. (2019) - Development of a 14 Degrees of Freedom Vehicle Model for Realtime Simulations in 3D Environment - Universit\u00e0 di Trento [13] Lot R. and Da Lio M. \"A symbolic approach for automatic generation of the equations of motion of multibody systems\", 2004, Multibody System Dynamics, 12(2): \\(147-172\\) [14] Oshaman Y., Shaviv I. \"Optimal tuning of a Kalman Filter using Genetic Algorithm\" Technion - Israel Institute of Technology (2000), doi: https://doi.org/10.2514/6.2000-4558 [15] Panzani G., Corno M., Savaresi S.M., \"Longitudinal Velocity Estimation in SingleTrack Vehicles\", IFAC Proceedings Volumes, Volume 45, Issue 16, 2012, Pages 17011706, https://doi.org/10.3182/20120711-3-BE-2027.00164. [16] Piccinini M. (2019) - Path Planning and Control of Self Driving Vehicles at the Limit of Handling - Universit\u00e0 di Trento - Ch: 2 [17] Regolin E., Alatorre A., Zambelli M., Victorino A., Charara A. and Ferrara A., \"A Sliding-Mode Virtual Sensor for Wheel Forces Estimation With Accuracy Enhancement via EKF,\" in IEEE Transactions on Vehicular Technology, vol. 68, no. 4, pp. 3457-3471, April 2019, doi: 10.1109/TVT.2019.2903598. [18] Ryu J., Nardi F., \\& Moshchuk N. \"Vehicle Sideslip Angle Estimation and Experimental Validation.\" Proceedings of the ASME 2013 International Mechanical Engineering Congress and Exposition. Volume 4A: Dynamics, Vibration and Control. San Diego, California, USA. November 15-21, 2013. V04AT04A052. ASME. https://doi.org/10.1115/IMECE2013-64466 [19] Ru\u017einskas A., Sivilevi\u010dius H., \"Magic Formula Tyre Model Application for a Tyre-Ice Interaction\", Procedia Engineering, Volume 187, 2017, https://doi.org/10.1016/j.proeng.2017.04.383. [20] Studer C. (2009) \"Numerics of Unilateral Contacts and Friction - Modeling and Numerical Time Integration in Non-Smooth Dynamics\", Springer-Verlag Berlin Heidelberg, pp. 59-127 [21] Viehweger M., Vaseur C., van Aalst S., Acosta M., Regolin E., Alatorre A., Desmet W., Naets F., Ivanov V., Ferrara A. \\& Victorino A. (2020) Vehicle state and tyre force estimation: demonstrations and guidelines, Vehicle System Dynamics, DOI: \\(10.1080 / 00423114.2020 .1714672\\) [22] Enciclopedia Treccani - https://www.treccani.it/enciclopedia/metodo-montecarlo/ [23] Enciclopedia Treccani - https://www.treccani.it/enciclopedia/gradi-di-liberta/","title":"References"},{"location":"fenice-vehicle-model-DMT/Theory/Vehicle_Model/#release-notes","text":"V1.0: 12/2020: Initial Release (Matteo Tomasi) V1.1: 10/12/2022: Added suspension velocities for non linear dampers and steering map (Luca Dalle Sasse)","title":"Release Notes"},{"location":"fenice-vehicle-model-DMT/Theory/Velocity_Estimation/","text":"Velocity Estimation Theory Accurate estimation of longitudinal vehicle speed is crucial for effective design and implementation of Anti-lock Braking Systems (ABS) and Traction Control Systems (TCS). The knowledge of the current value of the vehicle speed, in fact, is the key for computing the longitudinal wheel slip, which is the main control variable in the Slip Control implemented in Fenice. Different algorithms for the velocity estimation were implemented by the modelling and dynamics team during the last years, this report has the goal to select the best one to implement in Fenice and the reasoning behind. Raw algorithm This algorithm consists in evaluating at each time step simply the mean between the front wheels linear velocities of the vehicle. It is the simplest way to compute the longitudinal velocity and also less accurate but it could be useful in testing the control in order to have a lower computational effort which results in a lower simulation time. Figure 1 - Simulink block diagram of the row algorithm Panzani algorithm The Panzani algorithm takes as input the data acquired from the encoders in the front wheels and from the accelerometer positioned in the centre of mass of the vehicle. It consists of a complementary filter that performs a frequency weighted fusion of two sensors. This is useful, as the available sensors have different noise characteristics in the frequency domain. The longitudinal velocity estimation is constructed as the summation of 2 contributions: the low-pass filtered wheel velocity, and the high-pass filtered integrated longitudinal acceleration. Low-pass filtering the wheel velocity removes high-frequency noise, but introduces a phase lag; the phase lag is compensated for by the integrated longitudinal acceleration. High-pass filtering the longitudinal acceleration removes the bias before the integration, thus leaving only the high frequency components. In the implementation of this sensor fusion we have 2 parameters to tune: the cut of frequency of the filter and the order of the filter. A first order filter has been implemented considering similar cases found in the literature and a trial and error approach has been used to determine the cut of frequency. This algorithm is particularly robust because the complementary filter takes advantage of the strengths of both the sensors and compensates for the drawbacks of each other by making a sensor fusion of them. Figure 2 - Simulink block diagram of the Panzani algorithm Savaresi algorithm The Savaresi algorithm takes as input the data acquired from the encoders in the front wheels, the data from the accelerometer positioned in the centre of mass of the vehicle and unlike the Panzani algorithm it also reads the angular velocity of the rear wheels from the inverters. To summarise, through all these sensors, we have available for our estimation the angular velocity of both front and rear wheels and the longitudinal acceleration of the vehicle. The algorithm consists of a finite state machine, where the states are: vehicle speed is very low, vehicle is accelerating, vehicle has constant speed or is softly braking and vehicle is braking. The algorithm behaviour changes according to the status of the vehicle. Each state gives different weight to the described sensors, in such a way it is possible to rely more on the sensors that for a certain state are less affected by errors. In order to change status we have defined some thresholds in velocity and acceleration that must be tuned using the data acquired during the race tests. Although this algorithm is in theory really robust due to the big quantity of data that can elaborate, it presents some problems, in particular in the \"braking state\" where it is not fast enough to follow our reference data acquired with the GPS. Possible reasons that we have identified as responsible for this problem are: a non adequate filter of the acceleration or a non proper tuning of the thresholds. Figure 3 - Simulink block diagram of the Savaresi algorithm Figure 4 - Matlab script of the Savaresi algorithm Comparison The most relevant parameters influencing the selection of an algorithm with respect to another one are the accuracy of the estimation (which is done comparing the results with the GPS data) and the complexity of the algorithm, which turns into a slow response of the system. Those 2 parameters generally are a trade-off, in fact for better accuracy we need a complex algorithm that requires a higher computational effort and as a consequence in the time needed to perform the calculation. In order to evaluate the performance of the 3 algorithms we can compare their behaviour using the data acquired from the GPS during the tests done with \"ChimeraEvo\". The algorithms will be judged in different types of tests which correspond to different types of manoeuvre executed by the pilot. The step size used in the simulations will be always the same for both the algorithms. Three different tests have been selected in order to highlight the behaviour of the three algorithms and their advantages and disadvantages. Straight line manoeuvre As we can see all the three algorithms are quite accurate in this simple manoeuvre, in particular no one has problems in tracking the acceleration phase, which correspond in the pieces of the curve where the velocity increases. Tracking error increases in the breaking phase in particular for the Savaresi algorithm which presents a delay in detecting the breaking phase and a consequent extremely high deceleration in order to compensate for the delay in the detection. On the other hand the Panzani and the raw algorithm follow quite well the GPS data. For this manoeuvre the best tracking is performed by the Panzani Algorithm, but it has also a drawback, it is quite sensitive to the time step used for the simulation. For relatively high time step the response becomes quite noise, instead the Savaresi algorithm and the row algorithm are less sensitive to the increment of the time step but they remain less accurate with respect to the Panzani algorithm. Sine steer manoeuvre A sine steer manoeuvre involves a first phase of acceleration until the vehicle hits a target velocity then the pilot has to perform a sinusoidal steering wheel input and then linearly increase the frequency of the sinusoidal wave. The velocity estimated by the three algorithms in this manoeuvre is more noisy with respect to the straight line because of the complexity of the manoeuvre the acquired data from the sensors are more affected by vibrations and other external noise sources. The same considerations done for the previous test are valid for this one where we can highlight the tracking problem of the Savaresi algorithm in the breaking phase which is again clearly visible. We can also notice that the row and Savaresi algorithm make an overestimation of the velocity while the vehicle is in a constant velocity status. Figure 5 - Sine steer manoeuvre Half skid pad manoeuvre This test consists of following a circular track with a defined radius where the pilot has to accelerate until the vehicle tires slip with respect to ground, then it has to maintain a constant velocity. In this pot we can add to the previous consideration the presence of an instability in the Savaresi algorithm in tracking a sudden variation in acceleration. Figure 6 - Half skip pad manoeuvre Selection of the most accurate algorithm Considering the performance of the three algorithms, the selected one to be used for the velocity estimation required by both the traction control and the torque vectoring is the Panzani algorithm. All the three approaches have potential but the Panzani is the most stable and creates the lowest tracking error. Further improvements As mentioned before the main problem in the Savaresi algorithm is related to the breaking status. Actually we are investigating different ways to solve this problem, implementing more sophisticated filters for the input data and trying different configurations for the tuning of the parameters of the algorithms. We are also searching in the literature how similar problems have been solved. Revision History V1.0 22/06/2022: Initial release: Matteo Da Re. Bibliography Tanelli M., Savaresi S. M., Cantoni C., 2006, Longitudinal vehicle speed for traction and braking control systems Corno, M., Panzani G., Savaresi S., 2013, Traction-Control-Oriented State Estimation for Motorcycles","title":"Velocity Estimation Theory"},{"location":"fenice-vehicle-model-DMT/Theory/Velocity_Estimation/#velocity-estimation-theory","text":"Accurate estimation of longitudinal vehicle speed is crucial for effective design and implementation of Anti-lock Braking Systems (ABS) and Traction Control Systems (TCS). The knowledge of the current value of the vehicle speed, in fact, is the key for computing the longitudinal wheel slip, which is the main control variable in the Slip Control implemented in Fenice. Different algorithms for the velocity estimation were implemented by the modelling and dynamics team during the last years, this report has the goal to select the best one to implement in Fenice and the reasoning behind.","title":"Velocity Estimation Theory"},{"location":"fenice-vehicle-model-DMT/Theory/Velocity_Estimation/#raw-algorithm","text":"This algorithm consists in evaluating at each time step simply the mean between the front wheels linear velocities of the vehicle. It is the simplest way to compute the longitudinal velocity and also less accurate but it could be useful in testing the control in order to have a lower computational effort which results in a lower simulation time. Figure 1 - Simulink block diagram of the row algorithm","title":"Raw algorithm"},{"location":"fenice-vehicle-model-DMT/Theory/Velocity_Estimation/#panzani-algorithm","text":"The Panzani algorithm takes as input the data acquired from the encoders in the front wheels and from the accelerometer positioned in the centre of mass of the vehicle. It consists of a complementary filter that performs a frequency weighted fusion of two sensors. This is useful, as the available sensors have different noise characteristics in the frequency domain. The longitudinal velocity estimation is constructed as the summation of 2 contributions: the low-pass filtered wheel velocity, and the high-pass filtered integrated longitudinal acceleration. Low-pass filtering the wheel velocity removes high-frequency noise, but introduces a phase lag; the phase lag is compensated for by the integrated longitudinal acceleration. High-pass filtering the longitudinal acceleration removes the bias before the integration, thus leaving only the high frequency components. In the implementation of this sensor fusion we have 2 parameters to tune: the cut of frequency of the filter and the order of the filter. A first order filter has been implemented considering similar cases found in the literature and a trial and error approach has been used to determine the cut of frequency. This algorithm is particularly robust because the complementary filter takes advantage of the strengths of both the sensors and compensates for the drawbacks of each other by making a sensor fusion of them. Figure 2 - Simulink block diagram of the Panzani algorithm","title":"Panzani algorithm"},{"location":"fenice-vehicle-model-DMT/Theory/Velocity_Estimation/#savaresi-algorithm","text":"The Savaresi algorithm takes as input the data acquired from the encoders in the front wheels, the data from the accelerometer positioned in the centre of mass of the vehicle and unlike the Panzani algorithm it also reads the angular velocity of the rear wheels from the inverters. To summarise, through all these sensors, we have available for our estimation the angular velocity of both front and rear wheels and the longitudinal acceleration of the vehicle. The algorithm consists of a finite state machine, where the states are: vehicle speed is very low, vehicle is accelerating, vehicle has constant speed or is softly braking and vehicle is braking. The algorithm behaviour changes according to the status of the vehicle. Each state gives different weight to the described sensors, in such a way it is possible to rely more on the sensors that for a certain state are less affected by errors. In order to change status we have defined some thresholds in velocity and acceleration that must be tuned using the data acquired during the race tests. Although this algorithm is in theory really robust due to the big quantity of data that can elaborate, it presents some problems, in particular in the \"braking state\" where it is not fast enough to follow our reference data acquired with the GPS. Possible reasons that we have identified as responsible for this problem are: a non adequate filter of the acceleration or a non proper tuning of the thresholds. Figure 3 - Simulink block diagram of the Savaresi algorithm Figure 4 - Matlab script of the Savaresi algorithm","title":"Savaresi algorithm"},{"location":"fenice-vehicle-model-DMT/Theory/Velocity_Estimation/#comparison","text":"The most relevant parameters influencing the selection of an algorithm with respect to another one are the accuracy of the estimation (which is done comparing the results with the GPS data) and the complexity of the algorithm, which turns into a slow response of the system. Those 2 parameters generally are a trade-off, in fact for better accuracy we need a complex algorithm that requires a higher computational effort and as a consequence in the time needed to perform the calculation. In order to evaluate the performance of the 3 algorithms we can compare their behaviour using the data acquired from the GPS during the tests done with \"ChimeraEvo\". The algorithms will be judged in different types of tests which correspond to different types of manoeuvre executed by the pilot. The step size used in the simulations will be always the same for both the algorithms. Three different tests have been selected in order to highlight the behaviour of the three algorithms and their advantages and disadvantages.","title":"Comparison"},{"location":"fenice-vehicle-model-DMT/Theory/Velocity_Estimation/#straight-line-manoeuvre","text":"As we can see all the three algorithms are quite accurate in this simple manoeuvre, in particular no one has problems in tracking the acceleration phase, which correspond in the pieces of the curve where the velocity increases. Tracking error increases in the breaking phase in particular for the Savaresi algorithm which presents a delay in detecting the breaking phase and a consequent extremely high deceleration in order to compensate for the delay in the detection. On the other hand the Panzani and the raw algorithm follow quite well the GPS data. For this manoeuvre the best tracking is performed by the Panzani Algorithm, but it has also a drawback, it is quite sensitive to the time step used for the simulation. For relatively high time step the response becomes quite noise, instead the Savaresi algorithm and the row algorithm are less sensitive to the increment of the time step but they remain less accurate with respect to the Panzani algorithm.","title":"Straight line manoeuvre"},{"location":"fenice-vehicle-model-DMT/Theory/Velocity_Estimation/#sine-steer-manoeuvre","text":"A sine steer manoeuvre involves a first phase of acceleration until the vehicle hits a target velocity then the pilot has to perform a sinusoidal steering wheel input and then linearly increase the frequency of the sinusoidal wave. The velocity estimated by the three algorithms in this manoeuvre is more noisy with respect to the straight line because of the complexity of the manoeuvre the acquired data from the sensors are more affected by vibrations and other external noise sources. The same considerations done for the previous test are valid for this one where we can highlight the tracking problem of the Savaresi algorithm in the breaking phase which is again clearly visible. We can also notice that the row and Savaresi algorithm make an overestimation of the velocity while the vehicle is in a constant velocity status. Figure 5 - Sine steer manoeuvre","title":"Sine steer manoeuvre"},{"location":"fenice-vehicle-model-DMT/Theory/Velocity_Estimation/#half-skid-pad-manoeuvre","text":"This test consists of following a circular track with a defined radius where the pilot has to accelerate until the vehicle tires slip with respect to ground, then it has to maintain a constant velocity. In this pot we can add to the previous consideration the presence of an instability in the Savaresi algorithm in tracking a sudden variation in acceleration. Figure 6 - Half skip pad manoeuvre","title":"Half skid pad manoeuvre"},{"location":"fenice-vehicle-model-DMT/Theory/Velocity_Estimation/#selection-of-the-most-accurate-algorithm","text":"Considering the performance of the three algorithms, the selected one to be used for the velocity estimation required by both the traction control and the torque vectoring is the Panzani algorithm. All the three approaches have potential but the Panzani is the most stable and creates the lowest tracking error.","title":"Selection of the most accurate algorithm"},{"location":"fenice-vehicle-model-DMT/Theory/Velocity_Estimation/#further-improvements","text":"As mentioned before the main problem in the Savaresi algorithm is related to the breaking status. Actually we are investigating different ways to solve this problem, implementing more sophisticated filters for the input data and trying different configurations for the tuning of the parameters of the algorithms. We are also searching in the literature how similar problems have been solved.","title":"Further improvements"},{"location":"fenice-vehicle-model-DMT/Theory/Velocity_Estimation/#revision-history","text":"V1.0 22/06/2022: Initial release: Matteo Da Re.","title":"Revision History"},{"location":"fenice-vehicle-model-DMT/Theory/Velocity_Estimation/#bibliography","text":"Tanelli M., Savaresi S. M., Cantoni C., 2006, Longitudinal vehicle speed for traction and braking control systems Corno, M., Panzani G., Savaresi S., 2013, Traction-Control-Oriented State Estimation for Motorcycles","title":"Bibliography"},{"location":"handcart-hw/handcart/","text":"Handcart / Charger","title":"Handcart / Charger"},{"location":"handcart-hw/handcart/#handcart-charger","text":"","title":"Handcart / Charger"},{"location":"handcart-sw/main/","text":"Handcart Documentation Index Structure Resources & Useful links Intro The handcart is the device that is responsible of transporting and charging the car's accumulator. It is based on three main components: Brusa NLG513 charger, that is the actual charger Raspberry pi 4 to run the software High Voltage Accumulator The rasp is connected via CAN Bus with the BMS in the accumulator and with the Brusa charger. The software of the handcart is responsible of all the processes to ensure a good and safe charge. Abbreviations BMS, porco, acc -> accumulator HV -> High Voltage rasp -> raspberry FSM -> Finite State Machine TS (on, off) -> Tractive system (HV) (on o off) The old \"carrellino\" I want to remember the old handcart, that did his job during all these years. Software Overview The software is written in python and javascript. It's divided in two parts, respectively frontend and backend. The backend is responsible to manage the charge and to communicate with the devices, and it also hosts a webserver for the frontend. The software can be started trough the main.py python script found in backend/ folder. By default, a service can be found in the raspi, namely handcart-backend.service. In the folder utils/ you can find a shell script to reset the service. Backend The backend is the part of the software that is responsible to manage the charge and to communicate with the devices, it also hosts a webserver to serve pages and data to the frontend. Basically it is a python script that becomes a process, then it splits itself in three threads. Threads The four threads are: The state machine, aka the main thread The flask webserver The CAN read/write process The thread to manage the leds The three threads have an class istance that they can access which is in shared memory, accessed with a lock. Other types of communication are two queues: A queue for can msg send between FSM thread and CAN thread A queue for can msg recv between FSM thread and CAN thread A queue for command send between web server and the FSM Main thread with FSM The FSM is based on multiple states: CHECK: It is a state where the presence of the BMS and the BRUSA are checked, if they are both present it will pass to next state IDLE: Both devices are connected and ready to rock, a precharge command is waited PRECHARGE: Accumulator is asked TS ON, wait until a confirmation is received READY: Accumulator is in TS ON, brusa is ready, waiting for a charge command CHARGE: The charge is enabled C_DONE: The charge is finished ERROR: An error state, the charge (if enabled) is stopped, the BMS is asked to TS OFF, the PON of brusa is set to OFF Note that in each state there's a check over errors from the can, if an error is found, the next state will be ERROR. Both the BRUSA and the BMS messages from the CAN have a timeout, that if reached makes the FSM to go back to CHECK STATE:CHECK The presence of BMS and BRUSA is checked, if both are present, goto IDLE STATE:IDLE Both devices are connected and ready to rock, a precharge command is waited. STATE:PRECHARGE A TS ON can message is sent to BMS HV, which will do the precharge. In this state we will check if the bms will finish the precharge. Once it did so, the FSM will go to READY state. STATE:READY The TS is on, we are waiting to receive the charge command from the webserver. We countinously check the queue for new messages. STATE:CHARGE In this state the charge is enabled, to do this, a variable named \"can_forward_enabled\" is set to True. This variable is shared between the FSM trhead and the CAN thread. In the can thread, a check over can_forward_enabled is made, if it's False it will periodically send an empty CAN message to brusa (this is important to keep the link alive, otherwise the brusa will go in an error state if no msgs receivedin 300ms) If it's True, it will send an enable charge command to brusa with the voltage and current settings. For more info check the brusa CAN messages matrix. STATE:C_DONE The charge is done, TS is still on, waiting for user input. STATE:ERROR Something triggered an error, we have to turn off everithing that could be dangerous. The method \"staccastacca()\" is called. Where a TS_OFF message both for chimera's and fenice's accumulator is sent. The message is sent until a confirmation about the fact that the TS is OFF is received. In the staccastacca method also the PON is disabled The canread object The 'canread' object is an istance of a class that is thought to store all the information of the BMS, BRUSA, CAN and others. It is also used to process all the CAN messages. The CAN thread passes the can messages in the CAN queue and the FSM thread checks for new messages in the queue at each cycle, if so the message is processed in the canread object using a method. The canread object is accessed only by the thread of the FSM, the other threads access a copy of that object that is called shared_data. This is done for safety reason and to assure a fast access without lag to the main thread, as this object contains error state variables. Flask HTTP server This is the server that serve the requests received from the frontend. It uses the shared_data object to retrieve the data from the FSM thread Frontend The handcart's frontend is a webapp based on javascript and html, it fetches the data from the backend by doing RESTFUL requests to the backend. Charts are created using amcharts 4 with Javascript method (NOT the JSON method). To use fetches there are some basic method such as the request-create and the POST method to submit data. I strongly recommend you to use the formListener method that take a form and the partial URL (because we have to send commands only on the /command/ path, so we can avoid things that can't be done). In forms I create some hidden parameters to identify the command we want to send and it have to correspond with the json parameters shown in the documentation describing the json format. include/header.html Is the top-bar that have all status, number of warnings and errors, and actual value for each parameter needed. The error and warning's counter can be clicked to access the respective pages. Every value in the header are calculated by the js/status.js file, which will be loaded on page loading. There's also a big SHUTDOWN button to turn off the charge in every moment, independently whether page you are. index.html This page has six charts: the first on top-left graphically describe the latest voltage values, then you have the charge percentage and the latest current values on the first row. On the second row there are the latest temperature's chart and two charts about cells voltage and temperature that will work only with Fenice (Chimera still doesn't have these values). Data are received by the flask server using a fetch for each chart to fill the previous data (30 zeros to avoid graphical issues) and then another fetch will be called to ask the server the last data, in order to have a live chart (every 2 seconds). error.html and warning.html These two pages just print BMS-HV and Brusa errors and warnings in a table. The createTable method is inside the js/tables.js file and look at the json's parameters to create the table. If you need to print a json with the \"title-parameter\" in one column instead of on a row, follow the method used in brusa-info.html . brusa-info.html In this page are displayed some Brusa's flags in a table made as described above. settings.html Here you can modify some parameters, such as the Cut-Off voltage, the maximum current outlet and there's a button to enable or disable the fastcharge. charts.html This page can actually display \"more pages\": it depends on the parameter passed using the GET method. This parameter is used to set a title in the page and to decide which chart you want to display. At this point it will automatically check which chart-function it has to call and calls also the functions to update the header's values. Those charts won't refresh automatically: you have to refresh the page to see new data, so you can use the zoom (by clicking in the start position and drag until the end position of the zoom). To see all values about a specific chart there is a function called createMultilineChart that will create a chart with many lines as parameters that are in the json (timestamp excluded). Chart functions In addition to chart's creating functions there are some utilities functions in /chart/chartsFun.js : most of them are in this file just to clear the main one and to reuse them if needed, however they contain the more logical part (i.e. how to set the correct color using a percentage or how to set the correct position of each cell value according to the real position - check the image below to understand it better). CSS All styles are in the css/style.css file. Images All used images are in the images/ folder. JavaScript active.js : Contain a little script to check which page is active, in order to highlight it in the left navigation bar. const.js : Contain all constants needed in the whole frontend, to avoid hardcoding. script.js : Contains all other kind of functions; every function has its own parameter's description. status.js : As mentioned before it contains functions to check the devices' status to refresh the top bar. tables.js : As mentioned before it contains all used tables function. Raspberry configuration Follow the guide here Rasp config . The password of the raspberry is \"handcartpi\". In the handcart just one CAN bus is necessary. Hardware Electrical wiring TS Tractive System Wiring The TS wiring is described in this diagram: The junction box The TS cable that goes from the BRUSA to the accumulator has a connector in order of being able to charge both the Chimera's acc and the Fenice one. This is done by using a custom cable for each accumulator. The connector is inside a junction box. This box also have the TSMPs resistors. The shields of the cables from the accumulator are connected to PE (protective earth) coming from the cable of the BRUSA trough a molex connector. All the cables exiting the junction box are restrained using some cable restrains from lapp. The TSMP The TS measurament points are connected to the TS+ and TS- in the junction box, having a proper resistor in series. The handcart wiring & PCB connectors All the Shutdown cables in the wiring have purple color. RGB TSAL (fake) The TSAL is used to get a visual feedback of the state of the handcart during charging. The original fenice's TSAL has been taken and has been equiped with RGB leds, connetting the mosphet gates to some pins in the raspberry, specifically: - RED_LED = GPIO 12 #31 - GREEN_LED = GPIO 13 #33 - BLUE_LED = GPIO 16 #36 Some cables has been routed from the back of the pcb to a weipu 6 pin female cable-to-cable connector. Then, the male connector is connected to the TSAL. The pin assignment is: 1 - GND 2 - 12V 3 - Red signal 4 - Green signal 5 - Blue signal A view of the soldered cables of the fake TSAL and the fan. The shutdown circuit The shutdown circuit is generated from the PSU, it passes trough a fuse, it passes through the mushroom, to a relay which is controlled by the rasp, then TO_CHARGER, which is the interlock of the connector of the brusa, and then FROM_CHARGER to BMS\u2019s SD, then out of the BMS, to the TSMS key, then in to the BMS again to the airs. Note that the PON (Power ON) of the BRUSA is powered from the shutdown circuit, this way, if the shutdown is opened, the BRUSA is instantaneously disabled. Handcart PCB Components list Brusa NLG513 - HV charger Anderson SB 165A-600V - Connector of TS from brusa to accumulator Amphenol AT06-12S - Connector of communication cable to accumulator CGS HSA25 15K G 1731 - TSMP resistors Lapp Oflex FD 90 CV 16mm2 - TS cables TE connector 770680-1 - Connector of brusa communciation Lapp SKINTOP ST-M Cable restrain - Cable restrain for TS cables BRUSA NLG5 Charger deep dive The brusa can be controlled using CAN or can be programmed to be used without the CAN. For our purposes we will control it over CAN BUS. Serial connection To connect with brusa both for debug and/or change the settings we can use the serial interface. To do so, you have to have an USB to serial adapter, connected to the pins of the BRUSA's connector, check the brusa manual. There are specific settings to set up the serial connection, in german they're called anschlusseinstellungen: Baudrate: 19200 Data bits: 8 parity: none stopbits: 1 protocol: Xon/Xoff If you are on windows, let the serial COM settings as default, but edit the putty settings, i got some problems otherwise. Very important : i don't know why, but if you are going to use ChargeStar software you need to change the COM port to COM1, otherwise the brusa will not be recognized by the program. Note that the serial works only if the board on the brusa is fed with 12 volts via the proper pin 2 AUX or with the main power. to use the serial monitor you have to properly connect and setup the serial, then, use putty on windows or minicom on linux to connect to it. You will asked with a pasword, which is \"monitor\" ChargeStar software With the ChargeStar software you can program a charging profile, set various parameters and change some configuration of the brusa, see the brusa's manual for all the infos. Via ChargeStar you can also set the mode to CAN, very useful to control the charge via can. The ChargeStar software will run only on Windows XP or Windows Vista, obviously we'll chose XP, you can run a virtual machine on virtualbox and do the USB-passthrough of the serial to USB adapter. I read that somebody had issues with ChargeStar using the 64 bit version of windows, but for me worked fine. Note that i ran in some problems uploading a custom setting to the brusa: sometimes when the settings are uploaded, the brusa gives an NVSRAM CRC error, the only possible fix is reupload the settings to brusa changing some parameters a bit. I'm still not sure which parameter is causing problems, so change them randomly a bit and it should work after some tries. If you see, some input fields don't accept values with the \".\" not sure why. Connecting by CAN Connecting with CAN allows to monitor the message outputed by the brusa and (if properly configured) to set some parameters for charging. The CAN connection has to end with a 120 Ohm resistor, otherwise the messages will keep bouncing (kinda), trust me, it is necessary. See the full CAN matrix in the manual. By default the CAN is at 500kbps, unless differently specified in config file with ChargeStar. As i saw, brusa send messages just when the PON pin is set to HIGH (>5V). To set and enable the charge via can you have to send periodically a can message named NLG5_CTL see details on the can matrix. Note that the endianess is big (motorola). Setup procedure First, you need to know what you\u2019re doing, you\u2019re going to work with High Voltage both AC and DC, that\u2019s no joke. Finding a good power source Brusa will be absorbing a maximum of 16A on a 230V AC 50Hz outlet, so a maximum of 3.6kW, if you\u2019re using the tripolar connector there shouldn\u2019t be any problem, otherwise if you\u2019re using the tripolar to standard socket adaptor, make sure to check if the line is properly supporting the load. Usually it would just warm up the cables, but if you\u2019re unlucky this could cause a fire, so BE CAREFUL. Note that it is possible to specify to the BRUSA how much current to absorb. Connecting the accumulator Depending on the accumulator (Chimera or Fenice) you have to choose the right cable. Turn off the TSMS key Turn off the PON switch Connect the accumulator and the brusa with the HV connector. With chimera make sure that it makes a good contact, sometimes the interlock will not be closed properly. Connect the two LV connectors to the accumulator, and the other end to the handcart. Connecting brusa to main power Once a good power source has been found, connect the brusa to it. You\u2019ll hear a \u201cclick\u201d from the BRUSA. Charge procedure Make sure that just the people needed are near the handcart, the presence of an ESO would be ideal in a not official environment, and required in a race environment. Turn ONthe TSMS key. From now on, the system could be at >400 DC volt. Start the charging software, and then, start the charge. In case of any problem, push the red shutdown button in the handcart, this will stop the charge and open the AIRs of the accumulator. Backup (Emergency) software Before starting, follow the set up procedure for the handcart. It is necessary to initialize the canbus on the raspberry pi, just execute this script. If you need the handcart working as fast as possible, just download the charge script from github, and execute it on the raspberry pi, you will be guided through the precharge process of the accumulator and the charge settings. !!! Warning : This software is DUMB, if you set a voltage, the brusa will deliver it, be careful!. !!! Warning: at the time of writing (18/09/2021) the script supports just chimera\u2019s accumulator, this can be bypassed by reading the next note. !!! Tip: if you need to bypass the precharge check of the accumulator for any reason, you can set the variable \u201cBYPASS_TS_CHECK\u201d in the script to false, this way the script will not check the presence of the accumulator, and the brusa will work on anything it is attached to. Resources & Useful links Handcart drive folder Frontend REST API Documentation CAN messages reference here you can find BRUSA's CAN messages For pork's can messages search on other E-Agle's repo Fake pointers in python Python threading API Bootstrap dashboard template JS Charts Rasp config Charge state machine of BMS Diagram links Shutdown and TS diagrams 1 2 Decisions and info EV 4.5.10 Tells that \"Every TS connector outside of a housing must include a pilot contact/interlock line which is part of the shutdown circuit. Housings only used to avoid interlocks are prohibited.\" We have the black connector named \"Anderson\" which connects the brusa to the adaptor caple for the different accumulators, we want to put it in a container beacuse of the fact that TSMP and resistor has to be placed somewhere, and we didn't like the idea of putting them directly on the cables or the connector. This way we can leave it without the interlock connected to the shutdown.","title":"Handcart Documentation"},{"location":"handcart-sw/main/#handcart-documentation","text":"","title":"Handcart Documentation"},{"location":"handcart-sw/main/#index","text":"Structure Resources & Useful links","title":"Index"},{"location":"handcart-sw/main/#intro","text":"The handcart is the device that is responsible of transporting and charging the car's accumulator. It is based on three main components: Brusa NLG513 charger, that is the actual charger Raspberry pi 4 to run the software High Voltage Accumulator The rasp is connected via CAN Bus with the BMS in the accumulator and with the Brusa charger. The software of the handcart is responsible of all the processes to ensure a good and safe charge.","title":"Intro"},{"location":"handcart-sw/main/#abbreviations","text":"BMS, porco, acc -> accumulator HV -> High Voltage rasp -> raspberry FSM -> Finite State Machine TS (on, off) -> Tractive system (HV) (on o off)","title":"Abbreviations"},{"location":"handcart-sw/main/#the-old-carrellino","text":"I want to remember the old handcart, that did his job during all these years.","title":"The old \"carrellino\""},{"location":"handcart-sw/main/#software","text":"","title":"Software"},{"location":"handcart-sw/main/#overview","text":"The software is written in python and javascript. It's divided in two parts, respectively frontend and backend. The backend is responsible to manage the charge and to communicate with the devices, and it also hosts a webserver for the frontend. The software can be started trough the main.py python script found in backend/ folder. By default, a service can be found in the raspi, namely handcart-backend.service. In the folder utils/ you can find a shell script to reset the service.","title":"Overview"},{"location":"handcart-sw/main/#backend","text":"The backend is the part of the software that is responsible to manage the charge and to communicate with the devices, it also hosts a webserver to serve pages and data to the frontend. Basically it is a python script that becomes a process, then it splits itself in three threads.","title":"Backend"},{"location":"handcart-sw/main/#threads","text":"The four threads are: The state machine, aka the main thread The flask webserver The CAN read/write process The thread to manage the leds The three threads have an class istance that they can access which is in shared memory, accessed with a lock. Other types of communication are two queues: A queue for can msg send between FSM thread and CAN thread A queue for can msg recv between FSM thread and CAN thread A queue for command send between web server and the FSM","title":"Threads"},{"location":"handcart-sw/main/#main-thread-with-fsm","text":"The FSM is based on multiple states: CHECK: It is a state where the presence of the BMS and the BRUSA are checked, if they are both present it will pass to next state IDLE: Both devices are connected and ready to rock, a precharge command is waited PRECHARGE: Accumulator is asked TS ON, wait until a confirmation is received READY: Accumulator is in TS ON, brusa is ready, waiting for a charge command CHARGE: The charge is enabled C_DONE: The charge is finished ERROR: An error state, the charge (if enabled) is stopped, the BMS is asked to TS OFF, the PON of brusa is set to OFF Note that in each state there's a check over errors from the can, if an error is found, the next state will be ERROR. Both the BRUSA and the BMS messages from the CAN have a timeout, that if reached makes the FSM to go back to CHECK","title":"Main thread with FSM"},{"location":"handcart-sw/main/#statecheck","text":"The presence of BMS and BRUSA is checked, if both are present, goto IDLE","title":"STATE:CHECK"},{"location":"handcart-sw/main/#stateidle","text":"Both devices are connected and ready to rock, a precharge command is waited.","title":"STATE:IDLE"},{"location":"handcart-sw/main/#stateprecharge","text":"A TS ON can message is sent to BMS HV, which will do the precharge. In this state we will check if the bms will finish the precharge. Once it did so, the FSM will go to READY state.","title":"STATE:PRECHARGE"},{"location":"handcart-sw/main/#stateready","text":"The TS is on, we are waiting to receive the charge command from the webserver. We countinously check the queue for new messages.","title":"STATE:READY"},{"location":"handcart-sw/main/#statecharge","text":"In this state the charge is enabled, to do this, a variable named \"can_forward_enabled\" is set to True. This variable is shared between the FSM trhead and the CAN thread. In the can thread, a check over can_forward_enabled is made, if it's False it will periodically send an empty CAN message to brusa (this is important to keep the link alive, otherwise the brusa will go in an error state if no msgs receivedin 300ms) If it's True, it will send an enable charge command to brusa with the voltage and current settings. For more info check the brusa CAN messages matrix.","title":"STATE:CHARGE"},{"location":"handcart-sw/main/#statec_done","text":"The charge is done, TS is still on, waiting for user input.","title":"STATE:C_DONE"},{"location":"handcart-sw/main/#stateerror","text":"Something triggered an error, we have to turn off everithing that could be dangerous. The method \"staccastacca()\" is called. Where a TS_OFF message both for chimera's and fenice's accumulator is sent. The message is sent until a confirmation about the fact that the TS is OFF is received. In the staccastacca method also the PON is disabled","title":"STATE:ERROR"},{"location":"handcart-sw/main/#the-canread-object","text":"The 'canread' object is an istance of a class that is thought to store all the information of the BMS, BRUSA, CAN and others. It is also used to process all the CAN messages. The CAN thread passes the can messages in the CAN queue and the FSM thread checks for new messages in the queue at each cycle, if so the message is processed in the canread object using a method. The canread object is accessed only by the thread of the FSM, the other threads access a copy of that object that is called shared_data. This is done for safety reason and to assure a fast access without lag to the main thread, as this object contains error state variables.","title":"The canread object"},{"location":"handcart-sw/main/#flask-http-server","text":"This is the server that serve the requests received from the frontend. It uses the shared_data object to retrieve the data from the FSM thread","title":"Flask HTTP server"},{"location":"handcart-sw/main/#frontend","text":"The handcart's frontend is a webapp based on javascript and html, it fetches the data from the backend by doing RESTFUL requests to the backend. Charts are created using amcharts 4 with Javascript method (NOT the JSON method). To use fetches there are some basic method such as the request-create and the POST method to submit data. I strongly recommend you to use the formListener method that take a form and the partial URL (because we have to send commands only on the /command/ path, so we can avoid things that can't be done). In forms I create some hidden parameters to identify the command we want to send and it have to correspond with the json parameters shown in the documentation describing the json format.","title":"Frontend"},{"location":"handcart-sw/main/#includeheaderhtml","text":"Is the top-bar that have all status, number of warnings and errors, and actual value for each parameter needed. The error and warning's counter can be clicked to access the respective pages. Every value in the header are calculated by the js/status.js file, which will be loaded on page loading. There's also a big SHUTDOWN button to turn off the charge in every moment, independently whether page you are.","title":"include/header.html"},{"location":"handcart-sw/main/#indexhtml","text":"This page has six charts: the first on top-left graphically describe the latest voltage values, then you have the charge percentage and the latest current values on the first row. On the second row there are the latest temperature's chart and two charts about cells voltage and temperature that will work only with Fenice (Chimera still doesn't have these values). Data are received by the flask server using a fetch for each chart to fill the previous data (30 zeros to avoid graphical issues) and then another fetch will be called to ask the server the last data, in order to have a live chart (every 2 seconds).","title":"index.html"},{"location":"handcart-sw/main/#errorhtml-and-warninghtml","text":"These two pages just print BMS-HV and Brusa errors and warnings in a table. The createTable method is inside the js/tables.js file and look at the json's parameters to create the table. If you need to print a json with the \"title-parameter\" in one column instead of on a row, follow the method used in brusa-info.html .","title":"error.html and warning.html"},{"location":"handcart-sw/main/#brusa-infohtml","text":"In this page are displayed some Brusa's flags in a table made as described above.","title":"brusa-info.html"},{"location":"handcart-sw/main/#settingshtml","text":"Here you can modify some parameters, such as the Cut-Off voltage, the maximum current outlet and there's a button to enable or disable the fastcharge.","title":"settings.html"},{"location":"handcart-sw/main/#chartshtml","text":"This page can actually display \"more pages\": it depends on the parameter passed using the GET method. This parameter is used to set a title in the page and to decide which chart you want to display. At this point it will automatically check which chart-function it has to call and calls also the functions to update the header's values. Those charts won't refresh automatically: you have to refresh the page to see new data, so you can use the zoom (by clicking in the start position and drag until the end position of the zoom). To see all values about a specific chart there is a function called createMultilineChart that will create a chart with many lines as parameters that are in the json (timestamp excluded).","title":"charts.html"},{"location":"handcart-sw/main/#chart-functions","text":"In addition to chart's creating functions there are some utilities functions in /chart/chartsFun.js : most of them are in this file just to clear the main one and to reuse them if needed, however they contain the more logical part (i.e. how to set the correct color using a percentage or how to set the correct position of each cell value according to the real position - check the image below to understand it better).","title":"Chart functions"},{"location":"handcart-sw/main/#css","text":"All styles are in the css/style.css file.","title":"CSS"},{"location":"handcart-sw/main/#images","text":"All used images are in the images/ folder.","title":"Images"},{"location":"handcart-sw/main/#javascript","text":"active.js : Contain a little script to check which page is active, in order to highlight it in the left navigation bar. const.js : Contain all constants needed in the whole frontend, to avoid hardcoding. script.js : Contains all other kind of functions; every function has its own parameter's description. status.js : As mentioned before it contains functions to check the devices' status to refresh the top bar. tables.js : As mentioned before it contains all used tables function.","title":"JavaScript"},{"location":"handcart-sw/main/#raspberry-configuration","text":"Follow the guide here Rasp config . The password of the raspberry is \"handcartpi\". In the handcart just one CAN bus is necessary.","title":"Raspberry configuration"},{"location":"handcart-sw/main/#hardware","text":"","title":"Hardware"},{"location":"handcart-sw/main/#electrical-wiring","text":"","title":"Electrical wiring"},{"location":"handcart-sw/main/#ts-tractive-system-wiring","text":"The TS wiring is described in this diagram:","title":"TS Tractive System Wiring"},{"location":"handcart-sw/main/#the-junction-box","text":"The TS cable that goes from the BRUSA to the accumulator has a connector in order of being able to charge both the Chimera's acc and the Fenice one. This is done by using a custom cable for each accumulator. The connector is inside a junction box. This box also have the TSMPs resistors. The shields of the cables from the accumulator are connected to PE (protective earth) coming from the cable of the BRUSA trough a molex connector. All the cables exiting the junction box are restrained using some cable restrains from lapp.","title":"The junction box"},{"location":"handcart-sw/main/#the-tsmp","text":"The TS measurament points are connected to the TS+ and TS- in the junction box, having a proper resistor in series.","title":"The TSMP"},{"location":"handcart-sw/main/#the-handcart-wiring-pcb-connectors","text":"All the Shutdown cables in the wiring have purple color.","title":"The handcart wiring &amp; PCB connectors"},{"location":"handcart-sw/main/#rgb-tsal-fake","text":"The TSAL is used to get a visual feedback of the state of the handcart during charging. The original fenice's TSAL has been taken and has been equiped with RGB leds, connetting the mosphet gates to some pins in the raspberry, specifically: - RED_LED = GPIO 12 #31 - GREEN_LED = GPIO 13 #33 - BLUE_LED = GPIO 16 #36 Some cables has been routed from the back of the pcb to a weipu 6 pin female cable-to-cable connector. Then, the male connector is connected to the TSAL. The pin assignment is: 1 - GND 2 - 12V 3 - Red signal 4 - Green signal 5 - Blue signal A view of the soldered cables of the fake TSAL and the fan.","title":"RGB TSAL (fake)"},{"location":"handcart-sw/main/#the-shutdown-circuit","text":"The shutdown circuit is generated from the PSU, it passes trough a fuse, it passes through the mushroom, to a relay which is controlled by the rasp, then TO_CHARGER, which is the interlock of the connector of the brusa, and then FROM_CHARGER to BMS\u2019s SD, then out of the BMS, to the TSMS key, then in to the BMS again to the airs. Note that the PON (Power ON) of the BRUSA is powered from the shutdown circuit, this way, if the shutdown is opened, the BRUSA is instantaneously disabled.","title":"The shutdown circuit"},{"location":"handcart-sw/main/#handcart-pcb","text":"","title":"Handcart PCB"},{"location":"handcart-sw/main/#components-list","text":"Brusa NLG513 - HV charger Anderson SB 165A-600V - Connector of TS from brusa to accumulator Amphenol AT06-12S - Connector of communication cable to accumulator CGS HSA25 15K G 1731 - TSMP resistors Lapp Oflex FD 90 CV 16mm2 - TS cables TE connector 770680-1 - Connector of brusa communciation Lapp SKINTOP ST-M Cable restrain - Cable restrain for TS cables","title":"Components list"},{"location":"handcart-sw/main/#brusa-nlg5-charger-deep-dive","text":"The brusa can be controlled using CAN or can be programmed to be used without the CAN. For our purposes we will control it over CAN BUS.","title":"BRUSA NLG5 Charger deep dive"},{"location":"handcart-sw/main/#serial-connection","text":"To connect with brusa both for debug and/or change the settings we can use the serial interface. To do so, you have to have an USB to serial adapter, connected to the pins of the BRUSA's connector, check the brusa manual. There are specific settings to set up the serial connection, in german they're called anschlusseinstellungen: Baudrate: 19200 Data bits: 8 parity: none stopbits: 1 protocol: Xon/Xoff If you are on windows, let the serial COM settings as default, but edit the putty settings, i got some problems otherwise. Very important : i don't know why, but if you are going to use ChargeStar software you need to change the COM port to COM1, otherwise the brusa will not be recognized by the program. Note that the serial works only if the board on the brusa is fed with 12 volts via the proper pin 2 AUX or with the main power. to use the serial monitor you have to properly connect and setup the serial, then, use putty on windows or minicom on linux to connect to it. You will asked with a pasword, which is \"monitor\"","title":"Serial connection"},{"location":"handcart-sw/main/#chargestar-software","text":"With the ChargeStar software you can program a charging profile, set various parameters and change some configuration of the brusa, see the brusa's manual for all the infos. Via ChargeStar you can also set the mode to CAN, very useful to control the charge via can. The ChargeStar software will run only on Windows XP or Windows Vista, obviously we'll chose XP, you can run a virtual machine on virtualbox and do the USB-passthrough of the serial to USB adapter. I read that somebody had issues with ChargeStar using the 64 bit version of windows, but for me worked fine. Note that i ran in some problems uploading a custom setting to the brusa: sometimes when the settings are uploaded, the brusa gives an NVSRAM CRC error, the only possible fix is reupload the settings to brusa changing some parameters a bit. I'm still not sure which parameter is causing problems, so change them randomly a bit and it should work after some tries. If you see, some input fields don't accept values with the \".\" not sure why.","title":"ChargeStar software"},{"location":"handcart-sw/main/#connecting-by-can","text":"Connecting with CAN allows to monitor the message outputed by the brusa and (if properly configured) to set some parameters for charging. The CAN connection has to end with a 120 Ohm resistor, otherwise the messages will keep bouncing (kinda), trust me, it is necessary. See the full CAN matrix in the manual. By default the CAN is at 500kbps, unless differently specified in config file with ChargeStar. As i saw, brusa send messages just when the PON pin is set to HIGH (>5V). To set and enable the charge via can you have to send periodically a can message named NLG5_CTL see details on the can matrix. Note that the endianess is big (motorola).","title":"Connecting by CAN"},{"location":"handcart-sw/main/#setup-procedure","text":"First, you need to know what you\u2019re doing, you\u2019re going to work with High Voltage both AC and DC, that\u2019s no joke.","title":"Setup procedure"},{"location":"handcart-sw/main/#finding-a-good-power-source","text":"Brusa will be absorbing a maximum of 16A on a 230V AC 50Hz outlet, so a maximum of 3.6kW, if you\u2019re using the tripolar connector there shouldn\u2019t be any problem, otherwise if you\u2019re using the tripolar to standard socket adaptor, make sure to check if the line is properly supporting the load. Usually it would just warm up the cables, but if you\u2019re unlucky this could cause a fire, so BE CAREFUL. Note that it is possible to specify to the BRUSA how much current to absorb.","title":"Finding a good power source"},{"location":"handcart-sw/main/#connecting-the-accumulator","text":"Depending on the accumulator (Chimera or Fenice) you have to choose the right cable. Turn off the TSMS key Turn off the PON switch Connect the accumulator and the brusa with the HV connector. With chimera make sure that it makes a good contact, sometimes the interlock will not be closed properly. Connect the two LV connectors to the accumulator, and the other end to the handcart.","title":"Connecting the accumulator"},{"location":"handcart-sw/main/#connecting-brusa-to-main-power","text":"Once a good power source has been found, connect the brusa to it. You\u2019ll hear a \u201cclick\u201d from the BRUSA.","title":"Connecting brusa to main power"},{"location":"handcart-sw/main/#charge-procedure","text":"Make sure that just the people needed are near the handcart, the presence of an ESO would be ideal in a not official environment, and required in a race environment. Turn ONthe TSMS key. From now on, the system could be at >400 DC volt. Start the charging software, and then, start the charge. In case of any problem, push the red shutdown button in the handcart, this will stop the charge and open the AIRs of the accumulator.","title":"Charge procedure"},{"location":"handcart-sw/main/#backup-emergency-software","text":"Before starting, follow the set up procedure for the handcart. It is necessary to initialize the canbus on the raspberry pi, just execute this script. If you need the handcart working as fast as possible, just download the charge script from github, and execute it on the raspberry pi, you will be guided through the precharge process of the accumulator and the charge settings. !!! Warning : This software is DUMB, if you set a voltage, the brusa will deliver it, be careful!. !!! Warning: at the time of writing (18/09/2021) the script supports just chimera\u2019s accumulator, this can be bypassed by reading the next note. !!! Tip: if you need to bypass the precharge check of the accumulator for any reason, you can set the variable \u201cBYPASS_TS_CHECK\u201d in the script to false, this way the script will not check the presence of the accumulator, and the brusa will work on anything it is attached to.","title":"Backup (Emergency) software"},{"location":"handcart-sw/main/#resources-useful-links","text":"Handcart drive folder Frontend REST API Documentation CAN messages reference here you can find BRUSA's CAN messages For pork's can messages search on other E-Agle's repo Fake pointers in python Python threading API Bootstrap dashboard template JS Charts Rasp config Charge state machine of BMS","title":"Resources &amp; Useful links"},{"location":"handcart-sw/main/#diagram-links","text":"Shutdown and TS diagrams 1 2","title":"Diagram links"},{"location":"handcart-sw/main/#decisions-and-info","text":"EV 4.5.10 Tells that \"Every TS connector outside of a housing must include a pilot contact/interlock line which is part of the shutdown circuit. Housings only used to avoid interlocks are prohibited.\" We have the black connector named \"Anderson\" which connects the brusa to the adaptor caple for the different accumulators, we want to put it in a container beacuse of the fact that TSMP and resistor has to be placed somewhere, and we didn't like the idea of putting them directly on the cables or the connector. This way we can leave it without the interlock connected to the shutdown.","title":"Decisions and info"},{"location":"hw-fenice-ecu/DAS_ECU/","text":"ECU hardware The ECU is the main brain of the vehicle and have to perform the following tasks: Host the vehicle state machine Gather all the sensor informations around the car Compute the actuations on the motors and possible future expansions To do so the workload is split onto two processors: MCU manages the vehicle fsm connected to the 2 can buses present in the car reads the two APPSs reads the brake pressure sensors actuates the brakelight sensors pausabilities shutdown connection actuates the buzzer sound steering position wheel encoders IMU relays necessary sensor informations to the SBC performs the final checks before sending actuations SBC performs the heavier calculations for the actuations, motors and servos connected to the primary can bus to be able to bypass the MCU Connectors Below the quick reference of all connectors signals. The SBC connector pinout here follows the raspberry GPIO40 numbers so it has to be seen from the bottom of the ECU board with PIN1 the lower left in the picture above. Comments: - 3V3 is present on the pin only with the corresponding jumper closed, usually it is not - 5V is present on the pin only with the corresponding jumper closed, usually it is closed - SPI1 connects the SBC to the CAN module - SPI connects the SBC to the MCU, the SBC is the master due to Raspberry limitations - UART signals as outputted from the SBC 1 3V3* 5V** 2 3 NC 5V** 4 5 NC GND 6 7 NC RASP_TX 8 9 NC RASP_RX 10 11 RASP_RTS NC 12 13 NC GND 14 15 NC NC 16 17 NC NC 18 19 RASP_SPI_MOSI GND 20 21 RASP_SPI_MISO ~INT 22 23 RASP_SPI_CLK RASP_SPI_CS 24 25 GND RASP_CAN_CS 26 27 NC NC 28 29 CANRX_NVIDIA GND 30 31 CANTX_NVIDIA NC 32 33 NC GND 34 35 RASP_SPI1_MISO RASP_CTS 36 37 NC RASP_SPI1_MOSI 38 39 GND RASP_SPI1_CLK 40 Power Power (nominal 12V) enters the board from the POWER connector and powers: DCDC module Analog section linear regulator Brakelight Buzzer SDC relay The 5V output of the DCDC module powers: - SBC - Wheels encoders - Steering encoder - CAN transceiver outputs The 5V output of the analog section's linear regulator powers only the analog sensors. The 3V3 output of the DCDC module powers the rest. MCU configuration The MCU STM32F446RET6 has the following solution found given the requirements: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART2 General timing TIM1, Clock Source is internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 2 CAN full featured busses CAN1,CAN2 SBC communication, UART with full hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI1, hardware NSS input DMA to map the MCU RAM to the SPI master Steering position encoder SPI3 receive only master EEPROM/SDCARD SPI SPI2 IMU: SPI2 3 PWM channels for brakelight TIM3, Clock Source is internal clock 4 ADC channels, 2 brakes and 2 accelerators ADC1, 8kHz single channel sampling Pitot tube pressure reading ADC1/2 CRC module Buzzer PWM PWM channel on TIM1 IMU Not present at the time of writing. The IMU used is the Bosch BMI088 accelerometer and gyroscope 6-axis unit. Set the unused IMU pins as outputs to avoid leaving them floating. Interrupts INT1 new accelerometer data is setted as output of the IMU. INT3 new gyroscope data is setted as output of the IMU. Analog section See issue #1 The analog sensors have an indipendant linear supply to lower noise of the main switching DCDC. The code reading the APPS must follow EV 2.3,. As per T 11.8: - the analog sensors are offsetted on the pedal - the incoming signal difference is compared to detect implausability The ACC_S1 is the higher signal, ACC_S2 is the lower signal. A single pole low pass RC filter at a frequency of 16kHz is applied so that the signals can be sampled with low enough aliases up to 8kHz and further downsampled to the required frequency for the controls via digital filters after the ADC in the MCU. The the 4 signals are lowered from 0V-5V to 0-3.3V with a transfer function of G=18/(10+18)~=0.6428 The supply of the differential pressure sensor can be selected with jumper JP5. Brakelight The brakelight receives the 12V supply and 3 channels which are pulled low to turn on that channel, just like a common led light strip. In fact a 12V LED light strip can be attached to that connector and colors can be set by the ecu. The 3 lines coming from the MCU can be used as follows, granted compliance with the rules: - On CH[1,2,3] dutycycle equal and proportional to the brake pressure - On CH1 blinking while regen (T*w < 0) MCU to Raspberry The MCU is connected to a Raspberry GPIO40 interface of the SBC with: UART bidirectional hardware flow control interrupts between the devices can be generated on the RTS CTS line if configured accordingly SPI The SBC is the master of the bus The MCU is read using DMA on the internal memory a portion of the MCU RAM is memory mapped to the address space of the SBC Steering wheel encoder The MAX490E transceiver has one channel balanced to unbalanced and one channel unbalanced to balanced and converts the single ended DATA and CLK signals from the MCU to the balanced equivalents. The encoder on the wheel is then read by the MCU using the SPI master receive only mode with no chip select. The sensor sends 12 bits after 1 dummy bit. So 16bits can be read through and with bitwise magic the 12 needed bits are gathered. It's important to have the bit timings consistent, the encoder is not a simple shift register, an inconsistent bit timing could reset the encoder and throw off the communication. The filtering is the line termination as recommended by the encoder datasheet. Wheel encoders The UA9637A transceiver has two channels balanced to unbalanced and converts the balanced signals of the encoders to the unbalanced needed by the MCU. The wheel encoders (Left and Rigth) are read using TIM2 and TIM5 respectively, which are 32bit, in 'encoder mode' and thus the code can just read and reset the internal counter which increments and decrements with the wheel movement. The filtering is the line termination as recommended by the encoder datasheet. Raspberry GPIO It has been designed for placing a normal Raspberry PI4 but due to GPIO cross compatibility other such SBC can be used such as Nvidia Nano. The SBC can be powered by the ECU 5V line if below 2.5A. A Raspberry is already on the limit. When powering the SBC from outside open the power jumpers on the ECU. When using the Raspberry 4 SBC direct CAN access to the primary CAN can be added by populating the CAN ic in the image below as well as the corresponding CAN transceiver. Instead some more capable SBCs (cough cough) such as the Nvidia nano already have the CAN module inside and directly outputs the CAN RXTX signals. In this case, if placed on pins 29 and 31 respectively only the transceiver is needed. Buzzer The buzzer meant to be used is 12V, active. Meaning it contains its own oscillator thus the MCU signal should be just ON or OFF. However the pin is connected to a timer channel so it could be PWMed when using a passive buzzer or a speaker but in this case other precautions should be taken, in particular the slow switching times, high PWM frequencies and low resistance speakers could fry the transistor. When using an active buzzer don't use PWM!","title":"ECU hardware"},{"location":"hw-fenice-ecu/DAS_ECU/#ecu-hardware","text":"The ECU is the main brain of the vehicle and have to perform the following tasks: Host the vehicle state machine Gather all the sensor informations around the car Compute the actuations on the motors and possible future expansions To do so the workload is split onto two processors: MCU manages the vehicle fsm connected to the 2 can buses present in the car reads the two APPSs reads the brake pressure sensors actuates the brakelight sensors pausabilities shutdown connection actuates the buzzer sound steering position wheel encoders IMU relays necessary sensor informations to the SBC performs the final checks before sending actuations SBC performs the heavier calculations for the actuations, motors and servos connected to the primary can bus to be able to bypass the MCU","title":"ECU hardware"},{"location":"hw-fenice-ecu/DAS_ECU/#connectors","text":"Below the quick reference of all connectors signals. The SBC connector pinout here follows the raspberry GPIO40 numbers so it has to be seen from the bottom of the ECU board with PIN1 the lower left in the picture above. Comments: - 3V3 is present on the pin only with the corresponding jumper closed, usually it is not - 5V is present on the pin only with the corresponding jumper closed, usually it is closed - SPI1 connects the SBC to the CAN module - SPI connects the SBC to the MCU, the SBC is the master due to Raspberry limitations - UART signals as outputted from the SBC 1 3V3* 5V** 2 3 NC 5V** 4 5 NC GND 6 7 NC RASP_TX 8 9 NC RASP_RX 10 11 RASP_RTS NC 12 13 NC GND 14 15 NC NC 16 17 NC NC 18 19 RASP_SPI_MOSI GND 20 21 RASP_SPI_MISO ~INT 22 23 RASP_SPI_CLK RASP_SPI_CS 24 25 GND RASP_CAN_CS 26 27 NC NC 28 29 CANRX_NVIDIA GND 30 31 CANTX_NVIDIA NC 32 33 NC GND 34 35 RASP_SPI1_MISO RASP_CTS 36 37 NC RASP_SPI1_MOSI 38 39 GND RASP_SPI1_CLK 40","title":"Connectors"},{"location":"hw-fenice-ecu/DAS_ECU/#power","text":"Power (nominal 12V) enters the board from the POWER connector and powers: DCDC module Analog section linear regulator Brakelight Buzzer SDC relay The 5V output of the DCDC module powers: - SBC - Wheels encoders - Steering encoder - CAN transceiver outputs The 5V output of the analog section's linear regulator powers only the analog sensors. The 3V3 output of the DCDC module powers the rest.","title":"Power"},{"location":"hw-fenice-ecu/DAS_ECU/#mcu-configuration","text":"The MCU STM32F446RET6 has the following solution found given the requirements: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART2 General timing TIM1, Clock Source is internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 2 CAN full featured busses CAN1,CAN2 SBC communication, UART with full hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI1, hardware NSS input DMA to map the MCU RAM to the SPI master Steering position encoder SPI3 receive only master EEPROM/SDCARD SPI SPI2 IMU: SPI2 3 PWM channels for brakelight TIM3, Clock Source is internal clock 4 ADC channels, 2 brakes and 2 accelerators ADC1, 8kHz single channel sampling Pitot tube pressure reading ADC1/2 CRC module Buzzer PWM PWM channel on TIM1","title":"MCU configuration"},{"location":"hw-fenice-ecu/DAS_ECU/#imu","text":"Not present at the time of writing. The IMU used is the Bosch BMI088 accelerometer and gyroscope 6-axis unit. Set the unused IMU pins as outputs to avoid leaving them floating.","title":"IMU"},{"location":"hw-fenice-ecu/DAS_ECU/#interrupts","text":"INT1 new accelerometer data is setted as output of the IMU. INT3 new gyroscope data is setted as output of the IMU.","title":"Interrupts"},{"location":"hw-fenice-ecu/DAS_ECU/#analog-section","text":"See issue #1 The analog sensors have an indipendant linear supply to lower noise of the main switching DCDC. The code reading the APPS must follow EV 2.3,. As per T 11.8: - the analog sensors are offsetted on the pedal - the incoming signal difference is compared to detect implausability The ACC_S1 is the higher signal, ACC_S2 is the lower signal. A single pole low pass RC filter at a frequency of 16kHz is applied so that the signals can be sampled with low enough aliases up to 8kHz and further downsampled to the required frequency for the controls via digital filters after the ADC in the MCU. The the 4 signals are lowered from 0V-5V to 0-3.3V with a transfer function of G=18/(10+18)~=0.6428 The supply of the differential pressure sensor can be selected with jumper JP5.","title":"Analog section"},{"location":"hw-fenice-ecu/DAS_ECU/#brakelight","text":"The brakelight receives the 12V supply and 3 channels which are pulled low to turn on that channel, just like a common led light strip. In fact a 12V LED light strip can be attached to that connector and colors can be set by the ecu. The 3 lines coming from the MCU can be used as follows, granted compliance with the rules: - On CH[1,2,3] dutycycle equal and proportional to the brake pressure - On CH1 blinking while regen (T*w < 0)","title":"Brakelight"},{"location":"hw-fenice-ecu/DAS_ECU/#mcu-to-raspberry","text":"The MCU is connected to a Raspberry GPIO40 interface of the SBC with: UART bidirectional hardware flow control interrupts between the devices can be generated on the RTS CTS line if configured accordingly SPI The SBC is the master of the bus The MCU is read using DMA on the internal memory a portion of the MCU RAM is memory mapped to the address space of the SBC","title":"MCU to Raspberry"},{"location":"hw-fenice-ecu/DAS_ECU/#steering-wheel-encoder","text":"The MAX490E transceiver has one channel balanced to unbalanced and one channel unbalanced to balanced and converts the single ended DATA and CLK signals from the MCU to the balanced equivalents. The encoder on the wheel is then read by the MCU using the SPI master receive only mode with no chip select. The sensor sends 12 bits after 1 dummy bit. So 16bits can be read through and with bitwise magic the 12 needed bits are gathered. It's important to have the bit timings consistent, the encoder is not a simple shift register, an inconsistent bit timing could reset the encoder and throw off the communication. The filtering is the line termination as recommended by the encoder datasheet.","title":"Steering wheel encoder"},{"location":"hw-fenice-ecu/DAS_ECU/#wheel-encoders","text":"The UA9637A transceiver has two channels balanced to unbalanced and converts the balanced signals of the encoders to the unbalanced needed by the MCU. The wheel encoders (Left and Rigth) are read using TIM2 and TIM5 respectively, which are 32bit, in 'encoder mode' and thus the code can just read and reset the internal counter which increments and decrements with the wheel movement. The filtering is the line termination as recommended by the encoder datasheet.","title":"Wheel encoders"},{"location":"hw-fenice-ecu/DAS_ECU/#raspberry-gpio","text":"It has been designed for placing a normal Raspberry PI4 but due to GPIO cross compatibility other such SBC can be used such as Nvidia Nano. The SBC can be powered by the ECU 5V line if below 2.5A. A Raspberry is already on the limit. When powering the SBC from outside open the power jumpers on the ECU. When using the Raspberry 4 SBC direct CAN access to the primary CAN can be added by populating the CAN ic in the image below as well as the corresponding CAN transceiver. Instead some more capable SBCs (cough cough) such as the Nvidia nano already have the CAN module inside and directly outputs the CAN RXTX signals. In this case, if placed on pins 29 and 31 respectively only the transceiver is needed.","title":"Raspberry GPIO"},{"location":"hw-fenice-ecu/DAS_ECU/#buzzer","text":"The buzzer meant to be used is 12V, active. Meaning it contains its own oscillator thus the MCU signal should be just ON or OFF. However the pin is connected to a timer channel so it could be PWMed when using a passive buzzer or a speaker but in this case other precautions should be taken, in particular the slow switching times, high PWM frequencies and low resistance speakers could fry the transistor. When using an active buzzer don't use PWM!","title":"Buzzer"},{"location":"hw-fenice-evo-ecu/DAS_ECU/","text":"DAS+ECU MCU configuration The MCU STM32F765VGT6 has the following design requirements and solutions found: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART3 (same as on nucleo devkit) General timing TIM1 on internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 4 ADC channels, 2 brakes and 2 accelerators ADC2, 8kHz single channel sampling 3 PWM channels for brakelight TIM3 2 CAN full featured busses CAN1,CAN3 SBC communication, UART with hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI2, hardware NSS input DMA to map the MCU RAM to the SPI master EEPROM/SDCARD SPI SPI3 Steering position encoder SPI4 receive only master CRC module Buzzer PWM PWM channel on TIM1 The MCU STM32F446RET6 has the following design requirements and solutions found: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART2 General timing TIM1, Clock Source is internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 2 CAN full featured busses CAN1,CAN2 SBC communication, UART with full hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI1, hardware NSS input DMA to map the MCU RAM to the SPI master Steering position encoder SPI3 receive only master EEPROM/SDCARD SPI SPI2 IMU: SPI2 3 PWM channels for brakelight TIM3, Clock Source is internal clock 4 ADC channels, 2 brakes and 2 accelerators ADC1, 8kHz single channel sampling Pitot tube pressure reading ADC1/2 CRC module Buzzer PWM PWM channel on TIM1 IMU The IMU used is the Bosch BMI088 accelerometer and gyroscope 6-axis unit. Set the unused pin as outputs to avoid them floating. Interrupts INT1 new accelerometer data is setted as output of the IMU. INT3 new gyroscope data is setted as output of the IMU. Accelerator The code reading the accelerator must follow EV 2.3,. As per T 11.8: - the analog sensors are offsetted on the pedal - the incoming signal difference is compared to detect implausability The ACC_S1 is the higher signal, ACC_S2 is the lower signal. A single pole low pass RC filter at a frequency of 16kHz is applied so that the signal can be sampled with low enough aliases up to 8kHz and further downsampled to the required frequency for the controls via digital filters after the ADC in the MCU. Brake Pressure Brakelight The brakelight has 3 lines coming from the MCU and they are intended to be used as follows if in compliance with the rules: - On CH[1,2,3] fixed proportionally to the brake pressure - On CH1 blinking while regen MCU to Raspberry The MCU is connected to a Raspberry 40 pin GPIO interface on: UART bidirectional hardware flow control interrupts between the devices can be generated on the RTS CTS line if configured accordingly SPI The Raspberry is the master of the bus The MCU is read using DMA on the internal memory Steering wheel encoder The encoders on the wheel is read by the MCU using the SPI master receive only mode with no chip select. Wheel encoders The wheel ancoders (Left and Rigth) are read using TIM2 and TIM5 respectively in 'encoder mode' and thus the code can just read and reset the internal counter which increments and decrements with the wheel movement. Raspberry GPIO It has been designed for placing a normal Raspberry PI4 but due to GPIO cross compatibility other such SBC can be used. One option is the Nvidia Xavier which on the GPIOs also has CANRX/TX pins which have been connected to a transceiver to the CAN1 of the car.# DAS+ECU MCU configuration The MCU STM32F765VGT6 has the following design requirements and solutions found: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART3 (same as on nucleo devkit) General timing TIM1 on internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 4 ADC channels, 2 brakes and 2 accelerators ADC2, 8kHz single channel sampling 3 PWM channels for brakelight TIM3 2 CAN full featured busses CAN1,CAN3 SBC communication, UART with hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI2, hardware NSS input DMA to map the MCU RAM to the SPI master EEPROM/SDCARD SPI SPI3 Steering position encoder SPI4 receive only master CRC module Buzzer PWM PWM channel on TIM1 The MCU STM32F446RET6 has the following design requirements and solutions found: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART2 General timing TIM1, Clock Source is internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 2 CAN full featured busses CAN1,CAN2 SBC communication, UART with full hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI1, hardware NSS input DMA to map the MCU RAM to the SPI master Steering position encoder SPI3 receive only master EEPROM/SDCARD SPI SPI2 3 PWM channels for brakelight TIM3, Clock Source is internal clock 4 ADC channels, 2 brakes and 2 accelerators AD1, 8kHz single channel sampling CRC module Buzzer PWM PWM channel on TIM1 Accelerator The code reading the accelerator must follow EV 2.3,. As per T 11.8: the analog sensors are offsetted on the pedal the incoming signal difference is compared to detect implausability The ACC_S1 is the higher signal, ACC_S2 is the lower signal. A single pole low pass RC filter at a frequency of 16kHz is applied so that the signal can be sampled with low enough aliases up to 8kHz and further downsampled to the required frequency for the controls via digital filters after the ADC in the MCU. Brake Pressure Brakelight The brakelight has 3 lines coming from the MCU and they are intended to be used as follows if in compliance with the rules: On CH[1,2,3] fixed proportionally to the brake pressure On CH1 blinking while regen MCU to Raspberry The MCU is connected to a Raspberry 40 pin GPIO interface on: UART bidirectional hardware flow control interrupts between the devices can be generated on the RTS CTS line if configured accordingly SPI The Raspberry is the master of the bus The MCU is read using DMA on the internal memory Steering wheel encoder The encoders on the wheel is read by the MCU using the SPI master receive only mode with no chip select. Wheel encoders The wheel ancoders (Left and Rigth) are read using TIM2 and TIM5 respectively in 'encoder mode' and thus the code can just read and reset the internal counter which increments and decrements with the wheel movement. Raspberry GPIO It has been designed for placing a normal Raspberry PI4 but due to GPIO cross compatibility other such SBC can be used. One option is the Nvidia Xavier which on the GPIOs also has CANRX/TX pins which have been connected to a transceiver to the CAN1 of the car.","title":"DAS+ECU"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#dasecu","text":"","title":"DAS+ECU"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#mcu-configuration","text":"The MCU STM32F765VGT6 has the following design requirements and solutions found: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART3 (same as on nucleo devkit) General timing TIM1 on internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 4 ADC channels, 2 brakes and 2 accelerators ADC2, 8kHz single channel sampling 3 PWM channels for brakelight TIM3 2 CAN full featured busses CAN1,CAN3 SBC communication, UART with hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI2, hardware NSS input DMA to map the MCU RAM to the SPI master EEPROM/SDCARD SPI SPI3 Steering position encoder SPI4 receive only master CRC module Buzzer PWM PWM channel on TIM1 The MCU STM32F446RET6 has the following design requirements and solutions found: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART2 General timing TIM1, Clock Source is internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 2 CAN full featured busses CAN1,CAN2 SBC communication, UART with full hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI1, hardware NSS input DMA to map the MCU RAM to the SPI master Steering position encoder SPI3 receive only master EEPROM/SDCARD SPI SPI2 IMU: SPI2 3 PWM channels for brakelight TIM3, Clock Source is internal clock 4 ADC channels, 2 brakes and 2 accelerators ADC1, 8kHz single channel sampling Pitot tube pressure reading ADC1/2 CRC module Buzzer PWM PWM channel on TIM1","title":"MCU configuration"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#imu","text":"The IMU used is the Bosch BMI088 accelerometer and gyroscope 6-axis unit. Set the unused pin as outputs to avoid them floating.","title":"IMU"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#interrupts","text":"INT1 new accelerometer data is setted as output of the IMU. INT3 new gyroscope data is setted as output of the IMU.","title":"Interrupts"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#accelerator","text":"The code reading the accelerator must follow EV 2.3,. As per T 11.8: - the analog sensors are offsetted on the pedal - the incoming signal difference is compared to detect implausability The ACC_S1 is the higher signal, ACC_S2 is the lower signal. A single pole low pass RC filter at a frequency of 16kHz is applied so that the signal can be sampled with low enough aliases up to 8kHz and further downsampled to the required frequency for the controls via digital filters after the ADC in the MCU.","title":"Accelerator"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#brake-pressure","text":"","title":"Brake Pressure"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#brakelight","text":"The brakelight has 3 lines coming from the MCU and they are intended to be used as follows if in compliance with the rules: - On CH[1,2,3] fixed proportionally to the brake pressure - On CH1 blinking while regen","title":"Brakelight"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#mcu-to-raspberry","text":"The MCU is connected to a Raspberry 40 pin GPIO interface on: UART bidirectional hardware flow control interrupts between the devices can be generated on the RTS CTS line if configured accordingly SPI The Raspberry is the master of the bus The MCU is read using DMA on the internal memory","title":"MCU to Raspberry"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#steering-wheel-encoder","text":"The encoders on the wheel is read by the MCU using the SPI master receive only mode with no chip select.","title":"Steering wheel encoder"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#wheel-encoders","text":"The wheel ancoders (Left and Rigth) are read using TIM2 and TIM5 respectively in 'encoder mode' and thus the code can just read and reset the internal counter which increments and decrements with the wheel movement.","title":"Wheel encoders"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#raspberry-gpio","text":"It has been designed for placing a normal Raspberry PI4 but due to GPIO cross compatibility other such SBC can be used. One option is the Nvidia Xavier which on the GPIOs also has CANRX/TX pins which have been connected to a transceiver to the CAN1 of the car.# DAS+ECU","title":"Raspberry GPIO"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#mcu-configuration_1","text":"The MCU STM32F765VGT6 has the following design requirements and solutions found: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART3 (same as on nucleo devkit) General timing TIM1 on internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 4 ADC channels, 2 brakes and 2 accelerators ADC2, 8kHz single channel sampling 3 PWM channels for brakelight TIM3 2 CAN full featured busses CAN1,CAN3 SBC communication, UART with hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI2, hardware NSS input DMA to map the MCU RAM to the SPI master EEPROM/SDCARD SPI SPI3 Steering position encoder SPI4 receive only master CRC module Buzzer PWM PWM channel on TIM1 The MCU STM32F446RET6 has the following design requirements and solutions found: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART2 General timing TIM1, Clock Source is internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 2 CAN full featured busses CAN1,CAN2 SBC communication, UART with full hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI1, hardware NSS input DMA to map the MCU RAM to the SPI master Steering position encoder SPI3 receive only master EEPROM/SDCARD SPI SPI2 3 PWM channels for brakelight TIM3, Clock Source is internal clock 4 ADC channels, 2 brakes and 2 accelerators AD1, 8kHz single channel sampling CRC module Buzzer PWM PWM channel on TIM1","title":"MCU configuration"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#accelerator_1","text":"The code reading the accelerator must follow EV 2.3,. As per T 11.8: the analog sensors are offsetted on the pedal the incoming signal difference is compared to detect implausability The ACC_S1 is the higher signal, ACC_S2 is the lower signal. A single pole low pass RC filter at a frequency of 16kHz is applied so that the signal can be sampled with low enough aliases up to 8kHz and further downsampled to the required frequency for the controls via digital filters after the ADC in the MCU.","title":"Accelerator"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#brake-pressure_1","text":"","title":"Brake Pressure"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#brakelight_1","text":"The brakelight has 3 lines coming from the MCU and they are intended to be used as follows if in compliance with the rules: On CH[1,2,3] fixed proportionally to the brake pressure On CH1 blinking while regen","title":"Brakelight"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#mcu-to-raspberry_1","text":"The MCU is connected to a Raspberry 40 pin GPIO interface on: UART bidirectional hardware flow control interrupts between the devices can be generated on the RTS CTS line if configured accordingly SPI The Raspberry is the master of the bus The MCU is read using DMA on the internal memory","title":"MCU to Raspberry"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#steering-wheel-encoder_1","text":"The encoders on the wheel is read by the MCU using the SPI master receive only mode with no chip select.","title":"Steering wheel encoder"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#wheel-encoders_1","text":"The wheel ancoders (Left and Rigth) are read using TIM2 and TIM5 respectively in 'encoder mode' and thus the code can just read and reset the internal counter which increments and decrements with the wheel movement.","title":"Wheel encoders"},{"location":"hw-fenice-evo-ecu/DAS_ECU/#raspberry-gpio_1","text":"It has been designed for placing a normal Raspberry PI4 but due to GPIO cross compatibility other such SBC can be used. One option is the Nvidia Xavier which on the GPIOs also has CANRX/TX pins which have been connected to a transceiver to the CAN1 of the car.","title":"Raspberry GPIO"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/","text":"ECU Documentation Table of contents Introduction DCDC converter Debug Brakelight Shutdown Raspberry brain Encoders Analog sensors IMU Introduction The ECU (Electronic Control Unit) is a PCB composed by several components and is subdivided in some branches, which are: - CAN power connectors - DCDC converter - Debug - Brakelight - Shutdown - Raspberry brain - Encoders - Analog sensors - IMU. Analog sensors Brake and accelerator sensors Analog sensors have as main task to receive a variable tension (direct proportional to the travel) from the potentiometers placed on the pedals and transmit it to the Raspberry microcontroller. The signal, before the transmission, is filtered at a frequency of 100 kHz by low pass filters. LPF are realized through op-amp with a power supply of 12 V Pitot tube In this section, we can also find an integrated silicon pressure sensor, which uses a pitot tube to gain information about the aerodynamics of the car, and can be driven by two clean signals of 5 V or 3.3 V. We can choose the signals through a jumper. Power supply The power supply for the sensors is realized through a voltage regulator that converts 28 V to the 5 V needed by the sensors. Encoders The car is equipped with encoders to acquire useful data that concern the car performances. They are placed on the steering wheel and on the fronts wheels and communicate with the Raspberry through transceivers, which take as input differential signals. The input signals pass through a terminating resistor and a capacitor. The addition of the capacitor mitigates the power dissipation problems of other parallel termination schemes, blocks low-frequency noise, and minimizes overshoot and undershoot (source: https://resources.pcb.cadence.com/blog/termination-resistors-in-pcb-design). IMU The IMU is the inertial measurement unit (IMU) for the detection of movements and rotations in 6 degrees of freedom (6DoF). The BMI068 combines the functionality of two inertial sensors in one device: an advanced triaxial 16-bit gyroscope and a versatile, leading-edge triaxial 16-bit accelerometer. Raspberry brain Microcontrollers The section where decisions are taken is formed by the Raspberry microcontroller and STM32F446RETx. The second micro acquires informations about the vehicle and pedals status from all the sensors and encoders placed on the cars. The first one, instead, performs decision making. The two controllers communicates through the microchip MCP2515-xSO, which provides an interface between the CAN protocol, that transports the sensors' data, and the SPI, which sends the data through a BUS to the Raspberry. Both of them have a quartz oscillator connected to two parallel capacitors, as shown in the application notes of the device. Moreover, there are some CAN tranceivers to perform a direct communication between CAN protocol and Raspberry on two channels CAN1 and CAN2. They are preceded by a resistor of 33 \u03a9 to reduce disturbances at high frequencies. Buzzer In this section we can also find the buzzer, the device that products an acoustic to signal that the car is ready-to-drive (A5.6.3). Ferrite bead BLM18AG221SZ1D A ferrite bead is a type of choke that suppresses high-frequency electronic noise in electronic circuits. Ferrite beads employ high-frequency current dissipation in a ferrite ceramic to build high-frequency noise suppression devices. EEPROM The STM32F446RETx has also a pin for a memory. The chosen one is a M95256-WMN6P EEPROM memory, which can store and override input values through two different transistors that perform holding and writing. Brakelight The breaklight has 3 channel to communicate with the STM32F446RETx. The micro can provide the input (High) to close the circuit and activate the LEDS. Shutdown The shutdown circuit is composed by a relay and a transistor, that is usually in saturation zone. When the Raspberry sends a low signal, the transistor opens the circuit and the current goes to 0. DCDC converter The DCDC converter of the PCB converts the 12 V in 5 and 3.3 V.","title":"ECU Documentation"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#ecu-documentation","text":"","title":"ECU Documentation"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#table-of-contents","text":"Introduction DCDC converter Debug Brakelight Shutdown Raspberry brain Encoders Analog sensors IMU","title":"Table of contents"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#introduction","text":"The ECU (Electronic Control Unit) is a PCB composed by several components and is subdivided in some branches, which are: - CAN power connectors - DCDC converter - Debug - Brakelight - Shutdown - Raspberry brain - Encoders - Analog sensors - IMU.","title":"Introduction"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#analog-sensors","text":"","title":"Analog sensors"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#brake-and-accelerator-sensors","text":"Analog sensors have as main task to receive a variable tension (direct proportional to the travel) from the potentiometers placed on the pedals and transmit it to the Raspberry microcontroller. The signal, before the transmission, is filtered at a frequency of 100 kHz by low pass filters. LPF are realized through op-amp with a power supply of 12 V","title":"Brake and accelerator sensors"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#pitot-tube","text":"In this section, we can also find an integrated silicon pressure sensor, which uses a pitot tube to gain information about the aerodynamics of the car, and can be driven by two clean signals of 5 V or 3.3 V. We can choose the signals through a jumper.","title":"Pitot tube"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#power-supply","text":"The power supply for the sensors is realized through a voltage regulator that converts 28 V to the 5 V needed by the sensors.","title":"Power supply"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#encoders","text":"The car is equipped with encoders to acquire useful data that concern the car performances. They are placed on the steering wheel and on the fronts wheels and communicate with the Raspberry through transceivers, which take as input differential signals. The input signals pass through a terminating resistor and a capacitor. The addition of the capacitor mitigates the power dissipation problems of other parallel termination schemes, blocks low-frequency noise, and minimizes overshoot and undershoot (source: https://resources.pcb.cadence.com/blog/termination-resistors-in-pcb-design).","title":"Encoders"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#imu","text":"The IMU is the inertial measurement unit (IMU) for the detection of movements and rotations in 6 degrees of freedom (6DoF). The BMI068 combines the functionality of two inertial sensors in one device: an advanced triaxial 16-bit gyroscope and a versatile, leading-edge triaxial 16-bit accelerometer.","title":"IMU"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#raspberry-brain","text":"","title":"Raspberry brain"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#microcontrollers","text":"The section where decisions are taken is formed by the Raspberry microcontroller and STM32F446RETx. The second micro acquires informations about the vehicle and pedals status from all the sensors and encoders placed on the cars. The first one, instead, performs decision making. The two controllers communicates through the microchip MCP2515-xSO, which provides an interface between the CAN protocol, that transports the sensors' data, and the SPI, which sends the data through a BUS to the Raspberry. Both of them have a quartz oscillator connected to two parallel capacitors, as shown in the application notes of the device. Moreover, there are some CAN tranceivers to perform a direct communication between CAN protocol and Raspberry on two channels CAN1 and CAN2. They are preceded by a resistor of 33 \u03a9 to reduce disturbances at high frequencies.","title":"Microcontrollers"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#buzzer","text":"In this section we can also find the buzzer, the device that products an acoustic to signal that the car is ready-to-drive (A5.6.3).","title":"Buzzer"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#ferrite-bead-blm18ag221sz1d","text":"A ferrite bead is a type of choke that suppresses high-frequency electronic noise in electronic circuits. Ferrite beads employ high-frequency current dissipation in a ferrite ceramic to build high-frequency noise suppression devices.","title":"Ferrite bead BLM18AG221SZ1D"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#eeprom","text":"The STM32F446RETx has also a pin for a memory. The chosen one is a M95256-WMN6P EEPROM memory, which can store and override input values through two different transistors that perform holding and writing.","title":"EEPROM"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#brakelight","text":"The breaklight has 3 channel to communicate with the STM32F446RETx. The micro can provide the input (High) to close the circuit and activate the LEDS.","title":"Brakelight"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#shutdown","text":"The shutdown circuit is composed by a relay and a transistor, that is usually in saturation zone. When the Raspberry sends a low signal, the transistor opens the circuit and the current goes to 0.","title":"Shutdown"},{"location":"hw-fenice-evo-ecu/ECU%20Documentation/#dcdc-converter","text":"The DCDC converter of the PCB converts the 12 V in 5 and 3.3 V.","title":"DCDC converter"},{"location":"lap-time-simulator-DMT/01-How-to-get-started/","text":"Getting Started Table of Contents Required Software","title":"Getting Started"},{"location":"lap-time-simulator-DMT/01-How-to-get-started/#getting-started","text":"","title":"Getting Started"},{"location":"lap-time-simulator-DMT/01-How-to-get-started/#table-of-contents","text":"Required Software","title":"Table of Contents"},{"location":"lap-time-simulator-DMT/12-Release-Notes/","text":"Release Notes In this section you will find the updates of the model 03/12/2022: Initial release","title":"Release Notes"},{"location":"lap-time-simulator-DMT/12-Release-Notes/#release-notes","text":"In this section you will find the updates of the model 03/12/2022: Initial release","title":"Release Notes"},{"location":"lap-time-simulator-DMT/Home/","text":"Lap Time Simulator Welcome to the Lap Time Simulator wiki! TABLE OF CONTENTS How to Get Started Release Notes","title":"Lap Time Simulator"},{"location":"lap-time-simulator-DMT/Home/#lap-time-simulator","text":"Welcome to the Lap Time Simulator wiki!","title":"Lap Time Simulator"},{"location":"lap-time-simulator-DMT/Home/#table-of-contents","text":"How to Get Started Release Notes","title":"TABLE OF CONTENTS"},{"location":"lib-communication/connection/","text":"Implement New Connection Type Introduction To create a new connection type you should just implement all virtual functions in the abstract Connection class, that is in the inc/connection.h file. Every message has to be of type Generic Message . The structure of this struct is show here below: struct GenericMessage { string topic; string payload; }; To generalize the connection type you have to implement a class that will contain all the things you'll need for the connection, such as the context and the socket. The class you're going to create must inherit from GenericSocket class, a void class that has been created in the inc/connection.h file. Once you've done so, you can create your connection class, that will inherit from Connection (the abstract class mentioned above). Variables list All variables are protected and can be accessed from the derived class. The following variables are available: These variables are needed to set up the connection. You can only set them by calling the Connection 's init function, by passing to it them all. string address; // FORMAT EXAMPLE: 127.0.0.1 string port; // FORMAT EXAMPLE: 8080 int openMode; // FORMAT EXAMPLE: PUB/SUB (it's an enum) This is the object mentioned above, where should be stored your custom socket class. GeneralSocket* socket; These variables are checked inside the Connection class, so you have to manage them. For example: the open = true when the connection has started; the done = true when you close the connection; new_data should never be modify, because is managed by the Connection class. bool done; bool open; bool new_data; These variables are used in the Connection class to manage the reading and the writing operation. The mtx is used to lock the variables, so you can't read or write them at the same time; the cv is used to wait for the other thread to finish the operation; the buff_send is used to store the data that will be sent. mutex mtx; condition_variable cv; queue<GenerciMessage> buff_send; Every client has a unique id, that is stored in this variable. string id; The max queue size is determined by this variable. int max_queue_size; You can check how many subscription does a subscriber has by using this variable. int subscription_count; Methods to implement Here below the list of all the needed methods: The constructor should only call the Connection 's contrsuctor. // in the .cpp file [YOUR_CLASS]::[YOUR_CLASS]() : Connection() { // code here will be executed before the Connection constructor } The destructor should only call the Connection 's destructor and delete all pointers and other allocated variables. // in the .cpp file [YOUR_CLASS]::~[YOUR_CLASS]() { // code here will be executed before the Connection destructor delete [VARIABLE_NAME]; } The close connection function does not need parameter, because all connection items you'll need should be in the GeneralSocket item. In this function you have to manage the connection closing. void closeConnection(); The subscribe function should manage the subscriber's subscription to a spcified topic void subscribe(const string& topic); The unsubscribe function should manage the subscriber's unsubscription to a specified topic. void unsubscribe(const string& topic); The send message function should take a GenericMessage type message and just has to send it. void sendMessage(const message& msg); The receive message function should call the receive function of your connection and save the arguments in the given message type message. Different implementations may use callbacks, in these case you won't need this method. void receiveMessage(message& msg); The start function have to start either a PUB or a SUB connection and then must create a thread calling the sendLoop() function or the receiveLoop() function depending on the type of the client ( PUB or SUB ) and return the thread. It will start the connection using the parameter given to the init function. thread* start(); Already implemented methods (in the Connection class) Public methods The init function sets the connection's variables. As told before, to set the connection's variables you have to call this function. void init(const string& address, const string& port, const int& openMode); The set data will take a GenericMessage type message and insert it in the queue. void setData(GenericMessage msg); Protected methods This function is called by the send loop function. It will loop and check if the queue is not empty, if there's at least one message, it will call your send message function. void sendLoop(); This function is called by the receive loop function. It will loop and check if there are messages to receive by calling your receive message function. The received message will be used by clbk_on_message . void receiveLoop(); This function will reset the connection's variables. void reset(); This function will stop and close the connection calling your close connection function. void stop(); This function will clear the queue. void clearData(); Callbacks Set callbacks This function will set the given function to the clbk_on_connect variable. void add_on_connect(function<void(const int &id)>); This function will set the given function to the clbk_on_disconnect variable. void add_on_disconnect(function<void(const int &id, const int &code)>); This function will set the given function to the clbk_on_error variable. void add_on_error(function<void(const int &id, const int &code, const string &msg)>); This function will set the given function to the clbk_on_message variable. void add_on_message(function<void(const int &id, const GenericMessage &msg)>); This function will set the given function to the clbk_on_subscribe variable. void add_on_subscribe(function<void(const int &id, const string &topic)>); This function will set the given function to the clbk_on_unsubscribe variable. void add_on_unsubscribe(function<void(const int &id, const string &topic)>); Use callbacks This function will call the clbk_on_connect callback. It have to be called when the connection is opened. void onConnect(const int &id); This function will call the clbk_on_disconnect callback. It have to be called when the connection is closed (also when fatal errors occurs). The given code should be 0 if there's no error, otherwise it should be the error code. void onDisconnect(const int &id, const int& code); This function will call the clbk_on_error callback. It have to be called when an error occurs (remember to handle errors). It needs the error code and the error message. void onError(const int &id, const int& code, const string& msg); This function will call the clbk_on_message callback. It's used in the receive loop function. It takes the received message as a parameter. void onMessage(const int &id, const GenericMessage& msg); This function will call the clbk_on_subscribe callback. It has to be called when a subscription is done. It takes the topic as a parameter. void onSubscribe(const int &id, const string& topic); This function will call the clbk_on_unsubscribe callback. It have to be called when an unsubscription is done. It take the topic as a parameter. void onUnsubscribe(const int &id, const string& topic); This function will call the clbk_on_publish callback. It have to be called when a message is published. It takes the topic as a parameter. void onPublish(const int &id, const string& topic); Usage Create a connection Create a connection object. It will init connection variables. // the name should represent either the publisher or the subscriber [YOUR_CLASS] name; Init the connection. name.init(\"localhost\", \"1883\", PUB); // or name.init(\"localhost\", \"1883\", SUB); Set up the callbacks. // where [CALLBACK] is either open, close, error, message, subscribe, unsubscribe name.addOn[CALLBACK]([&]() { // do something }); Start the connection. It will automatically run the send loop or the receive loop , depending on the connection's mode setted in the init function. thread* thread_name = name.start(); Subscribe/unsubscribe to/from a topic or set data. name.subscribe(\"topic\"); // or name.unsubscribe(\"topic\"); // or // the topic should be the ID of the message name.setData(\"topic\", \"data\"); Close the connection. name.closeConnection(); Examples An example of the connection could be seen at src/connection/mqtt_connection.cpp , with the associated header at inc/connection/mqtt_connection.h . A working test example could be seen at scripts/testMQTT/test.cpp . It's a simple connection that will publish and subscribe to a topic. The example describes an MQTT working connection between a publisher and a subscriber comunicating between two different threads. Another example can be seen at src/connection/ws_connection.cpp with its header at src/connection/ws_connection.cpp and the test at scripts/testWS/test.cpp . It's a simple WebSocket connection that will publish and subscribe to a topic.","title":"Implement New Connection Type"},{"location":"lib-communication/connection/#implement-new-connection-type","text":"","title":"Implement New Connection Type"},{"location":"lib-communication/connection/#introduction","text":"To create a new connection type you should just implement all virtual functions in the abstract Connection class, that is in the inc/connection.h file. Every message has to be of type Generic Message . The structure of this struct is show here below: struct GenericMessage { string topic; string payload; }; To generalize the connection type you have to implement a class that will contain all the things you'll need for the connection, such as the context and the socket. The class you're going to create must inherit from GenericSocket class, a void class that has been created in the inc/connection.h file. Once you've done so, you can create your connection class, that will inherit from Connection (the abstract class mentioned above).","title":"Introduction"},{"location":"lib-communication/connection/#variables-list","text":"All variables are protected and can be accessed from the derived class. The following variables are available: These variables are needed to set up the connection. You can only set them by calling the Connection 's init function, by passing to it them all. string address; // FORMAT EXAMPLE: 127.0.0.1 string port; // FORMAT EXAMPLE: 8080 int openMode; // FORMAT EXAMPLE: PUB/SUB (it's an enum) This is the object mentioned above, where should be stored your custom socket class. GeneralSocket* socket; These variables are checked inside the Connection class, so you have to manage them. For example: the open = true when the connection has started; the done = true when you close the connection; new_data should never be modify, because is managed by the Connection class. bool done; bool open; bool new_data; These variables are used in the Connection class to manage the reading and the writing operation. The mtx is used to lock the variables, so you can't read or write them at the same time; the cv is used to wait for the other thread to finish the operation; the buff_send is used to store the data that will be sent. mutex mtx; condition_variable cv; queue<GenerciMessage> buff_send; Every client has a unique id, that is stored in this variable. string id; The max queue size is determined by this variable. int max_queue_size; You can check how many subscription does a subscriber has by using this variable. int subscription_count;","title":"Variables list"},{"location":"lib-communication/connection/#methods-to-implement","text":"Here below the list of all the needed methods: The constructor should only call the Connection 's contrsuctor. // in the .cpp file [YOUR_CLASS]::[YOUR_CLASS]() : Connection() { // code here will be executed before the Connection constructor } The destructor should only call the Connection 's destructor and delete all pointers and other allocated variables. // in the .cpp file [YOUR_CLASS]::~[YOUR_CLASS]() { // code here will be executed before the Connection destructor delete [VARIABLE_NAME]; } The close connection function does not need parameter, because all connection items you'll need should be in the GeneralSocket item. In this function you have to manage the connection closing. void closeConnection(); The subscribe function should manage the subscriber's subscription to a spcified topic void subscribe(const string& topic); The unsubscribe function should manage the subscriber's unsubscription to a specified topic. void unsubscribe(const string& topic); The send message function should take a GenericMessage type message and just has to send it. void sendMessage(const message& msg); The receive message function should call the receive function of your connection and save the arguments in the given message type message. Different implementations may use callbacks, in these case you won't need this method. void receiveMessage(message& msg); The start function have to start either a PUB or a SUB connection and then must create a thread calling the sendLoop() function or the receiveLoop() function depending on the type of the client ( PUB or SUB ) and return the thread. It will start the connection using the parameter given to the init function. thread* start();","title":"Methods to implement"},{"location":"lib-communication/connection/#already-implemented-methods-in-the-connection-class","text":"","title":"Already implemented methods (in the Connection class)"},{"location":"lib-communication/connection/#public-methods","text":"The init function sets the connection's variables. As told before, to set the connection's variables you have to call this function. void init(const string& address, const string& port, const int& openMode); The set data will take a GenericMessage type message and insert it in the queue. void setData(GenericMessage msg);","title":"Public methods"},{"location":"lib-communication/connection/#protected-methods","text":"This function is called by the send loop function. It will loop and check if the queue is not empty, if there's at least one message, it will call your send message function. void sendLoop(); This function is called by the receive loop function. It will loop and check if there are messages to receive by calling your receive message function. The received message will be used by clbk_on_message . void receiveLoop(); This function will reset the connection's variables. void reset(); This function will stop and close the connection calling your close connection function. void stop(); This function will clear the queue. void clearData();","title":"Protected methods"},{"location":"lib-communication/connection/#callbacks","text":"","title":"Callbacks"},{"location":"lib-communication/connection/#set-callbacks","text":"This function will set the given function to the clbk_on_connect variable. void add_on_connect(function<void(const int &id)>); This function will set the given function to the clbk_on_disconnect variable. void add_on_disconnect(function<void(const int &id, const int &code)>); This function will set the given function to the clbk_on_error variable. void add_on_error(function<void(const int &id, const int &code, const string &msg)>); This function will set the given function to the clbk_on_message variable. void add_on_message(function<void(const int &id, const GenericMessage &msg)>); This function will set the given function to the clbk_on_subscribe variable. void add_on_subscribe(function<void(const int &id, const string &topic)>); This function will set the given function to the clbk_on_unsubscribe variable. void add_on_unsubscribe(function<void(const int &id, const string &topic)>);","title":"Set callbacks"},{"location":"lib-communication/connection/#use-callbacks","text":"This function will call the clbk_on_connect callback. It have to be called when the connection is opened. void onConnect(const int &id); This function will call the clbk_on_disconnect callback. It have to be called when the connection is closed (also when fatal errors occurs). The given code should be 0 if there's no error, otherwise it should be the error code. void onDisconnect(const int &id, const int& code); This function will call the clbk_on_error callback. It have to be called when an error occurs (remember to handle errors). It needs the error code and the error message. void onError(const int &id, const int& code, const string& msg); This function will call the clbk_on_message callback. It's used in the receive loop function. It takes the received message as a parameter. void onMessage(const int &id, const GenericMessage& msg); This function will call the clbk_on_subscribe callback. It has to be called when a subscription is done. It takes the topic as a parameter. void onSubscribe(const int &id, const string& topic); This function will call the clbk_on_unsubscribe callback. It have to be called when an unsubscription is done. It take the topic as a parameter. void onUnsubscribe(const int &id, const string& topic); This function will call the clbk_on_publish callback. It have to be called when a message is published. It takes the topic as a parameter. void onPublish(const int &id, const string& topic);","title":"Use callbacks"},{"location":"lib-communication/connection/#usage","text":"","title":"Usage"},{"location":"lib-communication/connection/#create-a-connection","text":"Create a connection object. It will init connection variables. // the name should represent either the publisher or the subscriber [YOUR_CLASS] name; Init the connection. name.init(\"localhost\", \"1883\", PUB); // or name.init(\"localhost\", \"1883\", SUB); Set up the callbacks. // where [CALLBACK] is either open, close, error, message, subscribe, unsubscribe name.addOn[CALLBACK]([&]() { // do something }); Start the connection. It will automatically run the send loop or the receive loop , depending on the connection's mode setted in the init function. thread* thread_name = name.start(); Subscribe/unsubscribe to/from a topic or set data. name.subscribe(\"topic\"); // or name.unsubscribe(\"topic\"); // or // the topic should be the ID of the message name.setData(\"topic\", \"data\"); Close the connection. name.closeConnection();","title":"Create a connection"},{"location":"lib-communication/connection/#examples","text":"An example of the connection could be seen at src/connection/mqtt_connection.cpp , with the associated header at inc/connection/mqtt_connection.h . A working test example could be seen at scripts/testMQTT/test.cpp . It's a simple connection that will publish and subscribe to a topic. The example describes an MQTT working connection between a publisher and a subscriber comunicating between two different threads. Another example can be seen at src/connection/ws_connection.cpp with its header at src/connection/ws_connection.cpp and the test at scripts/testWS/test.cpp . It's a simple WebSocket connection that will publish and subscribe to a topic.","title":"Examples"},{"location":"lib-communication/mqtt_connection/","text":"MOSQUITTO SETUP INDEX: Installation Client Broker Test the Broker Compile and Test Usage Broker Configuration File Start the Broker Start the Telemetry Setup the Connection INSTALLATION: CLIENT First of all you have to install mosquitto library on the device where you'll run the telemetry, using sudo apt install libmosquitto-dev sudo apt install mosquitto-dev BROKER On the broker device you have to install the mosquitto broker service by sudo snap install mosquitto or, if you'll run the broker on 32-bit devices or if you don't have snap installed sudo apt install mosquitto TEST THE BROKER Before using the telemetry test if the broker work by installing also mosquito-clients , so sudo snap install mosquitto-clients or, as for the broker installation, sudo apt install mosquitto-clients Once you had installed mosquitto-clients , you can run a subscriber by mosquitto_sub -h localhost -p 1883 -t [TOPIC_TO_SUBSCRIBE] {-u [USERNAME] -P [PASSWORD]} and, on another terminal, run a publisher by mosquitto_pub -h localhost -p 1883 -t [TOPIC_TO_PUBLISH] -m [MESSAGE] {-u [USERNAME] -P [PASSWORD]} where the username and the password had been set on the broker (not mandatory, but raccommended). If there's no users or if you want to add some, you can follow the Documentation . EXAMPLE: Create a password's file passwords and run sudo mosquitto_passwd -c [FILE_NAME] [USERNAME] You'll be asked to choose a password and to repeat it. COMPILE & TEST: To use the mosquitto library you also have to append the -lmosquitto flag. There's a test in scripts/testMQTT folder. USAGE: Broker's Configuration File You can find the .conf file in the /etc/mosquitto/ folder. # Place your local configuration in /etc/mosquitto/conf.d/ # # A full description of the configuration file is at # /usr/share/doc/mosquitto/examples/mosquitto.conf.example #allow_anonymous true listener 1883 0.0.0.0 pid_file /run/mosquitto/mosquitto.pid persistence true persistence_location /var/lib/mosquitto/ log_dest topic log_type error log_type warning log_type notice log_type information connection_messages true log_timestamp true password_file /etc/mosquitto/passwords log_dest file /var/log/mosquitto/mosquitto.log include_dir /etc/mosquitto/conf.d - allow_anonymous true : can be useful while testing, to avoid creating new users or to don't add corresponging flags while executing the code. - listener 1883 0.0.0.0 : must be insert to make the broker listen on all its addresses. - include_dir /etc/mosquitto/conf.d : it's the folder where you can add your custom configuration files. - log_dest file /var/log/mosquitto/mosquitto.log : here you can find the log about your last broker session. Start the Broker Before starting the broker, remember to stop the service that is enabled by default on the device. To do so, you can run sudo systemctl stop mosquitto.service After the setup, you can start the broker by ./run_broker.sh that will execute the following line sudo mosquitto --verbose --config-file ./mosquitto.conf If you don't have the ./run_broker.sh file you can write it by yourself. If you would like to modify the configuration of the broker just add a new .conf file inside the conf.d/ folder. For the documentation about writing .conf files visit the Mosquitto Documentation . Start the Telemetry For this part just have a look at the Telemetry Documentation and, if you want to create a new type of connection, at the Connection Documentation . Setup the Connection Before setting up the connection, here's a thing you have to know: the topic field can be used to create a tree of topics, so you can subscribe to a topic and receive all the messages published on that topic and on all its subtopics. For example, if you subscribe to the topic home/sensors/temperature you'll receive all the messages published on home/sensors/temperature , home/sensors/temperature/1 and home/sensors/temperature/2 . 1. To setup the connection you have to create a new MQTTConnection object and, if needed, pass the username and the password to it. Add all callbacks you want to use to the MQTTConnection object by using the addOn[CALLBACK] method. Init the connection by calling the init method (view Connection Documentation to see which parameters it will need and for other information about connections). Start the connection by calling the start method and storing the return thread. Subscribe/unsubscribe to/from a topic or set data. name.subscribe(\"topic\"); // or name.unsubscribe(\"topic\"); // or name.setData(\"topic\", \"data\"); Close the connection. name.closeConnection(); EXAMPLES: The MQTT example is in the script/testMQTT/ folder. The .cpp and the .h files are in the src/connection/ and in the inc/connection folder. The user must check the pending messages counter before publishing by calling getPendingMessages() .","title":"MOSQUITTO SETUP"},{"location":"lib-communication/mqtt_connection/#mosquitto-setup","text":"","title":"MOSQUITTO SETUP"},{"location":"lib-communication/mqtt_connection/#index","text":"Installation Client Broker Test the Broker Compile and Test Usage Broker Configuration File Start the Broker Start the Telemetry Setup the Connection","title":"INDEX:"},{"location":"lib-communication/mqtt_connection/#installation","text":"","title":"INSTALLATION:"},{"location":"lib-communication/mqtt_connection/#client","text":"First of all you have to install mosquitto library on the device where you'll run the telemetry, using sudo apt install libmosquitto-dev sudo apt install mosquitto-dev","title":"CLIENT"},{"location":"lib-communication/mqtt_connection/#broker","text":"On the broker device you have to install the mosquitto broker service by sudo snap install mosquitto or, if you'll run the broker on 32-bit devices or if you don't have snap installed sudo apt install mosquitto","title":"BROKER"},{"location":"lib-communication/mqtt_connection/#test-the-broker","text":"Before using the telemetry test if the broker work by installing also mosquito-clients , so sudo snap install mosquitto-clients or, as for the broker installation, sudo apt install mosquitto-clients Once you had installed mosquitto-clients , you can run a subscriber by mosquitto_sub -h localhost -p 1883 -t [TOPIC_TO_SUBSCRIBE] {-u [USERNAME] -P [PASSWORD]} and, on another terminal, run a publisher by mosquitto_pub -h localhost -p 1883 -t [TOPIC_TO_PUBLISH] -m [MESSAGE] {-u [USERNAME] -P [PASSWORD]} where the username and the password had been set on the broker (not mandatory, but raccommended). If there's no users or if you want to add some, you can follow the Documentation .","title":"TEST THE BROKER"},{"location":"lib-communication/mqtt_connection/#example","text":"Create a password's file passwords and run sudo mosquitto_passwd -c [FILE_NAME] [USERNAME] You'll be asked to choose a password and to repeat it.","title":"EXAMPLE:"},{"location":"lib-communication/mqtt_connection/#compile-test","text":"To use the mosquitto library you also have to append the -lmosquitto flag. There's a test in scripts/testMQTT folder.","title":"COMPILE &amp; TEST:"},{"location":"lib-communication/mqtt_connection/#usage","text":"","title":"USAGE:"},{"location":"lib-communication/mqtt_connection/#brokers-configuration-file","text":"You can find the .conf file in the /etc/mosquitto/ folder. # Place your local configuration in /etc/mosquitto/conf.d/ # # A full description of the configuration file is at # /usr/share/doc/mosquitto/examples/mosquitto.conf.example #allow_anonymous true listener 1883 0.0.0.0 pid_file /run/mosquitto/mosquitto.pid persistence true persistence_location /var/lib/mosquitto/ log_dest topic log_type error log_type warning log_type notice log_type information connection_messages true log_timestamp true password_file /etc/mosquitto/passwords log_dest file /var/log/mosquitto/mosquitto.log include_dir /etc/mosquitto/conf.d - allow_anonymous true : can be useful while testing, to avoid creating new users or to don't add corresponging flags while executing the code. - listener 1883 0.0.0.0 : must be insert to make the broker listen on all its addresses. - include_dir /etc/mosquitto/conf.d : it's the folder where you can add your custom configuration files. - log_dest file /var/log/mosquitto/mosquitto.log : here you can find the log about your last broker session.","title":"Broker's Configuration File"},{"location":"lib-communication/mqtt_connection/#start-the-broker","text":"Before starting the broker, remember to stop the service that is enabled by default on the device. To do so, you can run sudo systemctl stop mosquitto.service After the setup, you can start the broker by ./run_broker.sh that will execute the following line sudo mosquitto --verbose --config-file ./mosquitto.conf If you don't have the ./run_broker.sh file you can write it by yourself. If you would like to modify the configuration of the broker just add a new .conf file inside the conf.d/ folder. For the documentation about writing .conf files visit the Mosquitto Documentation .","title":"Start the Broker"},{"location":"lib-communication/mqtt_connection/#start-the-telemetry","text":"For this part just have a look at the Telemetry Documentation and, if you want to create a new type of connection, at the Connection Documentation .","title":"Start the Telemetry"},{"location":"lib-communication/mqtt_connection/#setup-the-connection","text":"Before setting up the connection, here's a thing you have to know: the topic field can be used to create a tree of topics, so you can subscribe to a topic and receive all the messages published on that topic and on all its subtopics. For example, if you subscribe to the topic home/sensors/temperature you'll receive all the messages published on home/sensors/temperature , home/sensors/temperature/1 and home/sensors/temperature/2 . 1. To setup the connection you have to create a new MQTTConnection object and, if needed, pass the username and the password to it. Add all callbacks you want to use to the MQTTConnection object by using the addOn[CALLBACK] method. Init the connection by calling the init method (view Connection Documentation to see which parameters it will need and for other information about connections). Start the connection by calling the start method and storing the return thread. Subscribe/unsubscribe to/from a topic or set data. name.subscribe(\"topic\"); // or name.unsubscribe(\"topic\"); // or name.setData(\"topic\", \"data\"); Close the connection. name.closeConnection();","title":"Setup the Connection"},{"location":"lib-communication/mqtt_connection/#examples","text":"The MQTT example is in the script/testMQTT/ folder. The .cpp and the .h files are in the src/connection/ and in the inc/connection folder. The user must check the pending messages counter before publishing by calling getPendingMessages() .","title":"EXAMPLES:"},{"location":"rasp-shieldV2-config/","text":"Documentation! This page will be published to eagletrt.wiki . For info on how to use the wiki, refer to this guide and have a look around some other wiki pages. Remember to test locally before pushing this folder!","title":"Documentation!"},{"location":"rasp-shieldV2-config/#documentation","text":"This page will be published to eagletrt.wiki . For info on how to use the wiki, refer to this guide and have a look around some other wiki pages. Remember to test locally before pushing this folder!","title":"Documentation!"},{"location":"rtl_433/ANALYZE/","text":"Capture and analyze devices TL;DR Capture sample data with -S unknown . Note down the expected measurement values from a read-out or head unit. Check the spectrogram by dropping samples on https://triq.org/iqs/ (it should look \"busy\" like this ) Try analyzing each sample with rtl_433 -A gfile.cu8 to see if there is some real data. Use the analyzer hints to create a plausible -X decoder and demod the data codes. Then upload some zipped samples to an issue and post a description and tabled codes and values per sample file. Verify a transmission rtl_433 processes radio data in multiple stages. You can follow the stages and verify the data at each point. First a radio data packet is found and framed. Get on overview of the band. Check if the transmission is visible and in the expected frequency range. Use CubicSDR, Gqrx, SigDigger, SDR#, SDRangel or similar SDR UIs to verify you receice a signal. If you have the SDR receiver on a headless machine try rtl_tcp to transport data to a GUI. ::: tip A quick substitute for an SDR UI is to record a sample, e.g. -w file_433.92M_250k.cu -T 60 (adjust for the actual frequency and sample rate). Now drop that .cu8 sample file on https://triq.org/pdv/ to visually inspect the spectrogram (a sideways view of the common SDR waterfalls). ::: ::: warning Do not plug the receiver directly in a USB port, avoid noise and use a short usb cable. ::: Grab a sample Note the frequency, pick a frequency a little off, e.g 50k above or below. Then grab the signal with rtl_433, e.g. rtl_433 -f 433.92M -S unknown Visually verify the samples in https://triq.org/iqs ::: tip The modes for the sample grabber are - -S all : grab all frames found - -S unknown : grab frames that are not decoded by any decoder - -S known : grab frames successfully decoded by some decoder ::: The band covered is equal to the sample rate. At the default 433.92M and 250k sample rate that's 433.67 MHz to 434.17 MHz . For the 868M default sample rate of 1024k that's 867.5 MHz to 868.5 MHz . For the 868M it's like good to pick 868.3M for a band of 867.8 MHz to 868.8 MHz . To get a clean signal remove the receiver antenna and place the device at 10cm to the receiver, that mostly isolates the transmissions. Analyze the data packet Then next stage is demodulation of OOK or FSK data. A run of pulse/gap (OOK) or mark/space (FSK) timings is generated by the demod. Run rtl_433 -A SAMPLE.cu8 to get an overview of the timings, or rtl_433 -w OOK:- SAMPLE.cu8 to see the raw data. Write the pulses to a file with rtl_433 -w SAMPLE.ook SAMPLE.cu8 and visualize the file with https://triq.org/pdv ::: warning You need to give the sample rate if it's not 250k, look at the file name, e.g. use rtl_433 -s 1000k -A SAMPLE_1000k.cu8 ::: For advanced analysis you can also try out SigRok's Pulseview with rtl_433 -W out.sr SAMPLE.cu8 . Be sure to also try with higher sensitivity: -Y autolevel -Y magest -M noise -M level Try different sample rates, for 433M try -s 1024k , for 868M try -s 250k or -s 2048k . Try different demods, for 433M try -Y minmax , for 868M try -Y classic . Build a flex decoder Now build a flex decoder to slice the data into bits. Use the suggestion or make a guess based on the analyzed pulse data on the coding. Document data codes The last stage is the protocol decoding from the bit data. Build a table of codes and the expected sensor values to identify where the bytes are and what is contained. Preferably put the codes and annotations in a BitBench . Example commands capture samples not decoded by rtl_433 rtl_433 -S unknown capture samples of every received frame rtl_433 -S all anaylze a capture to get an overview of the timings rtl_433 -A SAMPLE.cu8 show the raw data pulse data from a captured sample rtl_433 -w OOK:- SAMPLE.cu8 convert pulse data from a capture to OOK file rtl_433 -w SAMPLE.ook SAMPLE.cu8 try to read codes from a captured sample rtl_433 -X '...' SAMPLE.cu8 open a captured sample in SigRok Pulseview rtl_433 -W SAMPLE.sr SAMPLE.cu8","title":"Capture and analyze devices"},{"location":"rtl_433/ANALYZE/#capture-and-analyze-devices","text":"","title":"Capture and analyze devices"},{"location":"rtl_433/ANALYZE/#tldr","text":"Capture sample data with -S unknown . Note down the expected measurement values from a read-out or head unit. Check the spectrogram by dropping samples on https://triq.org/iqs/ (it should look \"busy\" like this ) Try analyzing each sample with rtl_433 -A gfile.cu8 to see if there is some real data. Use the analyzer hints to create a plausible -X decoder and demod the data codes. Then upload some zipped samples to an issue and post a description and tabled codes and values per sample file.","title":"TL;DR"},{"location":"rtl_433/ANALYZE/#verify-a-transmission","text":"rtl_433 processes radio data in multiple stages. You can follow the stages and verify the data at each point. First a radio data packet is found and framed. Get on overview of the band. Check if the transmission is visible and in the expected frequency range. Use CubicSDR, Gqrx, SigDigger, SDR#, SDRangel or similar SDR UIs to verify you receice a signal. If you have the SDR receiver on a headless machine try rtl_tcp to transport data to a GUI. ::: tip A quick substitute for an SDR UI is to record a sample, e.g. -w file_433.92M_250k.cu -T 60 (adjust for the actual frequency and sample rate). Now drop that .cu8 sample file on https://triq.org/pdv/ to visually inspect the spectrogram (a sideways view of the common SDR waterfalls). ::: ::: warning Do not plug the receiver directly in a USB port, avoid noise and use a short usb cable. :::","title":"Verify a transmission"},{"location":"rtl_433/ANALYZE/#grab-a-sample","text":"Note the frequency, pick a frequency a little off, e.g 50k above or below. Then grab the signal with rtl_433, e.g. rtl_433 -f 433.92M -S unknown Visually verify the samples in https://triq.org/iqs ::: tip The modes for the sample grabber are - -S all : grab all frames found - -S unknown : grab frames that are not decoded by any decoder - -S known : grab frames successfully decoded by some decoder ::: The band covered is equal to the sample rate. At the default 433.92M and 250k sample rate that's 433.67 MHz to 434.17 MHz . For the 868M default sample rate of 1024k that's 867.5 MHz to 868.5 MHz . For the 868M it's like good to pick 868.3M for a band of 867.8 MHz to 868.8 MHz . To get a clean signal remove the receiver antenna and place the device at 10cm to the receiver, that mostly isolates the transmissions.","title":"Grab a sample"},{"location":"rtl_433/ANALYZE/#analyze-the-data-packet","text":"Then next stage is demodulation of OOK or FSK data. A run of pulse/gap (OOK) or mark/space (FSK) timings is generated by the demod. Run rtl_433 -A SAMPLE.cu8 to get an overview of the timings, or rtl_433 -w OOK:- SAMPLE.cu8 to see the raw data. Write the pulses to a file with rtl_433 -w SAMPLE.ook SAMPLE.cu8 and visualize the file with https://triq.org/pdv ::: warning You need to give the sample rate if it's not 250k, look at the file name, e.g. use rtl_433 -s 1000k -A SAMPLE_1000k.cu8 ::: For advanced analysis you can also try out SigRok's Pulseview with rtl_433 -W out.sr SAMPLE.cu8 . Be sure to also try with higher sensitivity: -Y autolevel -Y magest -M noise -M level Try different sample rates, for 433M try -s 1024k , for 868M try -s 250k or -s 2048k . Try different demods, for 433M try -Y minmax , for 868M try -Y classic .","title":"Analyze the data packet"},{"location":"rtl_433/ANALYZE/#build-a-flex-decoder","text":"Now build a flex decoder to slice the data into bits. Use the suggestion or make a guess based on the analyzed pulse data on the coding.","title":"Build a flex decoder"},{"location":"rtl_433/ANALYZE/#document-data-codes","text":"The last stage is the protocol decoding from the bit data. Build a table of codes and the expected sensor values to identify where the bytes are and what is contained. Preferably put the codes and annotations in a BitBench .","title":"Document data codes"},{"location":"rtl_433/ANALYZE/#example-commands","text":"capture samples not decoded by rtl_433 rtl_433 -S unknown capture samples of every received frame rtl_433 -S all anaylze a capture to get an overview of the timings rtl_433 -A SAMPLE.cu8 show the raw data pulse data from a captured sample rtl_433 -w OOK:- SAMPLE.cu8 convert pulse data from a capture to OOK file rtl_433 -w SAMPLE.ook SAMPLE.cu8 try to read codes from a captured sample rtl_433 -X '...' SAMPLE.cu8 open a captured sample in SigRok Pulseview rtl_433 -W SAMPLE.sr SAMPLE.cu8","title":"Example commands"},{"location":"rtl_433/BUILDING/","text":"Building rtl_433 rtl_433 currently supports these input types: * RTL-SDR (optional, recommended) * SoapySDR (optional) * files: CU8, CS16, CF32 I/Q data, U16 AM data (built-in) * rtl_tcp remote data servers (built-in) Building rtl_433 with RTL-SDR or SoapySDR support is optional but using RTL-SDR is highly recommended. The libraries and header files for RTL-SDR and/or SoapySDR should be installed beforehand. Nightly builds Some distributions offer nightly builds. openSUSE openSUSE users of at least Leap 42.3 or Tumbleweed can add the repository with daily builds: $ sudo zypper addrepo -f obs://home:mnhauke:rtl_433:nightly/rtl_433 rtl_433-nightly $ sudo zypper install rtl_433 The usual update mechanism will now keep the rtl_433 version current. Fedora Fedora users (31, 32 and Rawhide) can add the following copr repository to get nightly builds: $ sudo dnf copr enable tvass/rtl_433 $ sudo dnf install rtl_433 The usual update mechanism will now keep the rtl_433 version current. Linux / Mac OS X Depending on your system, you may need to install the following libraries. Debian: If you require TLS connections, install libssl-dev . sudo apt-get install libtool libusb-1.0-0-dev librtlsdr-dev rtl-sdr build-essential cmake pkg-config Centos/Fedora/RHEL with EPEL repo using cmake: If dnf doesn't exist, use yum . If you require TLS connections, install openssl-devel . sudo dnf install libtool libusbx-devel rtl-sdr-devel rtl-sdr cmake Mac OS X with MacPorts: If you require TLS connections, install openssl from either MacPorts or Homebrew. sudo port install rtl-sdr cmake Mac OS X with Homebrew: brew install rtl-sdr cmake pkg-config CMake Get the rtl_433 git repository if needed: git clone https://github.com/merbanan/rtl_433.git Installation using CMake: cd rtl_433/ mkdir build cd build cmake .. make make install Use CMake with -DENABLE_SOAPYSDR=ON (default: AUTO ) to require SoapySDR (e.g. with Debian needs the package libsoapysdr-dev ), use -DENABLE_RTLSDR=OFF (default: ON ) to disable RTL-SDR if needed. E.g. use: cmake -DENABLE_SOAPYSDR=ON .. ::: warning If you experience trouble with SoapySDR when compiling or running: you likely mixed version 0.7 and version 0.8 headers and libs. Purge all SoapySDR packages and source installation from /usr/local. Then install only from packages (version 0.7) or only from source (version 0.8). ::: Windows Visual Studio 2017 You need PothosSDR installed to get RTL-SDR and SoapySDR libraries. Any recent version should work, e.g. 2021.07.25-vc16 . When installing PothosSDR choose \"Add PothosSDR to the system PATH for the current user\". For TLS support (mqtts and influxs) you need OpenSSL installed. E.g. install Chocolatey then open a Command Prompt and choco install openssl Clone the project, e.g. open Visual Studio, change to \"Team Explorer\" > \"Projects\" > \"Manage Connections\" > \"Clone\" and enter https://github.com/merbanan/rtl_433.git If you want to change options, in the menu select \"CMake\" > \"Change CMake Settings\" > \"rtl433\", select e.g. \"x64-Release\", change e.g. \"buildRoot\": \"${workspaceRoot}\\\\build\", \"installRoot\": \"${workspaceRoot}\\\\install\", To start a build use in the menu e.g. \"CMake\" > \"Build all\" Or build at the Command Prompt without opening Visual Studio. Clone rtl_433 sources, then cd rtl_433 mkdir build cd build cmake -G \"Visual Studio 15 2017 Win64\" .. cmake --build . MinGW-w64 You'll probably want librtlsdr and libusb. libusb has prebuilt binaries for windows, librtlsdr needs to be built (or extracted from the PothosSDR installer) librtlsdr taken and adapted from here: https://www.onetransistor.eu/2017/03/compile-librtlsdr-windows-mingw.html install MinGW-w64 and CMake it's easiest if you select the option to include CMake in your path, otherwise you'll need to do this manually download the libusb binaries from https://sourceforge.net/projects/libusb/files/libusb-1.0/ or from https://libusb.info/ take the latest release and then download the .7z file, the other file contains the sources (or 'windows binaries' on the .info website) extract the archive and open the extracted folder copy the contents of the include folder to <mingw_installation_folder>/include copy the mingw64/dll/libusb-1.0.dll.a file to ` /lib copy the mingw64/dll/libusb-1.0.dll file to <mingw_installation_folder>/bin download the source code of librtlsdr https://github.com/steve-m/librtlsdr go into the librtlsdr folder open CMakeLists.txt with an editor that knows unix line endings go to # Find build dependencies (around line 65) and comment/remove the line with find_package(Threads) add the following lines instead: SET(CMAKE_THREAD_LIBS_INIT \"-lpthread\") SET(CMAKE_HAVE_THREADS_LIBRARY 1) SET(Threads_FOUND TRUE) go into the cmake/modules folder and open FindLibUSB.cmake with a text editor find the lines with the following text in them /usr/include/libusb-1.0 /usr/include /usr/local/include add some extra lines to point to the MinGW include folder where you extracted libusb-1.0, making it look like this take note of the \"\" around the folder names, these are needed when there are spaces in the folder name you'll need to find out the exact paths for your system /usr/include/libusb-1.0 /usr/include /usr/local/include \"C:/Program Files/mingw-w64/x86_64-8.1.0-posix-seh-rt_v6-rev0/mingw64/include\" \"C:/Program Files/mingw-w64/x86_64-8.1.0-posix-seh-rt_v6-rev0/mingw64/include/libusb-1.0\" open a MinGW terminal in the librtlsdr folder create build folder and go into it: mkdir build && cd build generate makefiles for MinGW: cmake -G \"MinGW Makefiles\" .. build the librtlsdr library: mingw32-make rtl_433 clone the rtl_433 repository and cd into it create a build folder and go into it: mkdir build && cd build run cmake -G \"MinGW Makefiles\" .. in the build directory run cmake-gui (this is easiest) set the source (the rtl_433 source code directory) and the build directory (one might create a build directory in the source directory) click configure select the grouped and advanced tickboxes go into the librtlsdr config group point the LIBRTLSDR_INCLUDE_DIRS to the include folder of the librtlsdr source point the LIBRTLSDR_LIBRARIES to the librtlsdr.dll.a file in the /build/src folder that's the one you've built earlier start a MinGW terminal and run mingw32-make to build when something in the tests folder doesn't build, you can disable it by commenting out add_subdirectory(tests) in the CMakeLists.txt file in the source folder of rtl_433 rtl_433.exe should be built now you need to place it in the same folder as librtlsdr.dll and libusb-1.0.dll (you should have seen both of them by now) good luck! If your system is missing or you find these steps are outdated please PR an update or open an issue.","title":"Building rtl_433"},{"location":"rtl_433/BUILDING/#building-rtl_433","text":"rtl_433 currently supports these input types: * RTL-SDR (optional, recommended) * SoapySDR (optional) * files: CU8, CS16, CF32 I/Q data, U16 AM data (built-in) * rtl_tcp remote data servers (built-in) Building rtl_433 with RTL-SDR or SoapySDR support is optional but using RTL-SDR is highly recommended. The libraries and header files for RTL-SDR and/or SoapySDR should be installed beforehand.","title":"Building rtl_433"},{"location":"rtl_433/BUILDING/#nightly-builds","text":"Some distributions offer nightly builds.","title":"Nightly builds"},{"location":"rtl_433/BUILDING/#opensuse","text":"openSUSE users of at least Leap 42.3 or Tumbleweed can add the repository with daily builds: $ sudo zypper addrepo -f obs://home:mnhauke:rtl_433:nightly/rtl_433 rtl_433-nightly $ sudo zypper install rtl_433 The usual update mechanism will now keep the rtl_433 version current.","title":"openSUSE"},{"location":"rtl_433/BUILDING/#fedora","text":"Fedora users (31, 32 and Rawhide) can add the following copr repository to get nightly builds: $ sudo dnf copr enable tvass/rtl_433 $ sudo dnf install rtl_433 The usual update mechanism will now keep the rtl_433 version current.","title":"Fedora"},{"location":"rtl_433/BUILDING/#linux-mac-os-x","text":"Depending on your system, you may need to install the following libraries. Debian: If you require TLS connections, install libssl-dev . sudo apt-get install libtool libusb-1.0-0-dev librtlsdr-dev rtl-sdr build-essential cmake pkg-config Centos/Fedora/RHEL with EPEL repo using cmake: If dnf doesn't exist, use yum . If you require TLS connections, install openssl-devel . sudo dnf install libtool libusbx-devel rtl-sdr-devel rtl-sdr cmake Mac OS X with MacPorts: If you require TLS connections, install openssl from either MacPorts or Homebrew. sudo port install rtl-sdr cmake Mac OS X with Homebrew: brew install rtl-sdr cmake pkg-config","title":"Linux / Mac OS X"},{"location":"rtl_433/BUILDING/#cmake","text":"Get the rtl_433 git repository if needed: git clone https://github.com/merbanan/rtl_433.git Installation using CMake: cd rtl_433/ mkdir build cd build cmake .. make make install Use CMake with -DENABLE_SOAPYSDR=ON (default: AUTO ) to require SoapySDR (e.g. with Debian needs the package libsoapysdr-dev ), use -DENABLE_RTLSDR=OFF (default: ON ) to disable RTL-SDR if needed. E.g. use: cmake -DENABLE_SOAPYSDR=ON .. ::: warning If you experience trouble with SoapySDR when compiling or running: you likely mixed version 0.7 and version 0.8 headers and libs. Purge all SoapySDR packages and source installation from /usr/local. Then install only from packages (version 0.7) or only from source (version 0.8). :::","title":"CMake"},{"location":"rtl_433/BUILDING/#windows","text":"","title":"Windows"},{"location":"rtl_433/BUILDING/#visual-studio-2017","text":"You need PothosSDR installed to get RTL-SDR and SoapySDR libraries. Any recent version should work, e.g. 2021.07.25-vc16 . When installing PothosSDR choose \"Add PothosSDR to the system PATH for the current user\". For TLS support (mqtts and influxs) you need OpenSSL installed. E.g. install Chocolatey then open a Command Prompt and choco install openssl Clone the project, e.g. open Visual Studio, change to \"Team Explorer\" > \"Projects\" > \"Manage Connections\" > \"Clone\" and enter https://github.com/merbanan/rtl_433.git If you want to change options, in the menu select \"CMake\" > \"Change CMake Settings\" > \"rtl433\", select e.g. \"x64-Release\", change e.g. \"buildRoot\": \"${workspaceRoot}\\\\build\", \"installRoot\": \"${workspaceRoot}\\\\install\", To start a build use in the menu e.g. \"CMake\" > \"Build all\" Or build at the Command Prompt without opening Visual Studio. Clone rtl_433 sources, then cd rtl_433 mkdir build cd build cmake -G \"Visual Studio 15 2017 Win64\" .. cmake --build .","title":"Visual Studio 2017"},{"location":"rtl_433/BUILDING/#mingw-w64","text":"You'll probably want librtlsdr and libusb. libusb has prebuilt binaries for windows, librtlsdr needs to be built (or extracted from the PothosSDR installer)","title":"MinGW-w64"},{"location":"rtl_433/BUILDING/#librtlsdr","text":"taken and adapted from here: https://www.onetransistor.eu/2017/03/compile-librtlsdr-windows-mingw.html install MinGW-w64 and CMake it's easiest if you select the option to include CMake in your path, otherwise you'll need to do this manually download the libusb binaries from https://sourceforge.net/projects/libusb/files/libusb-1.0/ or from https://libusb.info/ take the latest release and then download the .7z file, the other file contains the sources (or 'windows binaries' on the .info website) extract the archive and open the extracted folder copy the contents of the include folder to <mingw_installation_folder>/include copy the mingw64/dll/libusb-1.0.dll.a file to ` /lib copy the mingw64/dll/libusb-1.0.dll file to <mingw_installation_folder>/bin download the source code of librtlsdr https://github.com/steve-m/librtlsdr go into the librtlsdr folder open CMakeLists.txt with an editor that knows unix line endings go to # Find build dependencies (around line 65) and comment/remove the line with find_package(Threads) add the following lines instead: SET(CMAKE_THREAD_LIBS_INIT \"-lpthread\") SET(CMAKE_HAVE_THREADS_LIBRARY 1) SET(Threads_FOUND TRUE) go into the cmake/modules folder and open FindLibUSB.cmake with a text editor find the lines with the following text in them /usr/include/libusb-1.0 /usr/include /usr/local/include add some extra lines to point to the MinGW include folder where you extracted libusb-1.0, making it look like this take note of the \"\" around the folder names, these are needed when there are spaces in the folder name you'll need to find out the exact paths for your system /usr/include/libusb-1.0 /usr/include /usr/local/include \"C:/Program Files/mingw-w64/x86_64-8.1.0-posix-seh-rt_v6-rev0/mingw64/include\" \"C:/Program Files/mingw-w64/x86_64-8.1.0-posix-seh-rt_v6-rev0/mingw64/include/libusb-1.0\" open a MinGW terminal in the librtlsdr folder create build folder and go into it: mkdir build && cd build generate makefiles for MinGW: cmake -G \"MinGW Makefiles\" .. build the librtlsdr library: mingw32-make","title":"librtlsdr"},{"location":"rtl_433/BUILDING/#rtl_433","text":"clone the rtl_433 repository and cd into it create a build folder and go into it: mkdir build && cd build run cmake -G \"MinGW Makefiles\" .. in the build directory run cmake-gui (this is easiest) set the source (the rtl_433 source code directory) and the build directory (one might create a build directory in the source directory) click configure select the grouped and advanced tickboxes go into the librtlsdr config group point the LIBRTLSDR_INCLUDE_DIRS to the include folder of the librtlsdr source point the LIBRTLSDR_LIBRARIES to the librtlsdr.dll.a file in the /build/src folder that's the one you've built earlier start a MinGW terminal and run mingw32-make to build when something in the tests folder doesn't build, you can disable it by commenting out add_subdirectory(tests) in the CMakeLists.txt file in the source folder of rtl_433 rtl_433.exe should be built now you need to place it in the same folder as librtlsdr.dll and libusb-1.0.dll (you should have seen both of them by now) good luck! If your system is missing or you find these steps are outdated please PR an update or open an issue.","title":"rtl_433"},{"location":"rtl_433/CONTRIBUTING/","text":"Contributing guidelines The rtl_433 project is built on the work of many contributors analyzing, documenting, and coding device support. We are happy to accept your contribution of yet another sensor! Please check if your contribution is following these guidelines to improve the feedback loop and decrease the burden for the maintainers. Commit messages Pull-Requests (PR) will be added as squash commit and the commit message will likely be updated to follow this format. The commit messages should follow the common format of <area_of_work>: <verb> <commit_message> Area of work is optional and may be one of the following: build: for build/build system related work docs: for documentation related work, both in code and readme/docs folder ci: for work related to continuous integration test: for test related work deps: for changes related to (external) dependencies (e.g. soapysdr is updated or mongoose is updated) cosmetics: for housekeeping work, code style changes Don't prefix general work, e.g. adding a decoder should be \"Add support for TheDevice\". Verb may be one of the following: Add: for new additions, e.g. device support Fix: for changes that don't change anything to input/output (security related or bug fixing) Remove: for changes that remove behaviour (e.g. some old algorithms are cleaned up) Change: for changes that modify input/output behaviour (e.g. added checksums, preambles) Improve: for improvements without changes in normal output/behaviour Supporting Additional Devices and Test Data Some device protocol decoders are disabled by default. When testing to see if your device is decoded by rtl_433, use -G 4 to enable all device protocols. This will likely produce false positives, use with caution. The first step in decoding new devices is to record the signals using -S unknown . The signals will be stored individually in files named g NNN _ FFF M_ RRR k.cu8 : Parameter Description NNN signal grabbed number FFF frequency RRR sample rate This file can be played back with rtl_433 -r gNNN_FFFM_RRRk.cu8 . These files are vital for understanding the signal format as well as the message data. Use both analyzers -a and -A to look at the recorded signal and determine the pulse characteristics, e.g. rtl_433 -r gNNN_FFFM_RRRk.cu8 -a -A . Make sure you have recorded a proper set of test signals representing different conditions together with any and all information about the values that the signal should represent. For example, make a note of what temperature and/or humidity is the signal encoding. Ideally, capture a range of data values, such a different temperatures, to make it easy to spot what part of the message is changing. Add the data files, a text file describing the captured signals, pictures of the device and/or a link the manufacturer's page (ideally with specifications) to the rtl_433_tests github repository. Follow the existing structure as best as possible and send a pull request. https://github.com/merbanan/rtl_433_tests Please don't open a new github issue for device support or request decoding help from others until you've added test signals and the description to the repository. The rtl_433_test repository is also used to help test that changes to rtl_433 haven't caused any regressions. Code style Indentation is 4 spaces. Check with clang-format . Indent data_make() nicely tabular and surround it with /* clang-format off */ ... /* clang-format on */ Start your file with a copyright note (indent 4 spaces) like: /** @file Bresser Weather Center 5-in-1. Copyright (C) 2019 Christian W. Zuckschwerdt <zany@triq.net> This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. */ Name your decode function foobar_decode . Put documentation (markdown, no indent) before the decode function: /** Bresser Weather Center 7-in-1, outdoor sensor. ...supported models etc. Data layout: IIII F TTT HH CC - I: 16 bit ID - F: 4 bit flags - T: 12 bit temperature, scale 10 - H: 8 bit humidity - C: 8 bit CRC-8, poly 0x81 Format string: ID:16h FLAGS:4h TEMP:12h HUMI:8h CRC:8h ...Decoding notes like endianness, signedness */ The keys in data_make() need to contain - \"model\" , short unique key for this decoder - \"id\", a unique sensor ID - \"mic\" , if applicable the integrity check, e.g. \"PARITY\" , \"SUM\" , \"CRC\" , or \"DIGEST\" . See JSON Data fields for common keys.","title":"Contributing guidelines"},{"location":"rtl_433/CONTRIBUTING/#contributing-guidelines","text":"The rtl_433 project is built on the work of many contributors analyzing, documenting, and coding device support. We are happy to accept your contribution of yet another sensor! Please check if your contribution is following these guidelines to improve the feedback loop and decrease the burden for the maintainers.","title":"Contributing guidelines"},{"location":"rtl_433/CONTRIBUTING/#commit-messages","text":"Pull-Requests (PR) will be added as squash commit and the commit message will likely be updated to follow this format. The commit messages should follow the common format of <area_of_work>: <verb> <commit_message> Area of work is optional and may be one of the following: build: for build/build system related work docs: for documentation related work, both in code and readme/docs folder ci: for work related to continuous integration test: for test related work deps: for changes related to (external) dependencies (e.g. soapysdr is updated or mongoose is updated) cosmetics: for housekeeping work, code style changes Don't prefix general work, e.g. adding a decoder should be \"Add support for TheDevice\". Verb may be one of the following: Add: for new additions, e.g. device support Fix: for changes that don't change anything to input/output (security related or bug fixing) Remove: for changes that remove behaviour (e.g. some old algorithms are cleaned up) Change: for changes that modify input/output behaviour (e.g. added checksums, preambles) Improve: for improvements without changes in normal output/behaviour","title":"Commit messages"},{"location":"rtl_433/CONTRIBUTING/#supporting-additional-devices-and-test-data","text":"Some device protocol decoders are disabled by default. When testing to see if your device is decoded by rtl_433, use -G 4 to enable all device protocols. This will likely produce false positives, use with caution. The first step in decoding new devices is to record the signals using -S unknown . The signals will be stored individually in files named g NNN _ FFF M_ RRR k.cu8 : Parameter Description NNN signal grabbed number FFF frequency RRR sample rate This file can be played back with rtl_433 -r gNNN_FFFM_RRRk.cu8 . These files are vital for understanding the signal format as well as the message data. Use both analyzers -a and -A to look at the recorded signal and determine the pulse characteristics, e.g. rtl_433 -r gNNN_FFFM_RRRk.cu8 -a -A . Make sure you have recorded a proper set of test signals representing different conditions together with any and all information about the values that the signal should represent. For example, make a note of what temperature and/or humidity is the signal encoding. Ideally, capture a range of data values, such a different temperatures, to make it easy to spot what part of the message is changing. Add the data files, a text file describing the captured signals, pictures of the device and/or a link the manufacturer's page (ideally with specifications) to the rtl_433_tests github repository. Follow the existing structure as best as possible and send a pull request. https://github.com/merbanan/rtl_433_tests Please don't open a new github issue for device support or request decoding help from others until you've added test signals and the description to the repository. The rtl_433_test repository is also used to help test that changes to rtl_433 haven't caused any regressions.","title":"Supporting Additional Devices and Test Data"},{"location":"rtl_433/CONTRIBUTING/#code-style","text":"Indentation is 4 spaces. Check with clang-format . Indent data_make() nicely tabular and surround it with /* clang-format off */ ... /* clang-format on */ Start your file with a copyright note (indent 4 spaces) like: /** @file Bresser Weather Center 5-in-1. Copyright (C) 2019 Christian W. Zuckschwerdt <zany@triq.net> This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. */ Name your decode function foobar_decode . Put documentation (markdown, no indent) before the decode function: /** Bresser Weather Center 7-in-1, outdoor sensor. ...supported models etc. Data layout: IIII F TTT HH CC - I: 16 bit ID - F: 4 bit flags - T: 12 bit temperature, scale 10 - H: 8 bit humidity - C: 8 bit CRC-8, poly 0x81 Format string: ID:16h FLAGS:4h TEMP:12h HUMI:8h CRC:8h ...Decoding notes like endianness, signedness */ The keys in data_make() need to contain - \"model\" , short unique key for this decoder - \"id\", a unique sensor ID - \"mic\" , if applicable the integrity check, e.g. \"PARITY\" , \"SUM\" , \"CRC\" , or \"DIGEST\" . See JSON Data fields for common keys.","title":"Code style"},{"location":"rtl_433/DATA_FORMAT/","text":"JSON Data fields See also the discussion and rationale in https://github.com/merbanan/rtl_433/pull/827 Message Data These fields are the primary data fields containing the most basic message data and used to identify the specific device. For some devices these are the only fields contained in the message, as the message itself constitutes an event from this particular device model. time (string) (Required) Time stamp. String containing date and time of when the message was received. Format and timezone is dependent on current locale unless options like -M time:unix or -M time:iso and -M time:utc are used. type (string) (Optional) Classification of the general device type. Currently only used for \"TPMS\" . model (string) (Required) Device model. Human readable string concisely describing the device by manufacturer name and manufacturers model designation according to the following syntax: \"<Manufacturer>-<Model>\" . It is common for devices to be sold under different brands, however the Original Equipment Manufacturer name shall be used, where possible to identify. Avoid redundant word like \"sensor\", \"wireless\" etc. unless it is part of the manufacturers model designation. Avoid adding device type designations like \"Switch\", \"Temperature\", \"Thermostat\", \"Weather Station\" etc. Device type can be inferred from the data content. Avoid all non-alphanumeric characters, especially: \"/&$*#+[]()\" . Length of model string should be less than 32 characters. subtype (string) (Optional) Device type or function in a common protocol. Examples are various sensors, triggers, keyfob in wireless security. id (integer, rarely string) (Optional) Device identification. Used to differentiate between devices of same model . Depending on device model it may be a non-volatile value programmed into the device, a volatile value that changes at each power on (or battery change), or a value configurable by user e.g. by switch or jumpers. No assumptions should be made to the id value other than it contains a unique sequence of alphanumeric characters. Length of id should be less than 16 characters. channel (integer, rarely string) (Optional) Secondary device identification. For devices with more than one identification value (e.g. both an internal value and a switch). mic (string) (Optional) Message integrity check. String describing the method used for ensuring the data integrity of the message. Protocol decoders for devices without mic will be disabled by default as they are prone to excessive false positives. Possible values: \"CRC\" - Cyclic Redundancy Check. \"CHECKSUM\" - Accumulated sum of data. \"PARITY\" - Parity bit (odd, even, multiple) Common Device Data Various data fields, which are common across devices of different types. battery_ok (double) (Optional) Battery status indication as a level between 0 (empty) and 1 (full). If the sensor can only report a binary status the value shall be 1 for \"OK\" and 0 for \"LOW\". battery_V ( battery_mV ) (double) (Optional) Battery level in Volts. Should be supplemented by battery_ok status indication if possible. Sensor Data Due to the large variance in sensor types this list of common values is non-exhaustive. Additional data value fields should follow the form: <Type>_<Unit> , where Unit should be in sensors native units insofar possible with no conversion. Automatic unit conversion can be performed with the -C si or -C customary option. Examples: temperature_C ( temperature_F ) (double) (Optional) Temperature from a temperature sensor in degrees Celsius (Fahrenheit). setpoint_C ( setpoint_F ) (double) (Optional) Thermal set point of a thermostat device in degrees Celsius (Fahrenheit). humidity (double) (Optional) Humidity from a hygrometer sensor in % relative humidity moisture (double) (Optional) Moisture from a soil probe in % relative saturation wind_dir_deg (double) (Optional) Wind direction from wind sensor in compass direction degrees. wind_avg_m_s ( wind_avg_km_h , wind_avg_mi_h ) (double) (Optional) Average wind speed from wind sensor in m/s. Averaging time is sensor dependent. wind_max_m_s ( wind_max_km_h , wind_max_mi_h ) (double) (Optional) Gust wind speed from wind sensor in m/s. rain_mm ( rain_in ) (double) (Optional) Rainfall from rain sensor in mm (inches) since last reset. Reset method is device dependent. rain_rate_mm_h ( rain_rate_in_h ) (double) (Optional) Rainfall rate from rain sensor in mm per hour (inches per hour). pressure_hPa ( pressure_psi ) (double) (Optional) Air pressure from barometer or Tire Pressure Monitor in hPa (psi)","title":"JSON Data fields"},{"location":"rtl_433/DATA_FORMAT/#json-data-fields","text":"See also the discussion and rationale in https://github.com/merbanan/rtl_433/pull/827","title":"JSON Data fields"},{"location":"rtl_433/DATA_FORMAT/#message-data","text":"These fields are the primary data fields containing the most basic message data and used to identify the specific device. For some devices these are the only fields contained in the message, as the message itself constitutes an event from this particular device model. time (string) (Required) Time stamp. String containing date and time of when the message was received. Format and timezone is dependent on current locale unless options like -M time:unix or -M time:iso and -M time:utc are used. type (string) (Optional) Classification of the general device type. Currently only used for \"TPMS\" . model (string) (Required) Device model. Human readable string concisely describing the device by manufacturer name and manufacturers model designation according to the following syntax: \"<Manufacturer>-<Model>\" . It is common for devices to be sold under different brands, however the Original Equipment Manufacturer name shall be used, where possible to identify. Avoid redundant word like \"sensor\", \"wireless\" etc. unless it is part of the manufacturers model designation. Avoid adding device type designations like \"Switch\", \"Temperature\", \"Thermostat\", \"Weather Station\" etc. Device type can be inferred from the data content. Avoid all non-alphanumeric characters, especially: \"/&$*#+[]()\" . Length of model string should be less than 32 characters. subtype (string) (Optional) Device type or function in a common protocol. Examples are various sensors, triggers, keyfob in wireless security. id (integer, rarely string) (Optional) Device identification. Used to differentiate between devices of same model . Depending on device model it may be a non-volatile value programmed into the device, a volatile value that changes at each power on (or battery change), or a value configurable by user e.g. by switch or jumpers. No assumptions should be made to the id value other than it contains a unique sequence of alphanumeric characters. Length of id should be less than 16 characters. channel (integer, rarely string) (Optional) Secondary device identification. For devices with more than one identification value (e.g. both an internal value and a switch). mic (string) (Optional) Message integrity check. String describing the method used for ensuring the data integrity of the message. Protocol decoders for devices without mic will be disabled by default as they are prone to excessive false positives. Possible values: \"CRC\" - Cyclic Redundancy Check. \"CHECKSUM\" - Accumulated sum of data. \"PARITY\" - Parity bit (odd, even, multiple)","title":"Message Data"},{"location":"rtl_433/DATA_FORMAT/#common-device-data","text":"Various data fields, which are common across devices of different types. battery_ok (double) (Optional) Battery status indication as a level between 0 (empty) and 1 (full). If the sensor can only report a binary status the value shall be 1 for \"OK\" and 0 for \"LOW\". battery_V ( battery_mV ) (double) (Optional) Battery level in Volts. Should be supplemented by battery_ok status indication if possible.","title":"Common Device Data"},{"location":"rtl_433/DATA_FORMAT/#sensor-data","text":"Due to the large variance in sensor types this list of common values is non-exhaustive. Additional data value fields should follow the form: <Type>_<Unit> , where Unit should be in sensors native units insofar possible with no conversion. Automatic unit conversion can be performed with the -C si or -C customary option. Examples: temperature_C ( temperature_F ) (double) (Optional) Temperature from a temperature sensor in degrees Celsius (Fahrenheit). setpoint_C ( setpoint_F ) (double) (Optional) Thermal set point of a thermostat device in degrees Celsius (Fahrenheit). humidity (double) (Optional) Humidity from a hygrometer sensor in % relative humidity moisture (double) (Optional) Moisture from a soil probe in % relative saturation wind_dir_deg (double) (Optional) Wind direction from wind sensor in compass direction degrees. wind_avg_m_s ( wind_avg_km_h , wind_avg_mi_h ) (double) (Optional) Average wind speed from wind sensor in m/s. Averaging time is sensor dependent. wind_max_m_s ( wind_max_km_h , wind_max_mi_h ) (double) (Optional) Gust wind speed from wind sensor in m/s. rain_mm ( rain_in ) (double) (Optional) Rainfall from rain sensor in mm (inches) since last reset. Reset method is device dependent. rain_rate_mm_h ( rain_rate_in_h ) (double) (Optional) Rainfall rate from rain sensor in mm per hour (inches per hour). pressure_hPa ( pressure_psi ) (double) (Optional) Air pressure from barometer or Tire Pressure Monitor in hPa (psi)","title":"Sensor Data"},{"location":"rtl_433/HARDWARE/","text":"Hardware tested with rtl_433 rtl_433 is known to work with or tested with the following SDR hardware: RTL-SDR Actively tested and supported are Realtek RTL2832 based DVB dongles (and other similar devices supported by RTL-SDR). See also RTL-SDR . SoapySDR Actively tested and supported are - LimeSDR USB - LimeSDR mini - LimeNet Micro - PlutoSDR - SDRplay (RSP1A tested) - HackRF One (reported, we don't have a receiver) - SoapyRemote LimeSDR and LimeNet engineering samples were kindly provided by MyriadRf . See also SoapySDR . Not supported Ultra cheap 1-bit (OOK) receivers, and antenna-on-a-raspi-pin CC1101, and alike special purpose / non general SDR chips","title":"Hardware tested with rtl_433"},{"location":"rtl_433/HARDWARE/#hardware-tested-with-rtl_433","text":"rtl_433 is known to work with or tested with the following SDR hardware:","title":"Hardware tested with rtl_433"},{"location":"rtl_433/HARDWARE/#rtl-sdr","text":"Actively tested and supported are Realtek RTL2832 based DVB dongles (and other similar devices supported by RTL-SDR). See also RTL-SDR .","title":"RTL-SDR"},{"location":"rtl_433/HARDWARE/#soapysdr","text":"Actively tested and supported are - LimeSDR USB - LimeSDR mini - LimeNet Micro - PlutoSDR - SDRplay (RSP1A tested) - HackRF One (reported, we don't have a receiver) - SoapyRemote LimeSDR and LimeNet engineering samples were kindly provided by MyriadRf . See also SoapySDR .","title":"SoapySDR"},{"location":"rtl_433/HARDWARE/#not-supported","text":"Ultra cheap 1-bit (OOK) receivers, and antenna-on-a-raspi-pin CC1101, and alike special purpose / non general SDR chips","title":"Not supported"},{"location":"rtl_433/INTEGRATION/","text":"Integration Integration of rtl_433 output into various home automation gateways. ::: tip If you are a user of one these systems, please help to confirm and extend the information here. ::: openHAB openHAB - open source automation software for your home See the wiki page https://github.com/merbanan/rtl_433/wiki/How-to-integrate-rtl_433-sensors-into-openHAB-via-MQTT Some help comes from https://community.openhab.org/t/rtl-433-to-mqtt/80652/3 Run rtl_433 -F \"mqtt://192.168.178.42:1883,retain=0,devices=sensors/rtl_433/P[protocol]/C[channel]\" This produces some topics in the broker like this: sensors/rtl_433/P25/C1/id 147 sensors/rtl_433/P25/C1/temperature_C 33.200001 sensors/rtl_433/P25/C1/rain_mm 107.699997 sensors/rtl_433/P25/C1/battery_ok 1 sensors/rtl_433/P25/C1/mic CRC You can easily set up some MQTT things then: Bridge mqtt:broker:My-MQTT \"MQTT Broker\" @ \"RTL433\" [ host=\"192.168.x.x\", secure=false, port=1883, qos=0, retain=false, clientid=\"Oh2Mqtt2Thing\", keep_alive_time=30000, reconnect_time=60000 ] { Thing topic RTL_433 \"433MHz Empf\u00e4nger\" @ \"RTL433\" { Channels: Type number : temp \"Temperatur\" [ stateTopic=\"sensors/rtl_433/P25/C1/temperature_C\" ] Type number : hum \"Luftfeuchtigkeit\" [ stateTopic=\"sensors/rtl_433/P25/C1/humidity\" ] Type switch : batt \"Battery schwach\" [ stateTopic=\"sensors/rtl_433/P25/C1/battery\", transformationPattern=\"MAP:battery.map\"] } } Home Assistant Home Assistant - Open source home automation Home Assistant has good MQTT support and can read rtl_433 event topics. Assuming rtl_433 is started with rtl_433 -C si -M time:unix:usec:utc -F mqtt you can set up temperature and humidity sensors in Home Assistant with sensor: - name: temperature_raw state_topic: \"rtl_433/host/devices/Prologue-TH/5/3/+/temperature_C\" platform: mqtt device_class: temperature unit_of_measurement: \"\u00b0C\" force_update: true expire_after: 610 - name: humidity_raw state_topic: \"rtl_433/host/devices/Prologue-TH/5/3/+/humidity\" platform: mqtt device_class: humidity unit_of_measurement: \"%\" force_update: true expire_after: 610 You may want to postprocess the received values with something like sensor: - name: temperature entity_id: sensor.temperature_raw platform: filter filters: - filter: outlier window_size: 2 radius: 3.0 See the Home Assistant documentation for more information. See also rtl_433_mqtt_hass.py MQTT Home Assistant auto discovery. Domoticz Domoticz - Home Automation System Domoticz has built-in support for reading from rtl_433 using pipes. There is also a newer plugin using MQTT: enesbcs/pyrtl433 . ::: warning Testing and example needed ::: NodeRED NodeRED - Flow-based programming for the Internet of Things Node RED has built-in support for reading from MQTT and thus rtl_433 events. ::: warning Example needed ::: Databases You likely need to filter and transform rtl_433's output before sending it to a database. It's recommended you read the JSON data and process it to your specific requirements. Some example pipes/relays for rtl_433 JSON data. Should work with Python 2 and also Python 3. The pipe examples read JSON output from rtl_433 using a pipe, i.e. rtl_433 -F json ... | rtl_433_statsd_pipe.py The relay examples consumes the (UDP) Syslog output from rtl_433 (or a legacy plain JSON datagram). Basically run rtl_433 with -F syslog:127.0.0.1:1433 and the relay script as an unrelated process, i.e. rtl_433_mqtt_relay.py & rtl_433 -F syslog:127.0.0.1:1433 SQL An example to push data to SQL is at Domifry/RTL_433_SQL_Connection , see also #1828 . RRD See rtl_433_rrd_relay.py Statsd See rtl_433_statsd_pipe.py See rtl_433_statsd_relay.py Collectd See rtl_433_collectd_pipe.py Graphite See rtl_433_graphite_relay.py InfluxDB There is built-in support for an InfluxDB output. Specify an InfluxDB 2.0 server with e.g. rtl_433 -F \"influx://localhost:9999/api/v2/write?org=<org>&bucket=<bucket>,token=<authtoken>\" Specify an InfluxDB 1.x server with e.g. rtl_433 -F \"influx://localhost:8086/write?db=<db>&p=<password>&u=<user>\" It is recommended to additionally use the option -M time:unix:usec:utc for correct timestamps in InfluxDB. If you want to filter messages before they are inserted into the InfluxDB or if you want to transform the data see rtl_433_influxdb_relay.py for an example script. The rtl433_influx project allows to dump the JSON output of rtl_433 into InfluxDB. InfluxDB also comes with MQTT integration through Telegraf, see MQTT Monitoring and MQTT Consumer Input Plugin . MySQL TBD. Sqlite TBD.","title":"Integration"},{"location":"rtl_433/INTEGRATION/#integration","text":"Integration of rtl_433 output into various home automation gateways. ::: tip If you are a user of one these systems, please help to confirm and extend the information here. :::","title":"Integration"},{"location":"rtl_433/INTEGRATION/#openhab","text":"openHAB - open source automation software for your home See the wiki page https://github.com/merbanan/rtl_433/wiki/How-to-integrate-rtl_433-sensors-into-openHAB-via-MQTT Some help comes from https://community.openhab.org/t/rtl-433-to-mqtt/80652/3 Run rtl_433 -F \"mqtt://192.168.178.42:1883,retain=0,devices=sensors/rtl_433/P[protocol]/C[channel]\" This produces some topics in the broker like this: sensors/rtl_433/P25/C1/id 147 sensors/rtl_433/P25/C1/temperature_C 33.200001 sensors/rtl_433/P25/C1/rain_mm 107.699997 sensors/rtl_433/P25/C1/battery_ok 1 sensors/rtl_433/P25/C1/mic CRC You can easily set up some MQTT things then: Bridge mqtt:broker:My-MQTT \"MQTT Broker\" @ \"RTL433\" [ host=\"192.168.x.x\", secure=false, port=1883, qos=0, retain=false, clientid=\"Oh2Mqtt2Thing\", keep_alive_time=30000, reconnect_time=60000 ] { Thing topic RTL_433 \"433MHz Empf\u00e4nger\" @ \"RTL433\" { Channels: Type number : temp \"Temperatur\" [ stateTopic=\"sensors/rtl_433/P25/C1/temperature_C\" ] Type number : hum \"Luftfeuchtigkeit\" [ stateTopic=\"sensors/rtl_433/P25/C1/humidity\" ] Type switch : batt \"Battery schwach\" [ stateTopic=\"sensors/rtl_433/P25/C1/battery\", transformationPattern=\"MAP:battery.map\"] } }","title":"openHAB"},{"location":"rtl_433/INTEGRATION/#home-assistant","text":"Home Assistant - Open source home automation Home Assistant has good MQTT support and can read rtl_433 event topics. Assuming rtl_433 is started with rtl_433 -C si -M time:unix:usec:utc -F mqtt you can set up temperature and humidity sensors in Home Assistant with sensor: - name: temperature_raw state_topic: \"rtl_433/host/devices/Prologue-TH/5/3/+/temperature_C\" platform: mqtt device_class: temperature unit_of_measurement: \"\u00b0C\" force_update: true expire_after: 610 - name: humidity_raw state_topic: \"rtl_433/host/devices/Prologue-TH/5/3/+/humidity\" platform: mqtt device_class: humidity unit_of_measurement: \"%\" force_update: true expire_after: 610 You may want to postprocess the received values with something like sensor: - name: temperature entity_id: sensor.temperature_raw platform: filter filters: - filter: outlier window_size: 2 radius: 3.0 See the Home Assistant documentation for more information. See also rtl_433_mqtt_hass.py MQTT Home Assistant auto discovery.","title":"Home Assistant"},{"location":"rtl_433/INTEGRATION/#domoticz","text":"Domoticz - Home Automation System Domoticz has built-in support for reading from rtl_433 using pipes. There is also a newer plugin using MQTT: enesbcs/pyrtl433 . ::: warning Testing and example needed :::","title":"Domoticz"},{"location":"rtl_433/INTEGRATION/#nodered","text":"NodeRED - Flow-based programming for the Internet of Things Node RED has built-in support for reading from MQTT and thus rtl_433 events. ::: warning Example needed :::","title":"NodeRED"},{"location":"rtl_433/INTEGRATION/#databases","text":"You likely need to filter and transform rtl_433's output before sending it to a database. It's recommended you read the JSON data and process it to your specific requirements. Some example pipes/relays for rtl_433 JSON data. Should work with Python 2 and also Python 3. The pipe examples read JSON output from rtl_433 using a pipe, i.e. rtl_433 -F json ... | rtl_433_statsd_pipe.py The relay examples consumes the (UDP) Syslog output from rtl_433 (or a legacy plain JSON datagram). Basically run rtl_433 with -F syslog:127.0.0.1:1433 and the relay script as an unrelated process, i.e. rtl_433_mqtt_relay.py & rtl_433 -F syslog:127.0.0.1:1433","title":"Databases"},{"location":"rtl_433/INTEGRATION/#sql","text":"An example to push data to SQL is at Domifry/RTL_433_SQL_Connection , see also #1828 .","title":"SQL"},{"location":"rtl_433/INTEGRATION/#rrd","text":"See rtl_433_rrd_relay.py","title":"RRD"},{"location":"rtl_433/INTEGRATION/#statsd","text":"See rtl_433_statsd_pipe.py See rtl_433_statsd_relay.py","title":"Statsd"},{"location":"rtl_433/INTEGRATION/#collectd","text":"See rtl_433_collectd_pipe.py","title":"Collectd"},{"location":"rtl_433/INTEGRATION/#graphite","text":"See rtl_433_graphite_relay.py","title":"Graphite"},{"location":"rtl_433/INTEGRATION/#influxdb","text":"There is built-in support for an InfluxDB output. Specify an InfluxDB 2.0 server with e.g. rtl_433 -F \"influx://localhost:9999/api/v2/write?org=<org>&bucket=<bucket>,token=<authtoken>\" Specify an InfluxDB 1.x server with e.g. rtl_433 -F \"influx://localhost:8086/write?db=<db>&p=<password>&u=<user>\" It is recommended to additionally use the option -M time:unix:usec:utc for correct timestamps in InfluxDB. If you want to filter messages before they are inserted into the InfluxDB or if you want to transform the data see rtl_433_influxdb_relay.py for an example script. The rtl433_influx project allows to dump the JSON output of rtl_433 into InfluxDB. InfluxDB also comes with MQTT integration through Telegraf, see MQTT Monitoring and MQTT Consumer Input Plugin .","title":"InfluxDB"},{"location":"rtl_433/INTEGRATION/#mysql","text":"TBD.","title":"MySQL"},{"location":"rtl_433/INTEGRATION/#sqlite","text":"TBD.","title":"Sqlite"},{"location":"rtl_433/IQ_FORMATS/","text":"Introduction to I/Q formats SDR data is exchanged and saved in different formats. There are formats for raw I/Q sample data and formats with demodulated pulse data. I/Q sample data formats I/Q stands for \"In-phase / Quadrature\", the raw data format used by SDR receivers and transmitters. A sample consists of an I and Q value, each commonly of 8, 12, or 16-bit. This is called \"interleaved\" in audio or video data. The data can be processed similar to a two-channel audio signal, although at a much higher sample rate. ::: tip Common sample rates with RTL-SDR receivers are 250 kHz and 1024 kHz, also 1 MHz (1000 kHz). ::: The nature of an I/Q sample allows to use a bandwidth equal to the sample rate (with a purely real signal the Nyquist\u2013Shannon sampling theorem would only allow half the bandwidth). Generally the data formats are header- (and thus metadata-)less, the used center frequency and sample rate must be transferred separately or encoded in the filename. Formats differ in sample-(bit-)width and (bit-)number format, used bit-widths are 4, 8, 12, 16, 32, and 64, bit-formats are unsigned integer, signed integer, and float: .cu4 : Complex (I/Q), Unsigned integer, 4-bit per value (8 bit per sample) .cs4 : Signed integer .cu8 ( .data .complex16u ): 8-bit per value (16 bit per sample) .cs8 ( .complex16s ) .cu12 : 12-bit per value (24 bit per sample) .cs12 .cu16 : 16-bit per value (32 bit per sample) .cs16 .cu32 : 32-bit per value (64 bit per sample) .cs32 .cu64 : 64-bit per value (128 bit per sample) .cs64 .cf32 ( .cfile .complex ): Float, 32-bit per value (64 bit per sample) .cf64 : Double Float, 64-bit per value (128 bit per sample) Also used but rarely supported are audio files containing I/Q data: - .wav - .bwf : Broadcast Wave Format The \"native\" format for RTL-SDR receivers is .cu8 , for other receivers likely .cs16 . Most receivers only sample with 12-bit per channel, using .cs12 will be more compact although not as widely supported. The rtl_433 program supports most of these formats and allows to read, write, or convert them, e.g.: rtl_433 -w FILE.cu8 : write received data to sample file rtl_433 -w FILE.cu8 FILE.cs16 : convert sample file Pulse data formats Demodulated data can be stored in a readable text-format with file extension .ook , also .fsk or .psk . A header contains meta data about the demodulation (2-ASK / ook, 2-FSK / fsk, ...) and the extension is informational only. Each regular line in the file format contains a number for pulse duration and a number for gap duration. For FSK or PSK demodulation these are mark and space duration. There is also the .vcd format which can carry the same information and might be useful with traditional signal data software. It can optionally also encode more than two states, e.g. (4-FSK), this isn't used however. A very compact format is rfraw: , usually just one line of code. This format encodes quantized pulse/gap durations with a maximum of eight different durations. There are also formats for demodulated but \"raw\" amplitude or frequency, e.g. .am.s16 , .fm.s16 similar to the above formats but with only one \"channel\". The SigRok .sr format is a Zip and combines multiple files for easy viewing with SigRok Pulseview. ::: tip Install SigRok Pulseview and write a SigRok file. The overwrite option (uppercase -W ) will automatically open Pulseview. ::: The rtl_433 program can create all these formats from live data or sample files, e.g.: rtl_433 -w FILE.ook : write received data to ook file rtl_433 -w FILE.ook FILE.cu8 : convert sample file to ook file File name meta data In addition to the file extension meta data about the center frequency and sample rate are encoded in the filename. 433.92M : A decimal number suffixed with M denotes the center frequency 1000k : A decimal number suffixed with k denotes the sample rate Each part of the filename must be separated by an underscore. Even with low frequencies or high sample rates the suffix is fixed, ::: warning 433920k is not a valid frequency specification and 1M is not a valid sample rate specification in filenames. ::: File viewers All raw I/Q sample data formats and most demodulated pulse data formats can be visualized with the triq I/Q Spectrogram and Pulsedata viewer .","title":"Introduction to I/Q formats"},{"location":"rtl_433/IQ_FORMATS/#introduction-to-iq-formats","text":"SDR data is exchanged and saved in different formats. There are formats for raw I/Q sample data and formats with demodulated pulse data.","title":"Introduction to I/Q formats"},{"location":"rtl_433/IQ_FORMATS/#iq-sample-data-formats","text":"I/Q stands for \"In-phase / Quadrature\", the raw data format used by SDR receivers and transmitters. A sample consists of an I and Q value, each commonly of 8, 12, or 16-bit. This is called \"interleaved\" in audio or video data. The data can be processed similar to a two-channel audio signal, although at a much higher sample rate. ::: tip Common sample rates with RTL-SDR receivers are 250 kHz and 1024 kHz, also 1 MHz (1000 kHz). ::: The nature of an I/Q sample allows to use a bandwidth equal to the sample rate (with a purely real signal the Nyquist\u2013Shannon sampling theorem would only allow half the bandwidth). Generally the data formats are header- (and thus metadata-)less, the used center frequency and sample rate must be transferred separately or encoded in the filename. Formats differ in sample-(bit-)width and (bit-)number format, used bit-widths are 4, 8, 12, 16, 32, and 64, bit-formats are unsigned integer, signed integer, and float: .cu4 : Complex (I/Q), Unsigned integer, 4-bit per value (8 bit per sample) .cs4 : Signed integer .cu8 ( .data .complex16u ): 8-bit per value (16 bit per sample) .cs8 ( .complex16s ) .cu12 : 12-bit per value (24 bit per sample) .cs12 .cu16 : 16-bit per value (32 bit per sample) .cs16 .cu32 : 32-bit per value (64 bit per sample) .cs32 .cu64 : 64-bit per value (128 bit per sample) .cs64 .cf32 ( .cfile .complex ): Float, 32-bit per value (64 bit per sample) .cf64 : Double Float, 64-bit per value (128 bit per sample) Also used but rarely supported are audio files containing I/Q data: - .wav - .bwf : Broadcast Wave Format The \"native\" format for RTL-SDR receivers is .cu8 , for other receivers likely .cs16 . Most receivers only sample with 12-bit per channel, using .cs12 will be more compact although not as widely supported. The rtl_433 program supports most of these formats and allows to read, write, or convert them, e.g.: rtl_433 -w FILE.cu8 : write received data to sample file rtl_433 -w FILE.cu8 FILE.cs16 : convert sample file","title":"I/Q sample data formats"},{"location":"rtl_433/IQ_FORMATS/#pulse-data-formats","text":"Demodulated data can be stored in a readable text-format with file extension .ook , also .fsk or .psk . A header contains meta data about the demodulation (2-ASK / ook, 2-FSK / fsk, ...) and the extension is informational only. Each regular line in the file format contains a number for pulse duration and a number for gap duration. For FSK or PSK demodulation these are mark and space duration. There is also the .vcd format which can carry the same information and might be useful with traditional signal data software. It can optionally also encode more than two states, e.g. (4-FSK), this isn't used however. A very compact format is rfraw: , usually just one line of code. This format encodes quantized pulse/gap durations with a maximum of eight different durations. There are also formats for demodulated but \"raw\" amplitude or frequency, e.g. .am.s16 , .fm.s16 similar to the above formats but with only one \"channel\". The SigRok .sr format is a Zip and combines multiple files for easy viewing with SigRok Pulseview. ::: tip Install SigRok Pulseview and write a SigRok file. The overwrite option (uppercase -W ) will automatically open Pulseview. ::: The rtl_433 program can create all these formats from live data or sample files, e.g.: rtl_433 -w FILE.ook : write received data to ook file rtl_433 -w FILE.ook FILE.cu8 : convert sample file to ook file","title":"Pulse data formats"},{"location":"rtl_433/IQ_FORMATS/#file-name-meta-data","text":"In addition to the file extension meta data about the center frequency and sample rate are encoded in the filename. 433.92M : A decimal number suffixed with M denotes the center frequency 1000k : A decimal number suffixed with k denotes the sample rate Each part of the filename must be separated by an underscore. Even with low frequencies or high sample rates the suffix is fixed, ::: warning 433920k is not a valid frequency specification and 1M is not a valid sample rate specification in filenames. :::","title":"File name meta data"},{"location":"rtl_433/IQ_FORMATS/#file-viewers","text":"All raw I/Q sample data formats and most demodulated pulse data formats can be visualized with the triq I/Q Spectrogram and Pulsedata viewer .","title":"File viewers"},{"location":"rtl_433/LINKS/","text":"Links to tools and related projects SDR Inputs/Drivers RTL-SDR SoapySDR Analysis SigRok PulseView Audacity iqSpectrogram to visualize sample files BitBench to analyze data formats Related projects ShinySDR Web remote-controllable SDR receiver application supporting multiple simultaneous hardware devices and demodulators, including rtl_433 and other decoding tools. HASS addon to convert rtl433 output to mqtt rtl_fl2k_433 an RX/TX prototyping tool. Aims to be a comfortable, GUI-based bridge between RTL-SDR dongles on RX side and cheap FL2K dongles on TX side. Currently, the GUI is available for Win64 only. rtl_433 with Snap7 to inject weather data to industrial control system (PLC - Siemens S7-300 or compatible VIPA) coming from Weather station WH1080. Domoticz rtl_433 is usable from domoticz with a quite good integration: Domoticz launch rtl_433 with no data detection (relaunch rtl_433 if so) and process csv output format. All command line arguments are usable. WeeWx the weewx-sdr driver gets data from rtl_433 and feeds it into weewx. from there the data can be combined with data from other sources, displayed using any of the many weewx skins, and/or uploaded to many different web services. the first weewx-sdr release was in 2016. S.a. https://github.com/matthewwall/weewx-sdr https://github.com/weewx/weewx/wiki#skins https://github.com/weewx/weewx/wiki#uploaders rtl_snr : snr is a pair of equivalent C and Python programs that catalog and analyze signal-to-noise ratios from devices seen by RTL_SDR dongles and logged in JSON format by rtl_433.","title":"Links to tools and related projects"},{"location":"rtl_433/LINKS/#links-to-tools-and-related-projects","text":"","title":"Links to tools and related projects"},{"location":"rtl_433/LINKS/#sdr-inputsdrivers","text":"RTL-SDR SoapySDR","title":"SDR Inputs/Drivers"},{"location":"rtl_433/LINKS/#analysis","text":"SigRok PulseView Audacity iqSpectrogram to visualize sample files BitBench to analyze data formats","title":"Analysis"},{"location":"rtl_433/LINKS/#related-projects","text":"ShinySDR Web remote-controllable SDR receiver application supporting multiple simultaneous hardware devices and demodulators, including rtl_433 and other decoding tools. HASS addon to convert rtl433 output to mqtt rtl_fl2k_433 an RX/TX prototyping tool. Aims to be a comfortable, GUI-based bridge between RTL-SDR dongles on RX side and cheap FL2K dongles on TX side. Currently, the GUI is available for Win64 only. rtl_433 with Snap7 to inject weather data to industrial control system (PLC - Siemens S7-300 or compatible VIPA) coming from Weather station WH1080. Domoticz rtl_433 is usable from domoticz with a quite good integration: Domoticz launch rtl_433 with no data detection (relaunch rtl_433 if so) and process csv output format. All command line arguments are usable. WeeWx the weewx-sdr driver gets data from rtl_433 and feeds it into weewx. from there the data can be combined with data from other sources, displayed using any of the many weewx skins, and/or uploaded to many different web services. the first weewx-sdr release was in 2016. S.a. https://github.com/matthewwall/weewx-sdr https://github.com/weewx/weewx/wiki#skins https://github.com/weewx/weewx/wiki#uploaders rtl_snr : snr is a pair of equivalent C and Python programs that catalog and analyze signal-to-noise ratios from devices seen by RTL_SDR dongles and logged in JSON format by rtl_433.","title":"Related projects"},{"location":"rtl_433/OPERATION/","text":"Basic rtl_433 operation The principle buildings blocks of rtl_433 are: Inputs, Loaders, Processing, Analysis, Decoders, Dumpers, Outputs. At startup rtl_433 will read config files and parse command line arguments, then it will loop through these steps: Inputs: rtl_tcp, RTL-SDR, SoapySDR Loaders: Raw data files (cu8, cs16, ...) Processing: OOK and FSK demod, pulse detector, slicers, coding Analysis: Show statistics on pulses Decoders: Over 200 protocols Dumpers: Raw data files (cu8, cs16, ..., sr, ...) Outputs: Screen (kv), JSON, CSV, MQTT, Influx, UDP (syslog), HTTP rtl_433 will either acquire a live signal from an input or read a sample file with a loader. Then process that signal, analyse it's properties (if enabled) and write the signal with dumpers (if enabled). The raw data is run through decoders to produce decoded output data. Inputs Possible inputs are RTL-SDR, SoapySDR, and rtl_tcp. Inputs are selected with the -d option: [-d <RTL-SDR USB device index> | :<RTL-SDR USB device serial> | <SoapySDR device query> | rtl_tcp | help] RTL-SDR For RTL-SDR use the -d option as: [-d <RTL-SDR USB device index>] (default: 0) [-d :<RTL-SDR USB device serial (can be set with rtl_eeprom -s)>] If RTL-SDR support is compiled in (see the first line of rtl_433 -V ) the default input will be the first available RTL-SDR device. This can also explicitly be selected with rtl_433 -d 0 . Use e.g. rtl_433 -d 1 to select the second device. If you have set a serial number on your device you can use that number prefixed with a colon to select a device, e.g. rtl_433 -d :NESDRSMA . The sample format read from RTL-SDR is always CU8 . SoapySDR For SoapySDR use the -d option as: [-d \"\"] Open default SoapySDR device [-d driver=rtlsdr] Open e.g. specific SoapySDR device If SoapySDR support is compiled in (see the first line of rtl_433 -V ) and RTL-SDR is not then the default input will be the first available SoapySDR device. This can also explicitly be selected with rtl_433 -d \"\" . Otherwise specify a driver string to select the SoapySDR device. Use e.g. rtl_433 -d \"driver=rtlsdr\" to use RTL-SDR over Soapy. Usual SoapySDR driver string are e.g. \"driver=remote,remote=tcp://192.168.2.1:55132\" , \"driver=plutosdr\" , etc. The sample format read from SoapySDR is likely CS16 . A sample format of CU8 is tried first, but unlikely to be supported by SoapySDR drivers. rtl_tcp For rtl_tcp use the -d option as: [-d rtl_tcp[:[//]host[:port]] (default: localhost:1234) Specify host/port to connect to with e.g. -d rtl_tcp:127.0.0.1:1234 The rtl_tcp input is always available. The default host is \"localhost\" and default port is \"1234\". Use e.g. rtl_433 -d rtl_tcp:192.168.2.1 or rtl_433 -d rtl_tcp:192.168.2.1:2143 to select a specific source. Input Gain The input device gain can be set with the -g option: [-g <gain>] (default: auto) For RTL-SDR: gain in dB (\"0\" is auto). For SoapySDR: gain in dB for automatic distribution (\"\" is auto), or string of gain elements. E.g. \"LNA=20,TIA=8,PGA=2\" for LimeSDR. The default gain setting will be automatic gain (AGC enabled). For RTL-SDR the gain is given in dB, where \"0\" selects automatic gain. For SoapySDR a gain argument of \"\" selects automatic gain, a gain value in dB can be used for automatic distribution to the gain stages, and string of gain elements sets the given gain stages individually. Use e.g. -g \"LNA=20,TIA=8,PGA=2\" for LimeSDR. Antenna and settings For SoapySDR the antenna and various other settings can be selected with -t : [-t <settings>] apply a list of keyword=value settings for SoapySDR devices e.g. -t \"antenna=A,bandwidth=4.5M,rfnotch_ctrl=false\" Center Frequency The center frequency can be selected with -f : [-f <frequency>] Receive frequency(s) (default: 433920000 Hz) The default frequency is 433.92 MHz and can be explicitly requested with -f 433.92M . You can give a frequency in Hz, like -f 433920000 or use suffixes of k , M , or G , e.g. -f 433920k , or -f 433.92M . Other interesting frequencies are e.g. -f 868M , -f 315M , -f 345M , -f 915M . If you fine tune the frequency to your sender device you should avoid hitting the sender frequency dead center. The resulting DC (direct current) signal is often attenuated by receivers and hard to make out when analysing samples. A small offset of 10 kHz to 50 kHz works best. The -f option can be used multiple times to set up a list of frequency to hop. Use the -H option to set up the time to stay on each frequency or list on -H per -f to set a stay time for each frequency. (The last hop time given will be the default for all frequencies.) PPM correction A PPM error correction value can be given with -p : [-p <ppm_error] Correct rtl-sdr tuner frequency offset error (default: 0) The PPM error correction is most commonly used to counter the drift in warmed up RTL-SDR devices. Sample rate A sample rate value can be given with -s : [-s <sample rate>] Set sample rate (default: 250000 Hz) The default sample rate is 250 kHz and can be explicitly requested with -s 250k . You can give a sample rate in Hz, like -s 250000 or use suffixes of k , M , or G , e.g. -f 250k , or -f 8M . Note that the suffix is metric, the 1024000 Hz sample rate common with RTL-SDR has to be given as -s 1024k . Decoders Decoders can be selected with the -R and -X option: [-R <device> | help] Enable only the specified device decoding protocol (can be used multiple times) Specify a negative number to disable a device decoding protocol (can be used multiple times) [-X <spec> | help] Add a general purpose decoder (prepend -R 0 to disable all decoders) By default all decoders with proper validity checking are enabled. You can disable selected decoders with any number of -R -<number> options. E.g. use rtl_433 -R -8 -19 to disable the LaCrosse and Nexus decoders. Some decoders have little validity checking and may share very common signal characteristics. This will result in lots of false-positive decodes. These decoders are not enabled by default and you need to explicitly enable them with -R <number> . You can enable only selected decoders with any number of -R <number> options. Note that this will override the default and not select any decoder by default. E.g. use rtl_433 -R 8 19 to enable only the LaCrosse and Nexus decoders. An output line of Registered <n> out of <N> device decoding protocols will tersely show the enabled decoders. Lastly the -X option can be used to add a custom flex decoder. This can be used with -R 0 to disable all default decoders. E.g. rtl_433 -R 0 -X \"<spec>\" will only run your given custom decoder. Flex Decoder A flexible general purpose decoder can be added with the -X option: [-X <spec>] to add a flexible general purpose decoder. <spec> is \"key=value[,key=value...]\" Most common keys are: - name=<name> (or: n=<name> ) - modulation=<modulation> (or: m=<modulation> ) - short=<short> (or: s=<short> ) - long=<long> (or: l=<long> ) - sync=<sync> (or: y=<sync> ) - reset=<reset> (or: r=<reset> ) - gap=<gap> (or: g=<gap> ) - tolerance=<tolerance> (or: t=<tolerance> ) where: <name> can be any descriptive name tag you need in the output. <modulation> is one of: - OOK_MC_ZEROBIT : Manchester Code with fixed leading zero bit - OOK_PCM : Pulse Code Modulation (RZ or NRZ) - OOK_PPM : Pulse Position Modulation - OOK_PWM : Pulse Width Modulation - OOK_DMC : Differential Manchester Code - OOK_PIWM_RAW : Raw Pulse Interval and Width Modulation - OOK_PIWM_DC : Differential Pulse Interval and Width Modulation - OOK_MC_OSV1 : Manchester Code for OSv1 devices - FSK_PCM : FSK Pulse Code Modulation - FSK_PWM : FSK Pulse Width Modulation - FSK_MC_ZEROBIT : Manchester Code with fixed leading zero bit <short> , <long> , <sync> are nominal modulation timings in us, <reset> , <gap> , <tolerance> are maximum modulation timings in us: PCM short : Nominal width of pulse [us] long : Nominal width of bit period [us] PPM short : Nominal width of 0 gap [us] long : Nominal width of 1 gap [us] PWM short : Nominal width of 1 pulse [us] long : Nominal width of 0 pulse [us] sync : Nominal width of sync pulse [us] (optional) common gap : Maximum gap size before new row of bits [us] reset : Maximum gap size before End Of Message [us] tolerance : Maximum pulse deviation [us] (optional). Additional options are: - bits=<n> : only match if at least one row has <n> bits - rows=<n> : only match if there are <n> rows - repeats=<n> : only match if some row is repeated <n> times. - use opt>=n to match at least <n> and opt<=n to match at most <n> - invert : invert all bits - reflect : reflect each byte (MSB first to MSB last) - match=<bits> : only match if the <bits> are found - preamble=<bits> : match and align at the <bits> preamble. - <bits> is a row spec of {<bit count>}<bits as hex number> - unique : suppress duplicate row output - countonly : suppress detailed row output E.g. -X \"n=doorbell,m=OOK_PWM,s=400,l=800,r=7000,g=1000,match={24}0xa9878c,repeats>=3\" specifies: name is doorbell modulation is OOK_PWM width of a short bit is 400 \u00b5s width of a long bit is 800 \u00b5s maximum gap width to reset is 7000 \u00b5s maximum gap width to new row is 1000 \u00b5s the data needs to contain the match of 24 bits 0xa9878c the data needs to repeat at least 3 times To extract some bits: Example: get=battery:@4:{1}:[0:Ok 1:Empty] Using colon separated keys: - name ( battery ) - at which bit to start ( @4 ) - how many bits to read ( {1} ) - optional mapping (map 0 to Full , map 1 to Empty ) - or an optional format specifier ( %x ) A key starting with % is a format specifier for the KV output, in practice it will be something like %x , %X , %04x . See the conf folder for some examples of flex specs. Analysis Signal data can be analysed with -A , -a , sample data can be dumped with -S : [-a] Analyze mode. Print a textual description of the signal. [-A] Pulse Analyzer. Enable pulse analysis and decode attempt. Disable all decoders with -R 0 if you want analyzer output only. [-S none | all | unknown | known] Signal auto save. Creates one file per signal. Note: Saves raw I/Q samples (uint8 pcm, 2 channel). Preferred mode for generating test files. The -a option enables the (old) pulse decoder to print a textual description of the signal. The output might not be too useful, best to use the newer -A option. The -A option enables the (new) pulse analyzer. Each received transmission will be displayed in a statistical overview. A probable coding will be inferred and attempted to decode. The \"Pulse width distribution\", \"Gap width distribution\", and \"Pulse period distribution\" can tell you about the timing in the width column, and the coding in the count column. E.g. a single (or dominant count) pulse width with two gap widths is likely PPM, E.g. a two (or dominant count) pulse widths with a sinle gap widths or single period width is likely PWM. Disable all decoders with -R 0 if you want to view the analyzer output only. The -S option allows you to dump received transmissions for further analysis. Use e.g. rtl_433 -S all to dump all signals or rtl_433 -S unknown to dump only signals with no successful decodes (by enabled decoders). On file will be created per signal, see also \"File names\". Note: Saves raw I/Q samples CU8 (uint8 pcm, 2 channel) for RTL-SDR and CS16 (int16 pcm, 2 channel) for SoapySDR. Loaders and Dumpers Sample data can be loaded or dumped with -r , -w , -W , and codes verified with -y : [-r <filename> | help] Read data from input file instead of a receiver [-w <filename> | help] Save data stream to output file (a `-` dumps samples to stdout) [-W <filename> | help] Save data stream to output file, overwrite existing file [-y <code>] Verify decoding of demodulated test data (e.g. \"{25}fb2dd58\") with enabled devices Read file (loaders) Use the -r option or stdin to read signal data (instead of live input): [-r <filename> | help] Read data from input file instead of a receiver Parameters are detected from the full path, file name, and extension. See also \"File names\". File content and format options are: cu8 , cs16 , cf32 ( IQ implied), and am.s16 . Write file (dumpers) Use the -w and -W option to dump all signal data: [-w <filename>] Save data stream to output file (a `-` dumps samples to stdout) [-W <filename>] Save data stream to output file, overwrite existing file Parameters are detected from the full path, file name, and extension. See also \"File names\". File content and format options are: cu8 , cs16 , cf32 ( IQ implied), am.s16 , am.f32 , fm.s16 , fm.f32 , i.f32 , q.f32 , logic.u8 , ook , and vcd . For example you can dump the live decoded pulse data to stdout with rtl_433 -w OOK:- . Load bitbuffer code Use the -y option to test a known code line (bitbuffer): [-y <code>] Verify decoding of demodulated test data (e.g. \"{25}fb2dd58\") with enabled devices If you are developing or testing a decoder you can skip the device input or sample loading step and directly give a known code line (bitbuffer) to the enabled decoders. File names Samples recorded using the -S option will automatically be given filenames with some meta-data. The signals will be stored individually in files named g<NNN>_<FFF>M_<RRR>k.cu8 : Parameter Description NNN signal grabbed number FFF frequency RRR sample rate File names used with -r , and -w / -W (loaders and dumpers) also follow that convention. A center frequency is detected from the filename as (fractional) number suffixed with M , Hz , kHz , MHz , or GHz . A sample rate is detected from the filename as (fractional) number suffixed with k , sps , ksps , Msps , or Gsps . Parameters must be separated by non-alphanumeric chars and are case-insensitive. File content and format are detected by th extension, possible options are: cu8 ( IQ implied) cs16 ( IQ implied) cf32 ( IQ implied) am.s16' am.f32 fm.s16 fm.f32 i.f32 q.f32 logic.u8 ook vcd Overrides can be prefixed to the actual filename, separated by colon ( : ). E.g. default detection by extension: path/filename.am.s16 and forced overrides: am:s16:path/filename.ext ::: warning Note that not all file types are supported/applicable by loaders or dumpers. ::: Outputs Use the -F option to add outputs, use -M , -K , and -C to configure meta-data: [-F kv | json | csv | mqtt | syslog | null | help] Produce decoded output in given format. Append output to file with :<filename> (e.g. -F csv:log.csv), defaults to stdout. Specify host/port for syslog with e.g. -F syslog:127.0.0.1:1514 [-M time[:<options>] | protocol | level | stats | bits | help] Add various meta data to each output. [-K FILE | PATH | <tag>] Add an expanded token or fixed tag to every output line. [-C native | si | customary] Convert units in decoded output. Without any -F option the default is KV output. Use -F null to remove that default. KV output Use -F kv to add an output in KV format. A colorful, column based output intended for screen display. Append output to file with :<filename> (e.g. -F kv:log.txt ), defaults to stdout. ::: warning Note: the kv output is not a machine-readable key-value format, use the JSON output for that. ::: JSON output Use -F json to add an output in JSON format. Universally machine-readable output. Append output to file with :<filename> (e.g. -F json:log.json ), defaults to stdout. CSV output Use -F csv to add an output in CSV format. Append output to file with :<filename> (e.g. -F csv:log.csv ), defaults to stdout. ::: warning Note: the csv output is not recommended for post-processing, use the JSON output for a machine-readable format. ::: MQTT output Use -F mqtt to add an output in MQTT format. Specify MQTT server with e.g. -F mqtt://localhost:1883 . Add MQTT options with e.g. -F \"mqtt://host:1883,opt=arg\" . Supported MQTT options are: user=foo , pass=bar , retain[=0|1] , <format>[=<topic>] . Supported MQTT formats: (default is all formats) - events : posts JSON event data - states : posts JSON state data - devices : posts device and sensor info in nested topics The <topic> string will expand keys like [/model] , see below. E.g. -F \"mqtt://localhost:1883,user=USERNAME,pass=PASSWORD,retain=0,devices=rtl_433[/id]\" MQTT Format Strings Use format strings of: [token] : expand to token or nothing [token:default] expand to token or default [/token] expand to token with leading slash or nothing [/token:default] expand to token or default with leading slash Tokens are type , model , subtype , channel , id , and protocol for now. Note that for protocol to be available you first need to add it to the meta-data with -M protocol . Examples: sensors[/channel:0][/id] : always have a channel add id if available, you can also use sensors/[channel:0][/id] sensors[/channel][/id] : use channel and then id, each if available sensors[/id][/channel] : use id and then channel, each if available sensors[/channel:0]-[id:0] : always have a combined channel and id ... Defaults are a base topic of rtl_433/<hostname>/ continued - for devices with devices[/type][/model][/subtype][/channel][/id] - for events with events - for states with states SYSLOG output Use -F syslog to add an output in SYSLOG format. Specify host/port for syslog with e.g. -F syslog:127.0.0.1:1514 A UDP output of JSON messages with Syslog compatible header data. E.g. a UDP text payload of <165>1 2019-08-29T06:38:19Z raspi.fritz.box rtl_433 - - - {\"time\":\"2019-08-29 08:38:19\",\"model\":\"Nexus-TH\",\"id\":42,\"channel\":2,\"battery_ok\":1,\"temperature_C\":20.5,\"humidity\":83} See also RFC 5424 - The Syslog Protocol NULL output Without any -F option the default is KV output. Use -F null to remove that default. Meta information [-M time[:<options>]|protocol|level|noise[:<secs>]|stats|bits] Add various metadata to every output line. - Use time to add current date and time meta data (preset for live inputs). - Use time:rel to add sample position meta data (preset for read-file and stdin). - Use time:unix to show the seconds since unix epoch as time meta data. - Use time:iso to show the time with ISO-8601 format ( YYYY-MM-DD\"T\"hh:mm:ss ). - Use time:off to remove time meta data. - Use time:usec to add microseconds to date time meta data. - Use time:tz to output time with timezone offset. - Use time:utc to output time in UTC. (this may also be accomplished by invocation with TZ environment variable set). usec and utc can be combined with other options, eg. time:unix:utc:usec . - Use replay[:N] to replay file inputs at (N-times) realtime. - Use protocol / noprotocol to output the decoder protocol number meta data. - Use level to add Modulation, Frequency, RSSI, SNR, and Noise meta data. - Use noise[:secs] to report estimated noise level at intervals (default: 10 seconds). - Use stats[:[<level>][:<interval>]] to report statistics (default: 600 seconds). level 0: no report, 1: report successful devices, 2: report active devices, 3: report all - Use bits to add bit representation to code outputs (for debug). [-K FILE | PATH | <tag>] Add an expanded token or fixed tag to every output line. Use -K FILE to add the base file name (from a loader) to every output line. Use -K PATH to add the full path name (from a loader) to every output line. Use -K <tag> to add a fixed custom tag to every output line. Data conversion You can choose to normalize data by unit conversion with the -C option: [-C native | si | customary] Convert units in decoded output. The default is no conversion, you explicitly select this with -C native . With -C si units are converted to the SI system: - converts fields of Fahrenheit to Celsius ( _F to _C ) - converts fields of Miles/h to km/h ( _mph to _kph , _mi_h to _km_h ) - converts fields of Inch to mm ( _in to _mm ) - converts fields of Inch/h to mm/h ( _in_h to _mm_h ) - converts fields of InchHg to hPa ( _inHg to _hPa ) - converts fields of PSI to kPa ( _PSI to _kPa ) With -C customary units are converted to customary units: - converts fields of Celsius to Fahrenheit ( _C to _F ) - converts fields of km/h to Miles/h ( _kph to _mph , _km_h to _mi_h ) - converts fields of mm to Inch ( _mm to _inch ) - converts fields of mm/h to Inch/h ( _mm_h to _in_h ) - converts fields of hPa to InchHg ( _hPa to _inHg ) - converts fields of kPa to PSI ( _kPa to _PSI ) Filter output with bridges You can grab the decoded output from rtl_433 in various ways, then process and relay it somewhere. Pipes The simplest (but not very flexible or stable) way is to use pipes. E.g. capture the decode JSON messages and relay the to MQTT with rtl_433 -F json -M utc | mosquitto_pub -t home/rtl_433 -l See also rtl_433_collectd_pipe.py , and rtl_433_statsd_pipe.py for other examples of this method. UDP A better way is to use the Syslog-compatible UDP output to capture and relay the JSON message. See also rtl_433_graphite_relay.py , rtl_433_mqtt_relay.py , and rtl_433_statsd_relay.py for examples of this method. MQTT If you already use the MQTT output, then you can capture the MQTT data, process it and inject derived data back. See e.g. rtl_433_mqtt_hass.py for an example of this method.","title":"Basic rtl_433 operation"},{"location":"rtl_433/OPERATION/#basic-rtl_433-operation","text":"The principle buildings blocks of rtl_433 are: Inputs, Loaders, Processing, Analysis, Decoders, Dumpers, Outputs. At startup rtl_433 will read config files and parse command line arguments, then it will loop through these steps: Inputs: rtl_tcp, RTL-SDR, SoapySDR Loaders: Raw data files (cu8, cs16, ...) Processing: OOK and FSK demod, pulse detector, slicers, coding Analysis: Show statistics on pulses Decoders: Over 200 protocols Dumpers: Raw data files (cu8, cs16, ..., sr, ...) Outputs: Screen (kv), JSON, CSV, MQTT, Influx, UDP (syslog), HTTP rtl_433 will either acquire a live signal from an input or read a sample file with a loader. Then process that signal, analyse it's properties (if enabled) and write the signal with dumpers (if enabled). The raw data is run through decoders to produce decoded output data.","title":"Basic rtl_433 operation"},{"location":"rtl_433/OPERATION/#inputs","text":"Possible inputs are RTL-SDR, SoapySDR, and rtl_tcp. Inputs are selected with the -d option: [-d <RTL-SDR USB device index> | :<RTL-SDR USB device serial> | <SoapySDR device query> | rtl_tcp | help]","title":"Inputs"},{"location":"rtl_433/OPERATION/#rtl-sdr","text":"For RTL-SDR use the -d option as: [-d <RTL-SDR USB device index>] (default: 0) [-d :<RTL-SDR USB device serial (can be set with rtl_eeprom -s)>] If RTL-SDR support is compiled in (see the first line of rtl_433 -V ) the default input will be the first available RTL-SDR device. This can also explicitly be selected with rtl_433 -d 0 . Use e.g. rtl_433 -d 1 to select the second device. If you have set a serial number on your device you can use that number prefixed with a colon to select a device, e.g. rtl_433 -d :NESDRSMA . The sample format read from RTL-SDR is always CU8 .","title":"RTL-SDR"},{"location":"rtl_433/OPERATION/#soapysdr","text":"For SoapySDR use the -d option as: [-d \"\"] Open default SoapySDR device [-d driver=rtlsdr] Open e.g. specific SoapySDR device If SoapySDR support is compiled in (see the first line of rtl_433 -V ) and RTL-SDR is not then the default input will be the first available SoapySDR device. This can also explicitly be selected with rtl_433 -d \"\" . Otherwise specify a driver string to select the SoapySDR device. Use e.g. rtl_433 -d \"driver=rtlsdr\" to use RTL-SDR over Soapy. Usual SoapySDR driver string are e.g. \"driver=remote,remote=tcp://192.168.2.1:55132\" , \"driver=plutosdr\" , etc. The sample format read from SoapySDR is likely CS16 . A sample format of CU8 is tried first, but unlikely to be supported by SoapySDR drivers.","title":"SoapySDR"},{"location":"rtl_433/OPERATION/#rtl_tcp","text":"For rtl_tcp use the -d option as: [-d rtl_tcp[:[//]host[:port]] (default: localhost:1234) Specify host/port to connect to with e.g. -d rtl_tcp:127.0.0.1:1234 The rtl_tcp input is always available. The default host is \"localhost\" and default port is \"1234\". Use e.g. rtl_433 -d rtl_tcp:192.168.2.1 or rtl_433 -d rtl_tcp:192.168.2.1:2143 to select a specific source.","title":"rtl_tcp"},{"location":"rtl_433/OPERATION/#input-gain","text":"The input device gain can be set with the -g option: [-g <gain>] (default: auto) For RTL-SDR: gain in dB (\"0\" is auto). For SoapySDR: gain in dB for automatic distribution (\"\" is auto), or string of gain elements. E.g. \"LNA=20,TIA=8,PGA=2\" for LimeSDR. The default gain setting will be automatic gain (AGC enabled). For RTL-SDR the gain is given in dB, where \"0\" selects automatic gain. For SoapySDR a gain argument of \"\" selects automatic gain, a gain value in dB can be used for automatic distribution to the gain stages, and string of gain elements sets the given gain stages individually. Use e.g. -g \"LNA=20,TIA=8,PGA=2\" for LimeSDR.","title":"Input Gain"},{"location":"rtl_433/OPERATION/#antenna-and-settings","text":"For SoapySDR the antenna and various other settings can be selected with -t : [-t <settings>] apply a list of keyword=value settings for SoapySDR devices e.g. -t \"antenna=A,bandwidth=4.5M,rfnotch_ctrl=false\"","title":"Antenna and settings"},{"location":"rtl_433/OPERATION/#center-frequency","text":"The center frequency can be selected with -f : [-f <frequency>] Receive frequency(s) (default: 433920000 Hz) The default frequency is 433.92 MHz and can be explicitly requested with -f 433.92M . You can give a frequency in Hz, like -f 433920000 or use suffixes of k , M , or G , e.g. -f 433920k , or -f 433.92M . Other interesting frequencies are e.g. -f 868M , -f 315M , -f 345M , -f 915M . If you fine tune the frequency to your sender device you should avoid hitting the sender frequency dead center. The resulting DC (direct current) signal is often attenuated by receivers and hard to make out when analysing samples. A small offset of 10 kHz to 50 kHz works best. The -f option can be used multiple times to set up a list of frequency to hop. Use the -H option to set up the time to stay on each frequency or list on -H per -f to set a stay time for each frequency. (The last hop time given will be the default for all frequencies.)","title":"Center Frequency"},{"location":"rtl_433/OPERATION/#ppm-correction","text":"A PPM error correction value can be given with -p : [-p <ppm_error] Correct rtl-sdr tuner frequency offset error (default: 0) The PPM error correction is most commonly used to counter the drift in warmed up RTL-SDR devices.","title":"PPM correction"},{"location":"rtl_433/OPERATION/#sample-rate","text":"A sample rate value can be given with -s : [-s <sample rate>] Set sample rate (default: 250000 Hz) The default sample rate is 250 kHz and can be explicitly requested with -s 250k . You can give a sample rate in Hz, like -s 250000 or use suffixes of k , M , or G , e.g. -f 250k , or -f 8M . Note that the suffix is metric, the 1024000 Hz sample rate common with RTL-SDR has to be given as -s 1024k .","title":"Sample rate"},{"location":"rtl_433/OPERATION/#decoders","text":"Decoders can be selected with the -R and -X option: [-R <device> | help] Enable only the specified device decoding protocol (can be used multiple times) Specify a negative number to disable a device decoding protocol (can be used multiple times) [-X <spec> | help] Add a general purpose decoder (prepend -R 0 to disable all decoders) By default all decoders with proper validity checking are enabled. You can disable selected decoders with any number of -R -<number> options. E.g. use rtl_433 -R -8 -19 to disable the LaCrosse and Nexus decoders. Some decoders have little validity checking and may share very common signal characteristics. This will result in lots of false-positive decodes. These decoders are not enabled by default and you need to explicitly enable them with -R <number> . You can enable only selected decoders with any number of -R <number> options. Note that this will override the default and not select any decoder by default. E.g. use rtl_433 -R 8 19 to enable only the LaCrosse and Nexus decoders. An output line of Registered <n> out of <N> device decoding protocols will tersely show the enabled decoders. Lastly the -X option can be used to add a custom flex decoder. This can be used with -R 0 to disable all default decoders. E.g. rtl_433 -R 0 -X \"<spec>\" will only run your given custom decoder.","title":"Decoders"},{"location":"rtl_433/OPERATION/#flex-decoder","text":"A flexible general purpose decoder can be added with the -X option: [-X <spec>] to add a flexible general purpose decoder. <spec> is \"key=value[,key=value...]\" Most common keys are: - name=<name> (or: n=<name> ) - modulation=<modulation> (or: m=<modulation> ) - short=<short> (or: s=<short> ) - long=<long> (or: l=<long> ) - sync=<sync> (or: y=<sync> ) - reset=<reset> (or: r=<reset> ) - gap=<gap> (or: g=<gap> ) - tolerance=<tolerance> (or: t=<tolerance> ) where: <name> can be any descriptive name tag you need in the output. <modulation> is one of: - OOK_MC_ZEROBIT : Manchester Code with fixed leading zero bit - OOK_PCM : Pulse Code Modulation (RZ or NRZ) - OOK_PPM : Pulse Position Modulation - OOK_PWM : Pulse Width Modulation - OOK_DMC : Differential Manchester Code - OOK_PIWM_RAW : Raw Pulse Interval and Width Modulation - OOK_PIWM_DC : Differential Pulse Interval and Width Modulation - OOK_MC_OSV1 : Manchester Code for OSv1 devices - FSK_PCM : FSK Pulse Code Modulation - FSK_PWM : FSK Pulse Width Modulation - FSK_MC_ZEROBIT : Manchester Code with fixed leading zero bit <short> , <long> , <sync> are nominal modulation timings in us, <reset> , <gap> , <tolerance> are maximum modulation timings in us: PCM short : Nominal width of pulse [us] long : Nominal width of bit period [us] PPM short : Nominal width of 0 gap [us] long : Nominal width of 1 gap [us] PWM short : Nominal width of 1 pulse [us] long : Nominal width of 0 pulse [us] sync : Nominal width of sync pulse [us] (optional) common gap : Maximum gap size before new row of bits [us] reset : Maximum gap size before End Of Message [us] tolerance : Maximum pulse deviation [us] (optional). Additional options are: - bits=<n> : only match if at least one row has <n> bits - rows=<n> : only match if there are <n> rows - repeats=<n> : only match if some row is repeated <n> times. - use opt>=n to match at least <n> and opt<=n to match at most <n> - invert : invert all bits - reflect : reflect each byte (MSB first to MSB last) - match=<bits> : only match if the <bits> are found - preamble=<bits> : match and align at the <bits> preamble. - <bits> is a row spec of {<bit count>}<bits as hex number> - unique : suppress duplicate row output - countonly : suppress detailed row output E.g. -X \"n=doorbell,m=OOK_PWM,s=400,l=800,r=7000,g=1000,match={24}0xa9878c,repeats>=3\" specifies: name is doorbell modulation is OOK_PWM width of a short bit is 400 \u00b5s width of a long bit is 800 \u00b5s maximum gap width to reset is 7000 \u00b5s maximum gap width to new row is 1000 \u00b5s the data needs to contain the match of 24 bits 0xa9878c the data needs to repeat at least 3 times To extract some bits: Example: get=battery:@4:{1}:[0:Ok 1:Empty] Using colon separated keys: - name ( battery ) - at which bit to start ( @4 ) - how many bits to read ( {1} ) - optional mapping (map 0 to Full , map 1 to Empty ) - or an optional format specifier ( %x ) A key starting with % is a format specifier for the KV output, in practice it will be something like %x , %X , %04x . See the conf folder for some examples of flex specs.","title":"Flex Decoder"},{"location":"rtl_433/OPERATION/#analysis","text":"Signal data can be analysed with -A , -a , sample data can be dumped with -S : [-a] Analyze mode. Print a textual description of the signal. [-A] Pulse Analyzer. Enable pulse analysis and decode attempt. Disable all decoders with -R 0 if you want analyzer output only. [-S none | all | unknown | known] Signal auto save. Creates one file per signal. Note: Saves raw I/Q samples (uint8 pcm, 2 channel). Preferred mode for generating test files. The -a option enables the (old) pulse decoder to print a textual description of the signal. The output might not be too useful, best to use the newer -A option. The -A option enables the (new) pulse analyzer. Each received transmission will be displayed in a statistical overview. A probable coding will be inferred and attempted to decode. The \"Pulse width distribution\", \"Gap width distribution\", and \"Pulse period distribution\" can tell you about the timing in the width column, and the coding in the count column. E.g. a single (or dominant count) pulse width with two gap widths is likely PPM, E.g. a two (or dominant count) pulse widths with a sinle gap widths or single period width is likely PWM. Disable all decoders with -R 0 if you want to view the analyzer output only. The -S option allows you to dump received transmissions for further analysis. Use e.g. rtl_433 -S all to dump all signals or rtl_433 -S unknown to dump only signals with no successful decodes (by enabled decoders). On file will be created per signal, see also \"File names\". Note: Saves raw I/Q samples CU8 (uint8 pcm, 2 channel) for RTL-SDR and CS16 (int16 pcm, 2 channel) for SoapySDR.","title":"Analysis"},{"location":"rtl_433/OPERATION/#loaders-and-dumpers","text":"Sample data can be loaded or dumped with -r , -w , -W , and codes verified with -y : [-r <filename> | help] Read data from input file instead of a receiver [-w <filename> | help] Save data stream to output file (a `-` dumps samples to stdout) [-W <filename> | help] Save data stream to output file, overwrite existing file [-y <code>] Verify decoding of demodulated test data (e.g. \"{25}fb2dd58\") with enabled devices","title":"Loaders and Dumpers"},{"location":"rtl_433/OPERATION/#read-file-loaders","text":"Use the -r option or stdin to read signal data (instead of live input): [-r <filename> | help] Read data from input file instead of a receiver Parameters are detected from the full path, file name, and extension. See also \"File names\". File content and format options are: cu8 , cs16 , cf32 ( IQ implied), and am.s16 .","title":"Read file (loaders)"},{"location":"rtl_433/OPERATION/#write-file-dumpers","text":"Use the -w and -W option to dump all signal data: [-w <filename>] Save data stream to output file (a `-` dumps samples to stdout) [-W <filename>] Save data stream to output file, overwrite existing file Parameters are detected from the full path, file name, and extension. See also \"File names\". File content and format options are: cu8 , cs16 , cf32 ( IQ implied), am.s16 , am.f32 , fm.s16 , fm.f32 , i.f32 , q.f32 , logic.u8 , ook , and vcd . For example you can dump the live decoded pulse data to stdout with rtl_433 -w OOK:- .","title":"Write file (dumpers)"},{"location":"rtl_433/OPERATION/#load-bitbuffer-code","text":"Use the -y option to test a known code line (bitbuffer): [-y <code>] Verify decoding of demodulated test data (e.g. \"{25}fb2dd58\") with enabled devices If you are developing or testing a decoder you can skip the device input or sample loading step and directly give a known code line (bitbuffer) to the enabled decoders.","title":"Load bitbuffer code"},{"location":"rtl_433/OPERATION/#file-names","text":"Samples recorded using the -S option will automatically be given filenames with some meta-data. The signals will be stored individually in files named g<NNN>_<FFF>M_<RRR>k.cu8 : Parameter Description NNN signal grabbed number FFF frequency RRR sample rate File names used with -r , and -w / -W (loaders and dumpers) also follow that convention. A center frequency is detected from the filename as (fractional) number suffixed with M , Hz , kHz , MHz , or GHz . A sample rate is detected from the filename as (fractional) number suffixed with k , sps , ksps , Msps , or Gsps . Parameters must be separated by non-alphanumeric chars and are case-insensitive. File content and format are detected by th extension, possible options are: cu8 ( IQ implied) cs16 ( IQ implied) cf32 ( IQ implied) am.s16' am.f32 fm.s16 fm.f32 i.f32 q.f32 logic.u8 ook vcd Overrides can be prefixed to the actual filename, separated by colon ( : ). E.g. default detection by extension: path/filename.am.s16 and forced overrides: am:s16:path/filename.ext ::: warning Note that not all file types are supported/applicable by loaders or dumpers. :::","title":"File names"},{"location":"rtl_433/OPERATION/#outputs","text":"Use the -F option to add outputs, use -M , -K , and -C to configure meta-data: [-F kv | json | csv | mqtt | syslog | null | help] Produce decoded output in given format. Append output to file with :<filename> (e.g. -F csv:log.csv), defaults to stdout. Specify host/port for syslog with e.g. -F syslog:127.0.0.1:1514 [-M time[:<options>] | protocol | level | stats | bits | help] Add various meta data to each output. [-K FILE | PATH | <tag>] Add an expanded token or fixed tag to every output line. [-C native | si | customary] Convert units in decoded output. Without any -F option the default is KV output. Use -F null to remove that default.","title":"Outputs"},{"location":"rtl_433/OPERATION/#kv-output","text":"Use -F kv to add an output in KV format. A colorful, column based output intended for screen display. Append output to file with :<filename> (e.g. -F kv:log.txt ), defaults to stdout. ::: warning Note: the kv output is not a machine-readable key-value format, use the JSON output for that. :::","title":"KV output"},{"location":"rtl_433/OPERATION/#json-output","text":"Use -F json to add an output in JSON format. Universally machine-readable output. Append output to file with :<filename> (e.g. -F json:log.json ), defaults to stdout.","title":"JSON output"},{"location":"rtl_433/OPERATION/#csv-output","text":"Use -F csv to add an output in CSV format. Append output to file with :<filename> (e.g. -F csv:log.csv ), defaults to stdout. ::: warning Note: the csv output is not recommended for post-processing, use the JSON output for a machine-readable format. :::","title":"CSV output"},{"location":"rtl_433/OPERATION/#mqtt-output","text":"Use -F mqtt to add an output in MQTT format. Specify MQTT server with e.g. -F mqtt://localhost:1883 . Add MQTT options with e.g. -F \"mqtt://host:1883,opt=arg\" . Supported MQTT options are: user=foo , pass=bar , retain[=0|1] , <format>[=<topic>] . Supported MQTT formats: (default is all formats) - events : posts JSON event data - states : posts JSON state data - devices : posts device and sensor info in nested topics The <topic> string will expand keys like [/model] , see below. E.g. -F \"mqtt://localhost:1883,user=USERNAME,pass=PASSWORD,retain=0,devices=rtl_433[/id]\"","title":"MQTT output"},{"location":"rtl_433/OPERATION/#mqtt-format-strings","text":"Use format strings of: [token] : expand to token or nothing [token:default] expand to token or default [/token] expand to token with leading slash or nothing [/token:default] expand to token or default with leading slash Tokens are type , model , subtype , channel , id , and protocol for now. Note that for protocol to be available you first need to add it to the meta-data with -M protocol . Examples: sensors[/channel:0][/id] : always have a channel add id if available, you can also use sensors/[channel:0][/id] sensors[/channel][/id] : use channel and then id, each if available sensors[/id][/channel] : use id and then channel, each if available sensors[/channel:0]-[id:0] : always have a combined channel and id ... Defaults are a base topic of rtl_433/<hostname>/ continued - for devices with devices[/type][/model][/subtype][/channel][/id] - for events with events - for states with states","title":"MQTT Format Strings"},{"location":"rtl_433/OPERATION/#syslog-output","text":"Use -F syslog to add an output in SYSLOG format. Specify host/port for syslog with e.g. -F syslog:127.0.0.1:1514 A UDP output of JSON messages with Syslog compatible header data. E.g. a UDP text payload of <165>1 2019-08-29T06:38:19Z raspi.fritz.box rtl_433 - - - {\"time\":\"2019-08-29 08:38:19\",\"model\":\"Nexus-TH\",\"id\":42,\"channel\":2,\"battery_ok\":1,\"temperature_C\":20.5,\"humidity\":83} See also RFC 5424 - The Syslog Protocol","title":"SYSLOG output"},{"location":"rtl_433/OPERATION/#null-output","text":"Without any -F option the default is KV output. Use -F null to remove that default.","title":"NULL output"},{"location":"rtl_433/OPERATION/#meta-information","text":"[-M time[:<options>]|protocol|level|noise[:<secs>]|stats|bits] Add various metadata to every output line. - Use time to add current date and time meta data (preset for live inputs). - Use time:rel to add sample position meta data (preset for read-file and stdin). - Use time:unix to show the seconds since unix epoch as time meta data. - Use time:iso to show the time with ISO-8601 format ( YYYY-MM-DD\"T\"hh:mm:ss ). - Use time:off to remove time meta data. - Use time:usec to add microseconds to date time meta data. - Use time:tz to output time with timezone offset. - Use time:utc to output time in UTC. (this may also be accomplished by invocation with TZ environment variable set). usec and utc can be combined with other options, eg. time:unix:utc:usec . - Use replay[:N] to replay file inputs at (N-times) realtime. - Use protocol / noprotocol to output the decoder protocol number meta data. - Use level to add Modulation, Frequency, RSSI, SNR, and Noise meta data. - Use noise[:secs] to report estimated noise level at intervals (default: 10 seconds). - Use stats[:[<level>][:<interval>]] to report statistics (default: 600 seconds). level 0: no report, 1: report successful devices, 2: report active devices, 3: report all - Use bits to add bit representation to code outputs (for debug). [-K FILE | PATH | <tag>] Add an expanded token or fixed tag to every output line. Use -K FILE to add the base file name (from a loader) to every output line. Use -K PATH to add the full path name (from a loader) to every output line. Use -K <tag> to add a fixed custom tag to every output line.","title":"Meta information"},{"location":"rtl_433/OPERATION/#data-conversion","text":"You can choose to normalize data by unit conversion with the -C option: [-C native | si | customary] Convert units in decoded output. The default is no conversion, you explicitly select this with -C native . With -C si units are converted to the SI system: - converts fields of Fahrenheit to Celsius ( _F to _C ) - converts fields of Miles/h to km/h ( _mph to _kph , _mi_h to _km_h ) - converts fields of Inch to mm ( _in to _mm ) - converts fields of Inch/h to mm/h ( _in_h to _mm_h ) - converts fields of InchHg to hPa ( _inHg to _hPa ) - converts fields of PSI to kPa ( _PSI to _kPa ) With -C customary units are converted to customary units: - converts fields of Celsius to Fahrenheit ( _C to _F ) - converts fields of km/h to Miles/h ( _kph to _mph , _km_h to _mi_h ) - converts fields of mm to Inch ( _mm to _inch ) - converts fields of mm/h to Inch/h ( _mm_h to _in_h ) - converts fields of hPa to InchHg ( _hPa to _inHg ) - converts fields of kPa to PSI ( _kPa to _PSI )","title":"Data conversion"},{"location":"rtl_433/OPERATION/#filter-output-with-bridges","text":"You can grab the decoded output from rtl_433 in various ways, then process and relay it somewhere.","title":"Filter output with bridges"},{"location":"rtl_433/OPERATION/#pipes","text":"The simplest (but not very flexible or stable) way is to use pipes. E.g. capture the decode JSON messages and relay the to MQTT with rtl_433 -F json -M utc | mosquitto_pub -t home/rtl_433 -l See also rtl_433_collectd_pipe.py , and rtl_433_statsd_pipe.py for other examples of this method.","title":"Pipes"},{"location":"rtl_433/OPERATION/#udp","text":"A better way is to use the Syslog-compatible UDP output to capture and relay the JSON message. See also rtl_433_graphite_relay.py , rtl_433_mqtt_relay.py , and rtl_433_statsd_relay.py for examples of this method.","title":"UDP"},{"location":"rtl_433/OPERATION/#mqtt","text":"If you already use the MQTT output, then you can capture the MQTT data, process it and inject derived data back. See e.g. rtl_433_mqtt_hass.py for an example of this method.","title":"MQTT"},{"location":"rtl_433/PRIMER/","text":"Primer on SDR concepts A brief introduction to some concepts, most questions really only need a keyword to look it up. What is a signal? In the simplest way think of it as a sound file. Load a sample in Audacity and play it! But that's only the sampled , quantized baseband of the radio wave ... 433 MHz is 433920000 Hz? and so listening to 433920001 Hz is a different frequency that would not catch any 433 MHz signals? \"433\" really means the 433.92 MHz ISM-band . \"434\" would be more appropriate. It's a band of \"sample rate\"-width. E.g. 433.795 to 434.045 MHz at the default 433.92 \"center frequency\" and 250 kHz sample rate. How can you decrypt a signal? I am getting some signals with my SDR and it would be nice to know a bit more about them? Mostly it's not encrypted but only coded and modulated . Is the data transmitted in binary code? Always? There are multiple layers. Look up ASK , 2-ASK / OOK , FSK , 2-FSK then PCM , PWM , PPM , MANCHESTER , DMC . Can I know the strength of the signal to know if the transmitter is close or far? Only if there is no AGC or the current AGC value is reported (not with rtl-sdr). What is the meaning of the information I capture with rtl_433? It would be nice to know the meaning of each line or the different parts it shows? It's the decoded transmission and some meta-data about the signal. Why was I getting all zeros when I was listening to my device? How could I change this to get the correct information? Wrong assumption about decoding parameters. The suggested flex decoder is just a simple statistical heuristic. What is the information provided by the -A switch? pulse width, gap width, pulse period..... See PWM. Can I buy and install a bigger antenna to get better signal? Or is there some limitation on the signal that will not allow this? More metal is in fact the only reliable way to get better reception. But there are limits, s. wave length. And you could add directionality. Can I transmit a signal to my receiver thermometer and make it think that I am the transmission device? Does this mean that I can impersonate any transmitter device? Sure. This almost always possible. Does a sensor need some kind of computer/arduino to send signals or can it work with just the sensor and some transmitter hardware? There are specialized chips like the EV1527 that do this. A general-purpose MCU isn't likely to be used. And I would like to know a bit about other frequencies outside 433 MHz. 868 is also interesting. Mostly FSK is used, where 433 mostly uses OOK (ASK). I would like to send a doorbell button push to MQTT. rtl_433 doesn't decode it, but it's a simple button, so I only need a trigger event. With rtl_433 -a -R 0 I am able to catch the button with {25}... code. What is the correct way to send the raw data to MQTT? Use -A and note the -X line. Then use that to write a flex decoder. See e.g. EV1527-PIR-Sgooway.conf . Have fun.","title":"Primer on SDR concepts"},{"location":"rtl_433/PRIMER/#primer-on-sdr-concepts","text":"A brief introduction to some concepts, most questions really only need a keyword to look it up. What is a signal? In the simplest way think of it as a sound file. Load a sample in Audacity and play it! But that's only the sampled , quantized baseband of the radio wave ... 433 MHz is 433920000 Hz? and so listening to 433920001 Hz is a different frequency that would not catch any 433 MHz signals? \"433\" really means the 433.92 MHz ISM-band . \"434\" would be more appropriate. It's a band of \"sample rate\"-width. E.g. 433.795 to 434.045 MHz at the default 433.92 \"center frequency\" and 250 kHz sample rate. How can you decrypt a signal? I am getting some signals with my SDR and it would be nice to know a bit more about them? Mostly it's not encrypted but only coded and modulated . Is the data transmitted in binary code? Always? There are multiple layers. Look up ASK , 2-ASK / OOK , FSK , 2-FSK then PCM , PWM , PPM , MANCHESTER , DMC . Can I know the strength of the signal to know if the transmitter is close or far? Only if there is no AGC or the current AGC value is reported (not with rtl-sdr). What is the meaning of the information I capture with rtl_433? It would be nice to know the meaning of each line or the different parts it shows? It's the decoded transmission and some meta-data about the signal. Why was I getting all zeros when I was listening to my device? How could I change this to get the correct information? Wrong assumption about decoding parameters. The suggested flex decoder is just a simple statistical heuristic. What is the information provided by the -A switch? pulse width, gap width, pulse period..... See PWM. Can I buy and install a bigger antenna to get better signal? Or is there some limitation on the signal that will not allow this? More metal is in fact the only reliable way to get better reception. But there are limits, s. wave length. And you could add directionality. Can I transmit a signal to my receiver thermometer and make it think that I am the transmission device? Does this mean that I can impersonate any transmitter device? Sure. This almost always possible. Does a sensor need some kind of computer/arduino to send signals or can it work with just the sensor and some transmitter hardware? There are specialized chips like the EV1527 that do this. A general-purpose MCU isn't likely to be used. And I would like to know a bit about other frequencies outside 433 MHz. 868 is also interesting. Mostly FSK is used, where 433 mostly uses OOK (ASK). I would like to send a doorbell button push to MQTT. rtl_433 doesn't decode it, but it's a simple button, so I only need a trigger event. With rtl_433 -a -R 0 I am able to catch the button with {25}... code. What is the correct way to send the raw data to MQTT? Use -A and note the -X line. Then use that to write a flex decoder. See e.g. EV1527-PIR-Sgooway.conf . Have fun.","title":"Primer on SDR concepts"},{"location":"rtl_433/STARTING/","text":"Getting Started A short summary how to operate rtl_433 . Options Add options to the rtl_433 command line invocation to specify the mode of operation. E.g. the option -V will output the version string and exit, the option -h will output a brief usage help and exit. Some options take an argument, and you can also use those without argument or help or ? to get brief usage instructions. E.g. -d , -g , -R , -X , -F , -M , -r , -w , or -W without argument will list the argument syntax. Command line options a parsed left to right and will override each other or stack in some cases (frequency hopping). E.g. try the option -V -h to output the version string and exit, the -h option will not be reached, the other way around -h -V you will see the help output but no version string afterwards (but the help includes the version info). This ordering is important to keep in mind, generally go \"inputs\", \"processing options\", \"outputs\". ::: tip [-V] Output the version string and exit [-h] Output this usage help and exit Use -d, -g, -R, -X, -F, -M, -r, -w, or -W without argument for more help ::: Configuration files You can also use a configuration file to give the same options. Files will be read in order and options given will also override in that order. Configuration files can be mixed with command line options. You can instruct rtl_433 to read a configuration file with the -c <path> option. By default a configuration file will be searched for and loaded from - rtl_433.conf at the current directory - $HOME/.config/rtl_433/rtl_433.conf - /usr/local/etc/rtl_433/rtl_433.conf - /etc/rtl_433/rtl_433.conf An example configuration file with information on all possible options is provided at rtl_433.example.conf . ::: tip [-c ] Read config options from a file ::: Select an input rtl_433 can read live inputs (SDR hardware and network streams), sample files, and test codes. Choose a live input with -d : - -d <RTL-SDR USB device index> e.g. -d 0 for the first RTL-SDR found, - -d :<RTL-SDR USB device serial> e.g. -d :NESDRSMA (set the serial using the rtl_eeprom tool) - -d <SoapySDR device query> e.g. -d driver=lime - -d rtl_tcp e.g. -d rtl_tcp://192.168.1.2:1234 The default is to use the first RTL-SDR available ( -d 0 ). You can switch that to using the first SoapySDR available by using -d \"\" , i.e. the empty SoapySDR search string. ::: warning When running multiple instances of rtl_433 be sure to use a distinct input for each, do not rely on the auto-selection of the first available input. ::: Choose a file input using -r e.g. -r g001_433.92M_250k.cu8 If you list files to read as last options then you can omit the -r e.g. rtl_433 g001_433.92M_250k.cu8 If you are testing a decoder you can list a demodulated bit pattern as input using the -y option, e.g. -y \"{25}fb2dd58\" ::: tip [-d | : | | rtl_tcp | help] [-r | help] Read data from input file instead of a receiver [-y ] Verify decoding of demodulated test data (e.g. \"{25}fb2dd58\") with enabled devices ::: Configure the input Live inputs (from SDR hardware) need some settings to work, usually you at least want to specify the center frequency. The default center frequency is 433.92M , select a frequency using -f <frequency> . Suffixes of M , and k , G are accepted. Multiple center frequencies can be given to set up frequency hopping. The hopping time can be given with -H <seconds> , the default is 10 minutes (600 s). Multiple hopping times can be given and apply to each frequency given in that order. You can give -E hop to hop immediatly after each received event. The default sample rate for 433.92M is 250k Hz and 1000k for higher frequencies like 868M . Select a sample rate using -s <sample rate> -- rates higher than 1024k or maybe 2048k are not recommended. Specific settings for an SDR device can be given with -g <gain> , -p <ppm_error> , and even -t <settings> to apply a list of keyword=value settings for SoapySDR devices. ::: tip [-f ] Receive frequency(s) (default: 433920000 Hz) [-H ] Hop interval for polling of multiple frequencies (default: 600 seconds) [-E hop | quit] Hop/Quit after outputting successful event(s) [-s ] Set sample rate (default: 250000 Hz) [-g | help] (default: auto) [-t ] apply a list of keyword=value settings for SoapySDR devices e.g. -t \"antenna=A,bandwidth=4.5M,rfnotch_ctrl=false\" [-p ] Correct rtl-sdr tuner frequency offset error (default: 0) ::: Verbose output If rtl_433 seems to \"hang\", it's usually just not receiving any signals that can be successfully decoded. The default is to be silent until there is a solid data reception. Instruct rtl_433 not to be silent, use: - -v to show detailed notes on startup, - -vv to show failed decoding attempts, - -vvv to show all decoding attempts, - -A to analyze every signal in detail. ::: tip Disable all decoders with -R 0 if you want analyzer output only. ::: Alternatively get periodic status output using: -M level -M noise -M stats:2:30 ::: tip [-v] Increase verbosity (can be used multiple times). -v : verbose, -vv : verbose decoders, -vvv : debug decoders, -vvvv : trace decoding). [-A] Pulse Analyzer. Enable pulse analysis and decode attempt. ::: Select outputs The default output of rtl_433 , if no outputs are selected, is to the screen. Any number of outputs can be selected: - -F kv prints to the screen - -F json prints json lines - -F csv prints a csv formatted file - -F mqtt sends to MQTT - -F influx sends to InfluxDB - -F syslog send UDP messages - -F trigger puts a 1 to the given file, can be used to e.g. on a Raspberyy Pi flash the LED. Append output to file with :<filename> (e.g. -F csv:log.csv ), default is to print to stdout. Specify host/port for mqtt , influx , syslog , with e.g. -F syslog:127.0.0.1:1514 ::: tip [-F kv | json | csv | mqtt | influx | syslog | trigger | null | help] Produce decoded output in given format. ::: Write outputs to files You can write all received raw data to a file with -w <filename> (or -W <filename> to overwrite an existing file). ::: tip [-w | help] Save data stream to output file (a '-' dumps samples to stdout) [-W | help] Save data stream to output file, overwrite existing file ::: Store raw sample data rtl_433 can write a file for each received signal. This is the preferred mode for generating files to later analyze or add as test cases. Use - -S all to write all signals to files, - -S unknown to write signals which couldn't be decoded to files, - -S known to write signals that could be decoded to files. The saves signals are raw I/Q samples (uint8 pcm, 2 channel). ::: tip [-S none | all | unknown | known] Signal auto save. Creates one file per signal. ::: Select decoders The -R option selects decoders to use. The option can be given multiple times. Default is to activate all available decoders which are not default-disabled due to known problems. You can disable some decoders using negative number, e.g. -R -3 . You can enable only select decoders by using some -R options, e.g. -R 3 . You can disable all decoders using some -R 0 . Additional flexible general purpose decoders can be added using -X <spec> . ::: tip Disable all decoders with -R 0 if you want only the given flex decoder. ::: ::: tip [-R | help] Enable only the specified device decoding protocol (can be used multiple times) Specify a negative number to disable a device decoding protocol (can be used multiple times) [-X | help] Add a general purpose decoder (prepend -R 0 to disable all decoders) ::: Demodulator options The operation of the demodulator stage can be tuned with the -Y option. For the 433.92M frequency the classic pulse detector is used by default, for higher frequencies like 868M the minmax pulse detector is used by default. Use -Y classic or -Y minmax to force the use of a FSK pulse detector. Use -Y autolevel to automatically adjust the minimum detection level based on average estimated noise. Recommended. Use -Y squelch to skip frames below estimated noise level to reduce cpu load. Recommended. ::: tip [-Y auto | classic | minmax] FSK pulse detector mode. [-Y level= ] Manual detection level used to determine pulses (-1.0 to -30.0) (0=auto). [-Y minlevel= ] Manual minimum detection level used to determine pulses (-1.0 to -99.0). [-Y minsnr= ] Minimum SNR to determine pulses (1.0 to 99.0). [-Y autolevel] Set minlevel automatically based on average estimated noise. [-Y squelch] Skip frames below estimated noise level to reduce cpu load. [-Y ampest | magest] Choose amplitude or magnitude level estimator. ::: Meta-data and data conversion Additional meta data can be added to the output using the -M option . E.g. use -M level to add Modulation, Frequency, RSSI, SNR, and Noise meta data. Meta data formats can be selected, e.g. use -M time:iso:utc:usec to use the ISO format in the UTC zone with added microseconds. Various tags can be added to all event outputs. Use - -K FILE Add the expanded name of the input file to every output line, - -K PATH Add the expanded path of the input file to every output line, - -K <tag> Add an expanded token or fixed tag to every output line. - -K <key>=<tag> Add an expanded token or fixed tag to every output line. Known data units can be converted to SI units or Customary (US) units. The default is to output native units as received. Use - -C native Do not convert units in decoded output. - -C si Convert units to SI in decoded output. - -C customary Convert units to Customary (US) in decoded output. ::: tip [-M time[: ] | protocol | level | noise[: ] | stats | bits] Add various metadata to every output line. Use \"time\" to add current date and time meta data (preset for live inputs). Use \"time:rel\" to add sample position meta data (preset for read-file and stdin). Use \"time:unix\" to show the seconds since unix epoch as time meta data. Use \"time:iso\" to show the time with ISO-8601 format (YYYY-MM-DD\"T\"hh ss). Use \"time:off\" to remove time meta data. Use \"time:usec\" to add microseconds to date time meta data. Use \"time:tz\" to output time with timezone offset. Use \"time:utc\" to output time in UTC. (this may also be accomplished by invocation with TZ environment variable set). \"usec\" and \"utc\" can be combined with other options, eg. \"time:unix:utc:usec\". Use \"protocol\" / \"noprotocol\" to output the decoder protocol number meta data. Use \"level\" to add Modulation, Frequency, RSSI, SNR, and Noise meta data. Use \"noise[:secs]\" to report estimated noise level at intervals (default: 10 seconds). Use \"stats[:[ ][: ]]\" to report statistics (default: 600 seconds). level 0: no report, 1: report successful devices, 2: report active devices, 3: report all [-K FILE | PATH | <tag> | <key>=<tag>] Add an expanded token or fixed tag to every output line. If <tag> is \"FILE\" or \"PATH\" an expanded token will be added. The <tag> can also be a GPSd URL, e.g. \"-K gpsd,lat,lon\" (report lat and lon keys from local gpsd) \"-K loc=gpsd,lat,lon\" (report lat and lon in loc object) \"-K gpsd\" (full json TPV report, in default \"gps\" object) \"-K foo=gpsd://127.0.0.1:2947\" (with key and address) \"-K bar=gpsd,nmea\" (NMEA default GPGGA report) \"-K rmc=gpsd,nmea,filter='$GPRMC'\" (NMEA GPRMC report) Also <tag> can be a generic tcp address, e.g. \"-K foo=tcp:localhost:4000\" (read lines as TCP client) \"-K bar=tcp://127.0.0.1:3000,init='subscribe tags\\r\\n'\" \"-K baz=tcp://127.0.0.1:5000,filter='a prefix to match'\" [-C native | si | customary] Convert units in decoded output. ::: Mode of operation When reading live inputs rtl_433 will usually run forever, but you can limit the runtime - to a specific time using -T <seconds> , also formats like 12:34 or 1h23m45s are accepted, - to a number of samples using -n <value> as a number of samples to take (each sample is an I/Q pair), - to recieving an event using -E quit , to quit after outputting the first event. When reading input from files rtl_433 will process the data as fast as possible. You can limit the processing to original (or N-times) real-time using -M replay[:N] . ::: tip [-n ] Specify number of samples to take (each sample is an I/Q pair) [-T ] Specify number of seconds to run, also 12:34 or 1h23m45s [-E hop | quit] Hop/Quit after outputting successful event(s) [-M replay[:N]] to replay file inputs at (N-times) realtime. :::","title":"Getting Started"},{"location":"rtl_433/STARTING/#getting-started","text":"A short summary how to operate rtl_433 .","title":"Getting Started"},{"location":"rtl_433/STARTING/#options","text":"Add options to the rtl_433 command line invocation to specify the mode of operation. E.g. the option -V will output the version string and exit, the option -h will output a brief usage help and exit. Some options take an argument, and you can also use those without argument or help or ? to get brief usage instructions. E.g. -d , -g , -R , -X , -F , -M , -r , -w , or -W without argument will list the argument syntax. Command line options a parsed left to right and will override each other or stack in some cases (frequency hopping). E.g. try the option -V -h to output the version string and exit, the -h option will not be reached, the other way around -h -V you will see the help output but no version string afterwards (but the help includes the version info). This ordering is important to keep in mind, generally go \"inputs\", \"processing options\", \"outputs\". ::: tip [-V] Output the version string and exit [-h] Output this usage help and exit Use -d, -g, -R, -X, -F, -M, -r, -w, or -W without argument for more help :::","title":"Options"},{"location":"rtl_433/STARTING/#configuration-files","text":"You can also use a configuration file to give the same options. Files will be read in order and options given will also override in that order. Configuration files can be mixed with command line options. You can instruct rtl_433 to read a configuration file with the -c <path> option. By default a configuration file will be searched for and loaded from - rtl_433.conf at the current directory - $HOME/.config/rtl_433/rtl_433.conf - /usr/local/etc/rtl_433/rtl_433.conf - /etc/rtl_433/rtl_433.conf An example configuration file with information on all possible options is provided at rtl_433.example.conf . ::: tip [-c ] Read config options from a file :::","title":"Configuration files"},{"location":"rtl_433/STARTING/#select-an-input","text":"rtl_433 can read live inputs (SDR hardware and network streams), sample files, and test codes. Choose a live input with -d : - -d <RTL-SDR USB device index> e.g. -d 0 for the first RTL-SDR found, - -d :<RTL-SDR USB device serial> e.g. -d :NESDRSMA (set the serial using the rtl_eeprom tool) - -d <SoapySDR device query> e.g. -d driver=lime - -d rtl_tcp e.g. -d rtl_tcp://192.168.1.2:1234 The default is to use the first RTL-SDR available ( -d 0 ). You can switch that to using the first SoapySDR available by using -d \"\" , i.e. the empty SoapySDR search string. ::: warning When running multiple instances of rtl_433 be sure to use a distinct input for each, do not rely on the auto-selection of the first available input. ::: Choose a file input using -r e.g. -r g001_433.92M_250k.cu8 If you list files to read as last options then you can omit the -r e.g. rtl_433 g001_433.92M_250k.cu8 If you are testing a decoder you can list a demodulated bit pattern as input using the -y option, e.g. -y \"{25}fb2dd58\" ::: tip [-d | : | | rtl_tcp | help] [-r | help] Read data from input file instead of a receiver [-y ] Verify decoding of demodulated test data (e.g. \"{25}fb2dd58\") with enabled devices :::","title":"Select an input"},{"location":"rtl_433/STARTING/#configure-the-input","text":"Live inputs (from SDR hardware) need some settings to work, usually you at least want to specify the center frequency. The default center frequency is 433.92M , select a frequency using -f <frequency> . Suffixes of M , and k , G are accepted. Multiple center frequencies can be given to set up frequency hopping. The hopping time can be given with -H <seconds> , the default is 10 minutes (600 s). Multiple hopping times can be given and apply to each frequency given in that order. You can give -E hop to hop immediatly after each received event. The default sample rate for 433.92M is 250k Hz and 1000k for higher frequencies like 868M . Select a sample rate using -s <sample rate> -- rates higher than 1024k or maybe 2048k are not recommended. Specific settings for an SDR device can be given with -g <gain> , -p <ppm_error> , and even -t <settings> to apply a list of keyword=value settings for SoapySDR devices. ::: tip [-f ] Receive frequency(s) (default: 433920000 Hz) [-H ] Hop interval for polling of multiple frequencies (default: 600 seconds) [-E hop | quit] Hop/Quit after outputting successful event(s) [-s ] Set sample rate (default: 250000 Hz) [-g | help] (default: auto) [-t ] apply a list of keyword=value settings for SoapySDR devices e.g. -t \"antenna=A,bandwidth=4.5M,rfnotch_ctrl=false\" [-p ] Correct rtl-sdr tuner frequency offset error (default: 0) :::","title":"Configure the input"},{"location":"rtl_433/STARTING/#verbose-output","text":"If rtl_433 seems to \"hang\", it's usually just not receiving any signals that can be successfully decoded. The default is to be silent until there is a solid data reception. Instruct rtl_433 not to be silent, use: - -v to show detailed notes on startup, - -vv to show failed decoding attempts, - -vvv to show all decoding attempts, - -A to analyze every signal in detail. ::: tip Disable all decoders with -R 0 if you want analyzer output only. ::: Alternatively get periodic status output using: -M level -M noise -M stats:2:30 ::: tip [-v] Increase verbosity (can be used multiple times). -v : verbose, -vv : verbose decoders, -vvv : debug decoders, -vvvv : trace decoding). [-A] Pulse Analyzer. Enable pulse analysis and decode attempt. :::","title":"Verbose output"},{"location":"rtl_433/STARTING/#select-outputs","text":"The default output of rtl_433 , if no outputs are selected, is to the screen. Any number of outputs can be selected: - -F kv prints to the screen - -F json prints json lines - -F csv prints a csv formatted file - -F mqtt sends to MQTT - -F influx sends to InfluxDB - -F syslog send UDP messages - -F trigger puts a 1 to the given file, can be used to e.g. on a Raspberyy Pi flash the LED. Append output to file with :<filename> (e.g. -F csv:log.csv ), default is to print to stdout. Specify host/port for mqtt , influx , syslog , with e.g. -F syslog:127.0.0.1:1514 ::: tip [-F kv | json | csv | mqtt | influx | syslog | trigger | null | help] Produce decoded output in given format. :::","title":"Select outputs"},{"location":"rtl_433/STARTING/#write-outputs-to-files","text":"You can write all received raw data to a file with -w <filename> (or -W <filename> to overwrite an existing file). ::: tip [-w | help] Save data stream to output file (a '-' dumps samples to stdout) [-W | help] Save data stream to output file, overwrite existing file :::","title":"Write outputs to files"},{"location":"rtl_433/STARTING/#store-raw-sample-data","text":"rtl_433 can write a file for each received signal. This is the preferred mode for generating files to later analyze or add as test cases. Use - -S all to write all signals to files, - -S unknown to write signals which couldn't be decoded to files, - -S known to write signals that could be decoded to files. The saves signals are raw I/Q samples (uint8 pcm, 2 channel). ::: tip [-S none | all | unknown | known] Signal auto save. Creates one file per signal. :::","title":"Store raw sample data"},{"location":"rtl_433/STARTING/#select-decoders","text":"The -R option selects decoders to use. The option can be given multiple times. Default is to activate all available decoders which are not default-disabled due to known problems. You can disable some decoders using negative number, e.g. -R -3 . You can enable only select decoders by using some -R options, e.g. -R 3 . You can disable all decoders using some -R 0 . Additional flexible general purpose decoders can be added using -X <spec> . ::: tip Disable all decoders with -R 0 if you want only the given flex decoder. ::: ::: tip [-R | help] Enable only the specified device decoding protocol (can be used multiple times) Specify a negative number to disable a device decoding protocol (can be used multiple times) [-X | help] Add a general purpose decoder (prepend -R 0 to disable all decoders) :::","title":"Select decoders"},{"location":"rtl_433/STARTING/#demodulator-options","text":"The operation of the demodulator stage can be tuned with the -Y option. For the 433.92M frequency the classic pulse detector is used by default, for higher frequencies like 868M the minmax pulse detector is used by default. Use -Y classic or -Y minmax to force the use of a FSK pulse detector. Use -Y autolevel to automatically adjust the minimum detection level based on average estimated noise. Recommended. Use -Y squelch to skip frames below estimated noise level to reduce cpu load. Recommended. ::: tip [-Y auto | classic | minmax] FSK pulse detector mode. [-Y level= ] Manual detection level used to determine pulses (-1.0 to -30.0) (0=auto). [-Y minlevel= ] Manual minimum detection level used to determine pulses (-1.0 to -99.0). [-Y minsnr= ] Minimum SNR to determine pulses (1.0 to 99.0). [-Y autolevel] Set minlevel automatically based on average estimated noise. [-Y squelch] Skip frames below estimated noise level to reduce cpu load. [-Y ampest | magest] Choose amplitude or magnitude level estimator. :::","title":"Demodulator options"},{"location":"rtl_433/STARTING/#meta-data-and-data-conversion","text":"Additional meta data can be added to the output using the -M option . E.g. use -M level to add Modulation, Frequency, RSSI, SNR, and Noise meta data. Meta data formats can be selected, e.g. use -M time:iso:utc:usec to use the ISO format in the UTC zone with added microseconds. Various tags can be added to all event outputs. Use - -K FILE Add the expanded name of the input file to every output line, - -K PATH Add the expanded path of the input file to every output line, - -K <tag> Add an expanded token or fixed tag to every output line. - -K <key>=<tag> Add an expanded token or fixed tag to every output line. Known data units can be converted to SI units or Customary (US) units. The default is to output native units as received. Use - -C native Do not convert units in decoded output. - -C si Convert units to SI in decoded output. - -C customary Convert units to Customary (US) in decoded output. ::: tip [-M time[: ] | protocol | level | noise[: ] | stats | bits] Add various metadata to every output line. Use \"time\" to add current date and time meta data (preset for live inputs). Use \"time:rel\" to add sample position meta data (preset for read-file and stdin). Use \"time:unix\" to show the seconds since unix epoch as time meta data. Use \"time:iso\" to show the time with ISO-8601 format (YYYY-MM-DD\"T\"hh ss). Use \"time:off\" to remove time meta data. Use \"time:usec\" to add microseconds to date time meta data. Use \"time:tz\" to output time with timezone offset. Use \"time:utc\" to output time in UTC. (this may also be accomplished by invocation with TZ environment variable set). \"usec\" and \"utc\" can be combined with other options, eg. \"time:unix:utc:usec\". Use \"protocol\" / \"noprotocol\" to output the decoder protocol number meta data. Use \"level\" to add Modulation, Frequency, RSSI, SNR, and Noise meta data. Use \"noise[:secs]\" to report estimated noise level at intervals (default: 10 seconds). Use \"stats[:[ ][: ]]\" to report statistics (default: 600 seconds). level 0: no report, 1: report successful devices, 2: report active devices, 3: report all [-K FILE | PATH | <tag> | <key>=<tag>] Add an expanded token or fixed tag to every output line. If <tag> is \"FILE\" or \"PATH\" an expanded token will be added. The <tag> can also be a GPSd URL, e.g. \"-K gpsd,lat,lon\" (report lat and lon keys from local gpsd) \"-K loc=gpsd,lat,lon\" (report lat and lon in loc object) \"-K gpsd\" (full json TPV report, in default \"gps\" object) \"-K foo=gpsd://127.0.0.1:2947\" (with key and address) \"-K bar=gpsd,nmea\" (NMEA default GPGGA report) \"-K rmc=gpsd,nmea,filter='$GPRMC'\" (NMEA GPRMC report) Also <tag> can be a generic tcp address, e.g. \"-K foo=tcp:localhost:4000\" (read lines as TCP client) \"-K bar=tcp://127.0.0.1:3000,init='subscribe tags\\r\\n'\" \"-K baz=tcp://127.0.0.1:5000,filter='a prefix to match'\" [-C native | si | customary] Convert units in decoded output. :::","title":"Meta-data and data conversion"},{"location":"rtl_433/STARTING/#mode-of-operation","text":"When reading live inputs rtl_433 will usually run forever, but you can limit the runtime - to a specific time using -T <seconds> , also formats like 12:34 or 1h23m45s are accepted, - to a number of samples using -n <value> as a number of samples to take (each sample is an I/Q pair), - to recieving an event using -E quit , to quit after outputting the first event. When reading input from files rtl_433 will process the data as fast as possible. You can limit the processing to original (or N-times) real-time using -M replay[:N] . ::: tip [-n ] Specify number of samples to take (each sample is an I/Q pair) [-T ] Specify number of seconds to run, also 12:34 or 1h23m45s [-E hop | quit] Hop/Quit after outputting successful event(s) [-M replay[:N]] to replay file inputs at (N-times) realtime. :::","title":"Mode of operation"},{"location":"setup-measurements-DMT/Home/","text":"PROCEDURA SET-UP AGGIORNARE IL FILE Setup_Log PER OGNI REGOLAZIONE FATTA Gli strumenti per convergenza e camber li trovate nel cassetto sospensioni, c'\u00e8 anche uno spago nero per la convergenza e dei laserini per amplif. Per livellare le bilance trovate una staggia a fianco dell'armadio della Deckel Maho. CONTROLLI PRELIMINARI Macchina completa di tutto: porco, ali, pance, fondo ecc\u2026 Macchina su cavalletti Verificare con calibro lunghezza occhiello, occhiello degli ammortizzatori e lunghezze dei pull/push rod; Confrontare con lunghezze riportate nell'user manual e agire se non le rispettano. Verificare precarico molle, un buon valore di partenza per Fenice pu\u00f2 essere 1-2mm; Si avvicina la ghiera alla molla e poi si contano i giri della ghiera (rapporto giri/mm \u00e9 nell'user manual e nel manuale di EXT . Importante che destra e sinistra siano uguali e non superare i 2mm di precarico! Verificare pressione pneumatici, con asfalto asciutto e temperatura tra 20 e 30 gradi, 0.8 bar possono andare bene, verificare versi di rotazione pneumatici e usura. Verificare che le bilance siano coerenti tra loro e in caso contrario procedere con la taratura (vedi libretto bilancia o file excel . Posizionare le bilance e livellarle. (!! sia tra di loro che col piatto bilancia !!). Se necessario ci sono anche le 4 pedane in legno. Mettere a 0 tutte le regolazioni degli ammo (compressione alte, basse velocit\u00e1 e rebound alte e basse) e verificare pressione ammo. Il valore DEVE stare tra 5 e 12 bar (vanno bene 5 bar). Regolare valore con una pompetta per ammo da bici. SQUADRATURA Sempre a macchina alzata e in bolla (roll e anche pitch per quanto possibile) (rif. Chassis front). Montare barra orizzontale anteriore (serve rimuovere la carena) Tirare lo spago sulla barra e fissarlo al piedistallo posteriore (verificare che sia in squadra con la barra frontale (da vedere se fare solo un lato o entrambi) Montare le staffe sui cerchi (o mozzi) e inserire le rispettive \"chiavette\" Posizionare lo sterzo al centro Allineare lo spago al vertice di riferimento sulle chiavette (per toe nullo lo spago deve essere lungo la linea di riferimento) allentare i controdadi del tie rod; (cercare di non sforzare sul braccetto in carbonio) ruotare (allungare-accorciare) il tie rod finch\u00e9 si ottiene il valore di toe rear desiderato (0.4 \u00b0 toe in rear. 0.3\u00b0 toe out front), serrare i dadi. Ripetere dall'altro lato N.B : l'offset della chiavetta va regolato man mano che si regola la convergenza (mantenere lo spago sul vertice opposto, al centro del cerchietto rosso) N.B.: controllare sempre che i finecorsa destra e sinistra della cremagliera intervengano prima di qualche altra interferenza sul gruppo ruota! Controllare che non ci sia troppo filetto esposto ai capi dei tie rod, in caso potrebbe essere che lo sterzo non sia centrato bene e bisogni smontare i cardani per sistemarlo. CAMBER Azzerare strumento per camber su una parete verticale (controllata con livella) poi con la macchina perfettamente livellata, regolare il camber anteriore e posteriore tramite piastrine e lunette (cercare una posizione piana per appoggiare lo strumento, sulla parte superiore o inferiore della gomma, o sulla barra orizzontale della staffa mozzo, controllare anche la bolla ausiliaria dello strumento). Valori di camber iniziali: front -2.5\u00b0, rear -1.5\u00b0 N.B. valori di camber sono dati per macchina a terra (ride height) quindi tener conto dell'incremento di camber dovuto al fatto che la macchina sia a ruote alzate (circa 1\u00b0 front e 2\u00b0rear)! FRONT REAR Effect on car PULL/PUSH ROD ADJUSTER 1.95 [mm/mm] (effetto negativo) 0.99 [mm/mm] Ride height change TOE ADJUSTER 0.41[deg/mm] 0.45 [deg/mm] Toe out/in CAMBER ADJUSTER 0.33 [deg/mm] 0.24 [deg/mm] 0.25 [deg/mm] 0.0 [deg/mm] Camber change Toe change LEVERAGE RATIO 1.0 1.0 CAMBER GAIN 0.36 [deg/cm] 0.65 [deg/cm] BILANCIAMENTO Scollegare la barra antirollio e mettere la macchina sulle bilance. Agendo sulla lunghezza dei push/pull rod (push agisce al contrario del pull) bilanciare le diagonali cercando di minimizzare l'allungamento o accorciamento dei rod. Fare una pesata anche con pilota a bordo e segnarsi pesi con e senza. Ricollegare le barre antirollio e regolarle al grado di rigidezza desiderato. BRAKING Con asfalto in condizioni ottimali partire con distribuzione 60% front che si ottiene con balance bar perfettamente centrata. Proportioning valve regolata a circa 50% del suo range Con grip ridotto spostare leggermente il bilanciamento al posteriore REGOLAZIONE ASSETTO Verificare con termocamera la temperatura del battistrada dopo una run di prova (con curve veloci, lente e cambi di direzione), se la temperatura \u00e8 tanto pi\u00f9 alta sulla spalla interna aumentare (verso lo 0) camber, viceversa se \u00e8 molto calda la spalla esterna ridurlo. La temperatura deve risultare il pi\u00f9 possibile omogenea, leggermente pi\u00f9 alta verso l'esterno. Ripetere front e rear. Riscontro Parametro da regolare Regolazione Sottosterzo ARB FRONT ARB Rear Precarico Fronto Convergenza front Ammorbidire Irrigidire Ridurre Aumentare Toe-Out Sovrasterzo Convergenza Rear ARB rear Ridurre (allungare Tie Rod) Ammoorbidire Bloccaggio rear sbilanciamento in frenata Regolazione bilanciamento f/r ripartizione pressione Rebound rear Bound front Spostare verso front Irrigidire low speed Irrigidire low speed Eseguire sempre prima una regolazione di massima, in modo che l'effetto si possa notare, e solo poi regolare per piccoli step. Segnare sempre sul file Setup Log tutte le variazioni con relativo feedback pilota Release Notes V1.0 28/06/2022 : Initial release (Davide Rudari) V1.1 16/08/2022 : Updated values and link to files (Davide Rudari)","title":"PROCEDURA SET-UP"},{"location":"setup-measurements-DMT/Home/#procedura-set-up","text":"AGGIORNARE IL FILE Setup_Log PER OGNI REGOLAZIONE FATTA Gli strumenti per convergenza e camber li trovate nel cassetto sospensioni, c'\u00e8 anche uno spago nero per la convergenza e dei laserini per amplif. Per livellare le bilance trovate una staggia a fianco dell'armadio della Deckel Maho.","title":"PROCEDURA SET-UP"},{"location":"setup-measurements-DMT/Home/#controlli-preliminari","text":"Macchina completa di tutto: porco, ali, pance, fondo ecc\u2026 Macchina su cavalletti Verificare con calibro lunghezza occhiello, occhiello degli ammortizzatori e lunghezze dei pull/push rod; Confrontare con lunghezze riportate nell'user manual e agire se non le rispettano. Verificare precarico molle, un buon valore di partenza per Fenice pu\u00f2 essere 1-2mm; Si avvicina la ghiera alla molla e poi si contano i giri della ghiera (rapporto giri/mm \u00e9 nell'user manual e nel manuale di EXT . Importante che destra e sinistra siano uguali e non superare i 2mm di precarico! Verificare pressione pneumatici, con asfalto asciutto e temperatura tra 20 e 30 gradi, 0.8 bar possono andare bene, verificare versi di rotazione pneumatici e usura. Verificare che le bilance siano coerenti tra loro e in caso contrario procedere con la taratura (vedi libretto bilancia o file excel . Posizionare le bilance e livellarle. (!! sia tra di loro che col piatto bilancia !!). Se necessario ci sono anche le 4 pedane in legno. Mettere a 0 tutte le regolazioni degli ammo (compressione alte, basse velocit\u00e1 e rebound alte e basse) e verificare pressione ammo. Il valore DEVE stare tra 5 e 12 bar (vanno bene 5 bar). Regolare valore con una pompetta per ammo da bici.","title":"CONTROLLI PRELIMINARI"},{"location":"setup-measurements-DMT/Home/#squadratura","text":"Sempre a macchina alzata e in bolla (roll e anche pitch per quanto possibile) (rif. Chassis front). Montare barra orizzontale anteriore (serve rimuovere la carena) Tirare lo spago sulla barra e fissarlo al piedistallo posteriore (verificare che sia in squadra con la barra frontale (da vedere se fare solo un lato o entrambi) Montare le staffe sui cerchi (o mozzi) e inserire le rispettive \"chiavette\" Posizionare lo sterzo al centro Allineare lo spago al vertice di riferimento sulle chiavette (per toe nullo lo spago deve essere lungo la linea di riferimento) allentare i controdadi del tie rod; (cercare di non sforzare sul braccetto in carbonio) ruotare (allungare-accorciare) il tie rod finch\u00e9 si ottiene il valore di toe rear desiderato (0.4 \u00b0 toe in rear. 0.3\u00b0 toe out front), serrare i dadi. Ripetere dall'altro lato N.B : l'offset della chiavetta va regolato man mano che si regola la convergenza (mantenere lo spago sul vertice opposto, al centro del cerchietto rosso) N.B.: controllare sempre che i finecorsa destra e sinistra della cremagliera intervengano prima di qualche altra interferenza sul gruppo ruota! Controllare che non ci sia troppo filetto esposto ai capi dei tie rod, in caso potrebbe essere che lo sterzo non sia centrato bene e bisogni smontare i cardani per sistemarlo.","title":"SQUADRATURA"},{"location":"setup-measurements-DMT/Home/#camber","text":"Azzerare strumento per camber su una parete verticale (controllata con livella) poi con la macchina perfettamente livellata, regolare il camber anteriore e posteriore tramite piastrine e lunette (cercare una posizione piana per appoggiare lo strumento, sulla parte superiore o inferiore della gomma, o sulla barra orizzontale della staffa mozzo, controllare anche la bolla ausiliaria dello strumento). Valori di camber iniziali: front -2.5\u00b0, rear -1.5\u00b0 N.B. valori di camber sono dati per macchina a terra (ride height) quindi tener conto dell'incremento di camber dovuto al fatto che la macchina sia a ruote alzate (circa 1\u00b0 front e 2\u00b0rear)! FRONT REAR Effect on car PULL/PUSH ROD ADJUSTER 1.95 [mm/mm] (effetto negativo) 0.99 [mm/mm] Ride height change TOE ADJUSTER 0.41[deg/mm] 0.45 [deg/mm] Toe out/in CAMBER ADJUSTER 0.33 [deg/mm] 0.24 [deg/mm] 0.25 [deg/mm] 0.0 [deg/mm] Camber change Toe change LEVERAGE RATIO 1.0 1.0 CAMBER GAIN 0.36 [deg/cm] 0.65 [deg/cm]","title":"CAMBER"},{"location":"setup-measurements-DMT/Home/#bilanciamento","text":"Scollegare la barra antirollio e mettere la macchina sulle bilance. Agendo sulla lunghezza dei push/pull rod (push agisce al contrario del pull) bilanciare le diagonali cercando di minimizzare l'allungamento o accorciamento dei rod. Fare una pesata anche con pilota a bordo e segnarsi pesi con e senza. Ricollegare le barre antirollio e regolarle al grado di rigidezza desiderato.","title":"BILANCIAMENTO"},{"location":"setup-measurements-DMT/Home/#braking","text":"Con asfalto in condizioni ottimali partire con distribuzione 60% front che si ottiene con balance bar perfettamente centrata. Proportioning valve regolata a circa 50% del suo range Con grip ridotto spostare leggermente il bilanciamento al posteriore","title":"BRAKING"},{"location":"setup-measurements-DMT/Home/#regolazione-assetto","text":"Verificare con termocamera la temperatura del battistrada dopo una run di prova (con curve veloci, lente e cambi di direzione), se la temperatura \u00e8 tanto pi\u00f9 alta sulla spalla interna aumentare (verso lo 0) camber, viceversa se \u00e8 molto calda la spalla esterna ridurlo. La temperatura deve risultare il pi\u00f9 possibile omogenea, leggermente pi\u00f9 alta verso l'esterno. Ripetere front e rear. Riscontro Parametro da regolare Regolazione Sottosterzo ARB FRONT ARB Rear Precarico Fronto Convergenza front Ammorbidire Irrigidire Ridurre Aumentare Toe-Out Sovrasterzo Convergenza Rear ARB rear Ridurre (allungare Tie Rod) Ammoorbidire Bloccaggio rear sbilanciamento in frenata Regolazione bilanciamento f/r ripartizione pressione Rebound rear Bound front Spostare verso front Irrigidire low speed Irrigidire low speed Eseguire sempre prima una regolazione di massima, in modo che l'effetto si possa notare, e solo poi regolare per piccoli step. Segnare sempre sul file Setup Log tutte le variazioni con relativo feedback pilota","title":"REGOLAZIONE ASSETTO"},{"location":"setup-measurements-DMT/Home/#release-notes","text":"V1.0 28/06/2022 : Initial release (Davide Rudari) V1.1 16/08/2022 : Updated values and link to files (Davide Rudari)","title":"Release Notes"},{"location":"telemetry/","text":"Telemetry This repo contains telemetry codes allowing to log, send and parse all sensors data flowing in Fenice. This software is able to send and receive data to clients over a wireless connection. Telemetry App allows to communicate with telemetry. Introduction A telemetry software must log every piece of information of a specific system. The data should be saved in a simple and easy to access format. From the data acquired it must be possible to do analisys to detect problems, improve performances or to integrate new features. An important feature is to notify as soon as a problem is detected, allowing for an immediate fix.","title":"Telemetry"},{"location":"telemetry/#telemetry","text":"This repo contains telemetry codes allowing to log, send and parse all sensors data flowing in Fenice. This software is able to send and receive data to clients over a wireless connection. Telemetry App allows to communicate with telemetry.","title":"Telemetry"},{"location":"telemetry/#introduction","text":"A telemetry software must log every piece of information of a specific system. The data should be saved in a simple and easy to access format. From the data acquired it must be possible to do analisys to detect problems, improve performances or to integrate new features. An important feature is to notify as soon as a problem is detected, allowing for an immediate fix.","title":"Introduction"},{"location":"telemetry/Internal%20implementations/connection/","text":"Implement New Connection Type Introduction To create a new connection type you should just implement all virtual functions in the abstract Connection class, that is in the inc/connection.h file. Every message has to be of type Generic Message . The structure of this struct is show here below: struct GenericMessage { string topic; string payload; }; To generalize the connection type you have to implement a class that will contain all the things you'll need for the connection, such as the context and the socket. The class you're going to create must inherit from GeneralSocket class, a void class that has been created in the inc/connection.h file. Once you've done so, you can create your connection class, that will inherit from Connection (the abstract class mentioned above). Variables list All variables are protected and can be accessed from the derived class. The following variables are available: These variables are needed to set up the connection. You can only set them by calling the Connection 's init function, by passing to it them all. string address; // FORMAT EXAMPLE: 127.0.0.1 string port; // FORMAT EXAMPLE: 8080 int openMode; // FORMAT EXAMPLE: PUB/SUB (it's an enum) This is the object mentioned above, where should be stored your custom socket class. GeneralSocket* socket; These variables are checked inside the Connection class, so you have to manage them. For example: the open = true when the connection has started; the done = true when you close the connection; new_data should never be modify, because is managed by the Connection class. bool done; bool open; bool new_data; These variables are used in the Connection class to manage the reading and the writing operation. The mtx is used to lock the variables, so you can't read or write them at the same time; the cv is used to wait for the other thread to finish the operation; the buff_send is used to store the data that will be sent. mutex mtx; condition_variable cv; queue<message> buff_send; Methods to implement Here below the list of all the needed methods: The constructor should only call the Connection 's contrsuctor. // in the .cpp file [YOUR_CLASS]::[YOUR_CLASS]() : Connection() { // code here will be executed before the Connection constructor } The destructor should only call the Connection 's destructor and delete all pointers and other allocated variables. // in the .cpp file [YOUR_CLASS]::~[YOUR_CLASS]() { // code here will be executed before the Connection destructor delete [VARIABLE_NAME]; } The close connection function does not need parameter, because all connection items you'll need should be in the GeneralSocket item. In this function you have to manage the connection closing. void closeConnection(); The subscribe function should manage the subscriber's subscription to a spcified topic void subscribe(const string& topic); The subscribe function should manage the subscriber's unsubscription to a specified topic. void unsubscribe(const string& topic); The send message function should take a message type message and only send it. void sendMessage(const message& msg); The receive message function should call the receive function of your connection and save the arguments in the given message type message. void receiveMessage(message& msg); The start pub function have to start a PUB connection and then must create a thread calling the pubLoop(); function and return the thread. thread* startPub(); The start sub function have to start a SUB connection and then must create a thread calling the subLoop(); function and return the thread. thread* startSub(); Already implemented methods (in the Connection class) Public methods The init function sets the connection's variables. As told before, to set the connection's variables you have to call this function. void init(const string& address, const string& port, const int& openMode); The set data will create a message type message and insert it in the queue. void setData(string id, string data); The start function will start the connection using the parameter given to the init function. thread* start(); Protected methods This function is called by the start pub function. It will loop and check if the queue is not empty, if there's at least one message, it will call your send message function. void pubLoop(); This function is called by the start sub function. It will loop and check if there are messages to receive by calling your receive message function. The received message will be used by clbk_on_message . void subLoop(); This function will reset the connection's variables. void reset(); This function will stop and close the connection calling your close connection function. void stop(); This function will clear the queue. void clearData(); Callbacks Set callbacks This function will set the given function to the clbk_on_open variable. void add_on_open(function<void()>); This function will set the given function to the clbk_on_close variable. void add_on_close(function<void(const int& code)>); This function will set the given function to the clbk_on_error variable. void add_on_error(function<void(const int& code, const string& msg)>); This function will set the given function to the clbk_on_message variable. void add_on_message(function<void(const message&)>); This function will set the given function to the clbk_on_subscribe variable. void add_on_subscribe(function<void(const string&)>); This function will set the given function to the clbk_on_unsubscribe variable. void add_on_unsubscribe(function<void(const string&)>); Use callbacks This function will call the clbk_on_open callback. It have to be called when the connection is opened. void on_open(); This function will call the clbk_on_close callback. It have to be called when the connection is closed (also when fatal errors occur). The given code should be 0 if there's no error, otherwise it should be the error code. void on_close(const int& code); This function will call the clbk_on_error callback. It have to be called when an error occurs (remember to handle errors). It need the error code and the error message. void on_error(const int& code, const string& msg); This function will call the clbk_on_message callback. It's used in the sub loop function. It take the received message as a parameter. void on_message(const message& msg); This function will call the clbk_on_subscribe callback. It have to be called when a subscription is done. It take the topic as a parameter. void on_subscribe(const string& topic); This function will call the clbk_on_unsubscribe callback. It have to be called when an unsubscription is done. It take the topic as a parameter. void on_unsubscribe(const string& topic); Usage Create a connection Create a connection object. It will init connection variables. // the name should represent either the publisher or the subscriber [YOUR_CLASS] name; Init the connection. name.init(\"localhost\", \"1883\", PUB); // or name.init(\"localhost\", \"1883\", SUB); Set up the callbacks. // where [CALLBACK] is either open, close, error, message, subscribe, unsubscribe name.add_on_[CALLBACK]([&]() { // do something }); Start the connection. It will automatically run the pub loop or the sub loop , depending on the connection's mode setted in the init function. thread* thread_name = name.start(); Subscribe/unsubscribe to/from a topic or set data. name.subscribe(\"topic\"); // or name.unsubscribe(\"topic\"); // or // the topic should be the ID of the message name.setData(\"topic\", \"data\"); Close the connection. name.closeConnection(); Examples An example of the connection could be seen at src/zmq_connection.cpp , with the associated header at inc/zmq_connection.h . A working test example could be seen at scripts/testZMQ/test.cpp . It's a simple connection that will publish and subscribe to a topic. The example describes a ZMQ working connection between a publisher and a subscriber comunicating between two different threads.","title":"Implement New Connection Type"},{"location":"telemetry/Internal%20implementations/connection/#implement-new-connection-type","text":"","title":"Implement New Connection Type"},{"location":"telemetry/Internal%20implementations/connection/#introduction","text":"To create a new connection type you should just implement all virtual functions in the abstract Connection class, that is in the inc/connection.h file. Every message has to be of type Generic Message . The structure of this struct is show here below: struct GenericMessage { string topic; string payload; }; To generalize the connection type you have to implement a class that will contain all the things you'll need for the connection, such as the context and the socket. The class you're going to create must inherit from GeneralSocket class, a void class that has been created in the inc/connection.h file. Once you've done so, you can create your connection class, that will inherit from Connection (the abstract class mentioned above).","title":"Introduction"},{"location":"telemetry/Internal%20implementations/connection/#variables-list","text":"All variables are protected and can be accessed from the derived class. The following variables are available: These variables are needed to set up the connection. You can only set them by calling the Connection 's init function, by passing to it them all. string address; // FORMAT EXAMPLE: 127.0.0.1 string port; // FORMAT EXAMPLE: 8080 int openMode; // FORMAT EXAMPLE: PUB/SUB (it's an enum) This is the object mentioned above, where should be stored your custom socket class. GeneralSocket* socket; These variables are checked inside the Connection class, so you have to manage them. For example: the open = true when the connection has started; the done = true when you close the connection; new_data should never be modify, because is managed by the Connection class. bool done; bool open; bool new_data; These variables are used in the Connection class to manage the reading and the writing operation. The mtx is used to lock the variables, so you can't read or write them at the same time; the cv is used to wait for the other thread to finish the operation; the buff_send is used to store the data that will be sent. mutex mtx; condition_variable cv; queue<message> buff_send;","title":"Variables list"},{"location":"telemetry/Internal%20implementations/connection/#methods-to-implement","text":"Here below the list of all the needed methods: The constructor should only call the Connection 's contrsuctor. // in the .cpp file [YOUR_CLASS]::[YOUR_CLASS]() : Connection() { // code here will be executed before the Connection constructor } The destructor should only call the Connection 's destructor and delete all pointers and other allocated variables. // in the .cpp file [YOUR_CLASS]::~[YOUR_CLASS]() { // code here will be executed before the Connection destructor delete [VARIABLE_NAME]; } The close connection function does not need parameter, because all connection items you'll need should be in the GeneralSocket item. In this function you have to manage the connection closing. void closeConnection(); The subscribe function should manage the subscriber's subscription to a spcified topic void subscribe(const string& topic); The subscribe function should manage the subscriber's unsubscription to a specified topic. void unsubscribe(const string& topic); The send message function should take a message type message and only send it. void sendMessage(const message& msg); The receive message function should call the receive function of your connection and save the arguments in the given message type message. void receiveMessage(message& msg); The start pub function have to start a PUB connection and then must create a thread calling the pubLoop(); function and return the thread. thread* startPub(); The start sub function have to start a SUB connection and then must create a thread calling the subLoop(); function and return the thread. thread* startSub();","title":"Methods to implement"},{"location":"telemetry/Internal%20implementations/connection/#already-implemented-methods-in-the-connection-class","text":"","title":"Already implemented methods (in the Connection class)"},{"location":"telemetry/Internal%20implementations/connection/#public-methods","text":"The init function sets the connection's variables. As told before, to set the connection's variables you have to call this function. void init(const string& address, const string& port, const int& openMode); The set data will create a message type message and insert it in the queue. void setData(string id, string data); The start function will start the connection using the parameter given to the init function. thread* start();","title":"Public methods"},{"location":"telemetry/Internal%20implementations/connection/#protected-methods","text":"This function is called by the start pub function. It will loop and check if the queue is not empty, if there's at least one message, it will call your send message function. void pubLoop(); This function is called by the start sub function. It will loop and check if there are messages to receive by calling your receive message function. The received message will be used by clbk_on_message . void subLoop(); This function will reset the connection's variables. void reset(); This function will stop and close the connection calling your close connection function. void stop(); This function will clear the queue. void clearData();","title":"Protected methods"},{"location":"telemetry/Internal%20implementations/connection/#callbacks","text":"","title":"Callbacks"},{"location":"telemetry/Internal%20implementations/connection/#set-callbacks","text":"This function will set the given function to the clbk_on_open variable. void add_on_open(function<void()>); This function will set the given function to the clbk_on_close variable. void add_on_close(function<void(const int& code)>); This function will set the given function to the clbk_on_error variable. void add_on_error(function<void(const int& code, const string& msg)>); This function will set the given function to the clbk_on_message variable. void add_on_message(function<void(const message&)>); This function will set the given function to the clbk_on_subscribe variable. void add_on_subscribe(function<void(const string&)>); This function will set the given function to the clbk_on_unsubscribe variable. void add_on_unsubscribe(function<void(const string&)>);","title":"Set callbacks"},{"location":"telemetry/Internal%20implementations/connection/#use-callbacks","text":"This function will call the clbk_on_open callback. It have to be called when the connection is opened. void on_open(); This function will call the clbk_on_close callback. It have to be called when the connection is closed (also when fatal errors occur). The given code should be 0 if there's no error, otherwise it should be the error code. void on_close(const int& code); This function will call the clbk_on_error callback. It have to be called when an error occurs (remember to handle errors). It need the error code and the error message. void on_error(const int& code, const string& msg); This function will call the clbk_on_message callback. It's used in the sub loop function. It take the received message as a parameter. void on_message(const message& msg); This function will call the clbk_on_subscribe callback. It have to be called when a subscription is done. It take the topic as a parameter. void on_subscribe(const string& topic); This function will call the clbk_on_unsubscribe callback. It have to be called when an unsubscription is done. It take the topic as a parameter. void on_unsubscribe(const string& topic);","title":"Use callbacks"},{"location":"telemetry/Internal%20implementations/connection/#usage","text":"","title":"Usage"},{"location":"telemetry/Internal%20implementations/connection/#create-a-connection","text":"Create a connection object. It will init connection variables. // the name should represent either the publisher or the subscriber [YOUR_CLASS] name; Init the connection. name.init(\"localhost\", \"1883\", PUB); // or name.init(\"localhost\", \"1883\", SUB); Set up the callbacks. // where [CALLBACK] is either open, close, error, message, subscribe, unsubscribe name.add_on_[CALLBACK]([&]() { // do something }); Start the connection. It will automatically run the pub loop or the sub loop , depending on the connection's mode setted in the init function. thread* thread_name = name.start(); Subscribe/unsubscribe to/from a topic or set data. name.subscribe(\"topic\"); // or name.unsubscribe(\"topic\"); // or // the topic should be the ID of the message name.setData(\"topic\", \"data\"); Close the connection. name.closeConnection();","title":"Create a connection"},{"location":"telemetry/Internal%20implementations/connection/#examples","text":"An example of the connection could be seen at src/zmq_connection.cpp , with the associated header at inc/zmq_connection.h . A working test example could be seen at scripts/testZMQ/test.cpp . It's a simple connection that will publish and subscribe to a topic. The example describes a ZMQ working connection between a publisher and a subscriber comunicating between two different threads.","title":"Examples"},{"location":"telemetry/Internal%20implementations/file_transmission/","text":"File transmission This library allows sending and receiving files from telemetry. It is used to send to telemetry binary files that will be flashed on ECUs on the car. Some of the ECUs have the ability to update the firmware via CAN, so the telemetry receives the updated firmware and then flashes it to the correct ECU. Usage Fist establish a connection between sender and receiver. Then instantiate a transaction object: FileTransfer::FileTransferManager::transaction_t; There are two constructors, one for the sender and one for the receiver. Basically you must setup filename and destination path. And max_chunk_size (in bytes), a connection pointer, and a callback function. The callback function is used to notify the user about the events. A callback example is: file_transfer_callback callback = []( const int & id_ , TRANSACTION_EVENT event ){ cout << \"Transaction <\" << id << \"> event: \" << TRANSACTION_EVENT_STRING [ event ] << endl ; }; The FileTransferManager class is used to manage the transactions. Instantiate a FileTransfer::FileTransferManager object. This can be global as it can handle multiple file transfers (both send and receive). FileTransfer :: FileTransferManager ftm ; Send To start a file transfer for sending: Call FileTransfer::FileTransferManager::send(). The send function handles all the sending process, it creates a thread and returns the id of the transaction. The sending thread can fill the queue with messages, but checks the queue rememaining size before sending, to avoid messages being dropped. Create a transaction object: FileTransfer::FileTransferManager::transaction_t; with the sender constructor: FileTransfer :: FileTransferManager :: transaction_t transaction ( \"bin/telemetry\" , // filename \"bin\" , // destination path & conn , // connection pointer \"file_transfer\" , // topic 4096 , // max_chunk_size in bytes callback // callback function ); Then simply to start sending the file: int transaction_id = ftm . send ( transaction ); if ( transaction_id == -1 ){ printf ( \"Failed to send file \\n\\r \" ); } The send sequence is: The transaction begin mesage is sent. File chunks are sent in order. The transaction end message is sent. Transaction begin message { \"filename\" : \"telemetry\" , \"dest_path\" : \"bin/\" , \"total_chunks\" : 1000 , \"transaction_hash\" : 000 } The transaction hash is done on filename and destination path, so two transactions can have the same hash. Total chunks is the number of chunks that will be sent. Chunk message { \"chunk_n\" : 1 , \"chunk_total\" : 1 , \"transaction_hash\" : 000 , \"data\" : \"chunk data\" } Transaction end message { \"transaction_hash\" : 000 ; } Receive A receiving transaction is defined by the topic_begin, from that message you can get the filename, destination path and total_chunks. When receiving topic_begin call FileTransfer::FileTransferManager::init_receive(). Each time you receive a topic you can get the chunk_id and the data, and call FileTransfer::FileTransferManager::receive(). The transaction end is notified by the topic_end message. When the transaction is finished you can call FileTransfer::FileTransferManager::end_receive(). This function can return false if not all chunks were received. The receiver must handle the link beween the transaction hash and the transaction id. A simple way is to use a hash table. // key: transaction hash // value: transaction id std :: unordered_map < int , int > transfers ; When receiving a transaction begin message, create a transaction object: FileTransfer::FileTransferManager::transaction_t; with the receiver constructor: FileTransfer :: FileTransferManager :: transaction_t rcv_transaction ( message . filename , message . dest_path , message . total_chunks , callback ); Then initialize the receiving transaction and save the transaction id: int id = ftm . init_receive ( rcv_transaction ); if ( id != -1 ){ transfers . insert ({ message . transaction_hash , id }); printf ( \"<%d> -> %s \\n\\r \" , message . transaction_hash , message . filename . c_str ()); } else { printf ( \"Failed to receive file %s \\n\\r \" , message . filename . c_str ()); } When receiving a chunk message, check if the transaction id is in the hash table. If it is, then save the chunk: auto it = transfers . find ( chunk . transaction_hash ); if ( it != transfers . end ()){ if ( ! ftm . receive ( it -> second , msg )){ printf ( \"FileTranferManager did not find transaction\" ); } else { printf ( \"<%d> received chunk %d of %d: %f \\n \" , chunk . transaction_hash , chunk . chunk_n , chunk . chunk_total , ( float ) chunk . chunk_n / chunk . chunk_total ); } } else { printf ( \"Transaction id unrecognized %d \\n\\r \" , chunk . transaction_hash ); } When receiving a transaction end message, check if the transaction id is in the hash table. If it is, then finish the transaction: auto it = transfers . find ( chunk . transaction_hash ); if ( it != transfers . end ()){ if ( ftm . end_receive ( it -> second )){ transfers . erase ( it ); printf ( \"<%d> -> End \\n\\r \" , chunk . transaction_hash ); } else { printf ( \"<%d> -> FAILED end receive \\n\\r \" , chunk . transaction_hash ); } } else { printf ( \"End transaction failed \\n\\r \" ); }","title":"File transmission"},{"location":"telemetry/Internal%20implementations/file_transmission/#file-transmission","text":"This library allows sending and receiving files from telemetry. It is used to send to telemetry binary files that will be flashed on ECUs on the car. Some of the ECUs have the ability to update the firmware via CAN, so the telemetry receives the updated firmware and then flashes it to the correct ECU.","title":"File transmission"},{"location":"telemetry/Internal%20implementations/file_transmission/#usage","text":"Fist establish a connection between sender and receiver. Then instantiate a transaction object: FileTransfer::FileTransferManager::transaction_t; There are two constructors, one for the sender and one for the receiver. Basically you must setup filename and destination path. And max_chunk_size (in bytes), a connection pointer, and a callback function. The callback function is used to notify the user about the events. A callback example is: file_transfer_callback callback = []( const int & id_ , TRANSACTION_EVENT event ){ cout << \"Transaction <\" << id << \"> event: \" << TRANSACTION_EVENT_STRING [ event ] << endl ; }; The FileTransferManager class is used to manage the transactions. Instantiate a FileTransfer::FileTransferManager object. This can be global as it can handle multiple file transfers (both send and receive). FileTransfer :: FileTransferManager ftm ;","title":"Usage"},{"location":"telemetry/Internal%20implementations/file_transmission/#send","text":"To start a file transfer for sending: Call FileTransfer::FileTransferManager::send(). The send function handles all the sending process, it creates a thread and returns the id of the transaction. The sending thread can fill the queue with messages, but checks the queue rememaining size before sending, to avoid messages being dropped. Create a transaction object: FileTransfer::FileTransferManager::transaction_t; with the sender constructor: FileTransfer :: FileTransferManager :: transaction_t transaction ( \"bin/telemetry\" , // filename \"bin\" , // destination path & conn , // connection pointer \"file_transfer\" , // topic 4096 , // max_chunk_size in bytes callback // callback function ); Then simply to start sending the file: int transaction_id = ftm . send ( transaction ); if ( transaction_id == -1 ){ printf ( \"Failed to send file \\n\\r \" ); } The send sequence is: The transaction begin mesage is sent. File chunks are sent in order. The transaction end message is sent. Transaction begin message { \"filename\" : \"telemetry\" , \"dest_path\" : \"bin/\" , \"total_chunks\" : 1000 , \"transaction_hash\" : 000 } The transaction hash is done on filename and destination path, so two transactions can have the same hash. Total chunks is the number of chunks that will be sent. Chunk message { \"chunk_n\" : 1 , \"chunk_total\" : 1 , \"transaction_hash\" : 000 , \"data\" : \"chunk data\" } Transaction end message { \"transaction_hash\" : 000 ; }","title":"Send"},{"location":"telemetry/Internal%20implementations/file_transmission/#receive","text":"A receiving transaction is defined by the topic_begin, from that message you can get the filename, destination path and total_chunks. When receiving topic_begin call FileTransfer::FileTransferManager::init_receive(). Each time you receive a topic you can get the chunk_id and the data, and call FileTransfer::FileTransferManager::receive(). The transaction end is notified by the topic_end message. When the transaction is finished you can call FileTransfer::FileTransferManager::end_receive(). This function can return false if not all chunks were received. The receiver must handle the link beween the transaction hash and the transaction id. A simple way is to use a hash table. // key: transaction hash // value: transaction id std :: unordered_map < int , int > transfers ; When receiving a transaction begin message, create a transaction object: FileTransfer::FileTransferManager::transaction_t; with the receiver constructor: FileTransfer :: FileTransferManager :: transaction_t rcv_transaction ( message . filename , message . dest_path , message . total_chunks , callback ); Then initialize the receiving transaction and save the transaction id: int id = ftm . init_receive ( rcv_transaction ); if ( id != -1 ){ transfers . insert ({ message . transaction_hash , id }); printf ( \"<%d> -> %s \\n\\r \" , message . transaction_hash , message . filename . c_str ()); } else { printf ( \"Failed to receive file %s \\n\\r \" , message . filename . c_str ()); } When receiving a chunk message, check if the transaction id is in the hash table. If it is, then save the chunk: auto it = transfers . find ( chunk . transaction_hash ); if ( it != transfers . end ()){ if ( ! ftm . receive ( it -> second , msg )){ printf ( \"FileTranferManager did not find transaction\" ); } else { printf ( \"<%d> received chunk %d of %d: %f \\n \" , chunk . transaction_hash , chunk . chunk_n , chunk . chunk_total , ( float ) chunk . chunk_n / chunk . chunk_total ); } } else { printf ( \"Transaction id unrecognized %d \\n\\r \" , chunk . transaction_hash ); } When receiving a transaction end message, check if the transaction id is in the hash table. If it is, then finish the transaction: auto it = transfers . find ( chunk . transaction_hash ); if ( it != transfers . end ()){ if ( ftm . end_receive ( it -> second )){ transfers . erase ( it ); printf ( \"<%d> -> End \\n\\r \" , chunk . transaction_hash ); } else { printf ( \"<%d> -> FAILED end receive \\n\\r \" , chunk . transaction_hash ); } } else { printf ( \"End transaction failed \\n\\r \" ); }","title":"Receive"},{"location":"telemetry/Internal%20implementations/json_loading/","text":"Json Loading Telemetry heavily relies on JSON files to store configurations and to send messages. From c++ lots of libraries are used to serialize and deserialize the data, this is a bit of a pain to use. One of the fastest JSON libraries is rapidjson . It is important to be able to load all JSON files/messages in a fast and easy way, checking if they are valid to avoid errors. Because of this a code generator was implemented to generate c++ structs thar represents the JSON files, and with them also all the other utility functions. Including int project In only one file define these macro to enable the json loader definitions in the project: #define __JSON_LOADER_DEFINITION__ #define __MESSAGES_JSON_IMPLEMENTATION__ Where MESSAGES is the header file of the messages. Struct Generation Supported types are: int double string bool vectors objects and vector of objects (also multiple levels of nesting) Simple JSON This JSON: { \"Messages\" : 351245 , \"Average_Frequency_Hz\" : 3078 , \"Duration_seconds\" : 114.093 } Will generate the following c++ struct: typedef struct stat_json { int Messages ; int Average_Frequency_Hz ; double Duration_seconds ; } stat_json ; Where stat_json is the filename used in the code generator. Complex JSON This JSON: { \"type\" : \"telemetry_status\" , \"timestamp\" : 0.0 , \"data\" : 1 , \"msgs_per_second\" : [ { \"device\" : \"name\" , \"count\" : 1 } ], \"camera_status\" : \"fail\" , \"cpu_process_load\" : 10 } Will generate the following c++ structs: typedef struct msgs_per_second_o { std :: string device ; int count ; } msgs_per_second_o ; typedef struct telemetry_status { std :: string type ; double timestamp ; int data ; std :: vector < msgs_per_second_o > msgs_per_second ; std :: string camera_status ; int cpu_process_load ; } telemetry_status ; Logging If the application is using logging functions the JSON loader exposes a macro to define the log function that will be used to log messages, for example when checking JSON. Default log function is: #ifndef JSON_LOG_FUNC #define JSON_LOG_FUNC(msg) std::cout << msg << std::endl; #endif Functions The so called main structs are the struct of the first level of nesting. These are the only one that can use LoadJson, SaveJson, StructToString, and StringToStruct. // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T , class J > bool CheckJson ( const T & obj , const J & doc ); // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T , class J > void Deserialize ( T & obj , J & doc ); template < class T > void Serialize ( rapidjson :: Document & out , const T & obj ); template < class T > void Serialize ( rapidjson :: Value & out , const T & obj , rapidjson :: Document :: AllocatorType & alloc ); // ---- Main structs only ---- // // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T > bool LoadStruct ( T & out , const std :: string & path ); template < class T > void SaveStruct ( const T & obj , const std :: string & path ); template < class T > std :: string StructToString ( const T & obj ); template < class T > bool StringToStruct ( const std :: string & obj_str , T & obj ); CheckJson checks if all the required fields are present in the JSON file, doesn't throw any exceptions but returns false if any of the required fields is missing. The missing fields are logged using JSON_LOG_FUNC . LoadStruct loads a JSON file and deserializes it into a struct. Before loading the JSON file it checks if it is valid. If it is not valid it logs the error using JSON_LOG_FUNC . If the JSON has some missing fileds it will still load all the valid one. SaveStruct saves a struct into a JSON file. StructToString converts a struct to a string. StringToStruct converts a JSON formatted string to a struct, as always checks the JSON before deserializing. Deserialize deserializes a JSON file into a struct. Serialize serializes a struct into a JSON file.","title":"Json Loading"},{"location":"telemetry/Internal%20implementations/json_loading/#json-loading","text":"Telemetry heavily relies on JSON files to store configurations and to send messages. From c++ lots of libraries are used to serialize and deserialize the data, this is a bit of a pain to use. One of the fastest JSON libraries is rapidjson . It is important to be able to load all JSON files/messages in a fast and easy way, checking if they are valid to avoid errors. Because of this a code generator was implemented to generate c++ structs thar represents the JSON files, and with them also all the other utility functions.","title":"Json Loading"},{"location":"telemetry/Internal%20implementations/json_loading/#including-int-project","text":"In only one file define these macro to enable the json loader definitions in the project: #define __JSON_LOADER_DEFINITION__ #define __MESSAGES_JSON_IMPLEMENTATION__ Where MESSAGES is the header file of the messages.","title":"Including int project"},{"location":"telemetry/Internal%20implementations/json_loading/#struct-generation","text":"Supported types are: int double string bool vectors objects and vector of objects (also multiple levels of nesting)","title":"Struct Generation"},{"location":"telemetry/Internal%20implementations/json_loading/#simple-json","text":"This JSON: { \"Messages\" : 351245 , \"Average_Frequency_Hz\" : 3078 , \"Duration_seconds\" : 114.093 } Will generate the following c++ struct: typedef struct stat_json { int Messages ; int Average_Frequency_Hz ; double Duration_seconds ; } stat_json ; Where stat_json is the filename used in the code generator.","title":"Simple JSON"},{"location":"telemetry/Internal%20implementations/json_loading/#complex-json","text":"This JSON: { \"type\" : \"telemetry_status\" , \"timestamp\" : 0.0 , \"data\" : 1 , \"msgs_per_second\" : [ { \"device\" : \"name\" , \"count\" : 1 } ], \"camera_status\" : \"fail\" , \"cpu_process_load\" : 10 } Will generate the following c++ structs: typedef struct msgs_per_second_o { std :: string device ; int count ; } msgs_per_second_o ; typedef struct telemetry_status { std :: string type ; double timestamp ; int data ; std :: vector < msgs_per_second_o > msgs_per_second ; std :: string camera_status ; int cpu_process_load ; } telemetry_status ;","title":"Complex JSON"},{"location":"telemetry/Internal%20implementations/json_loading/#logging","text":"If the application is using logging functions the JSON loader exposes a macro to define the log function that will be used to log messages, for example when checking JSON. Default log function is: #ifndef JSON_LOG_FUNC #define JSON_LOG_FUNC(msg) std::cout << msg << std::endl; #endif","title":"Logging"},{"location":"telemetry/Internal%20implementations/json_loading/#functions","text":"The so called main structs are the struct of the first level of nesting. These are the only one that can use LoadJson, SaveJson, StructToString, and StringToStruct. // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T , class J > bool CheckJson ( const T & obj , const J & doc ); // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T , class J > void Deserialize ( T & obj , J & doc ); template < class T > void Serialize ( rapidjson :: Document & out , const T & obj ); template < class T > void Serialize ( rapidjson :: Value & out , const T & obj , rapidjson :: Document :: AllocatorType & alloc ); // ---- Main structs only ---- // // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T > bool LoadStruct ( T & out , const std :: string & path ); template < class T > void SaveStruct ( const T & obj , const std :: string & path ); template < class T > std :: string StructToString ( const T & obj ); template < class T > bool StringToStruct ( const std :: string & obj_str , T & obj ); CheckJson checks if all the required fields are present in the JSON file, doesn't throw any exceptions but returns false if any of the required fields is missing. The missing fields are logged using JSON_LOG_FUNC . LoadStruct loads a JSON file and deserializes it into a struct. Before loading the JSON file it checks if it is valid. If it is not valid it logs the error using JSON_LOG_FUNC . If the JSON has some missing fileds it will still load all the valid one. SaveStruct saves a struct into a JSON file. StructToString converts a struct to a string. StringToStruct converts a JSON formatted string to a struct, as always checks the JSON before deserializing. Deserialize deserializes a JSON file into a struct. Serialize serializes a struct into a JSON file.","title":"Functions"},{"location":"telemetry/Overview/features/","text":"Features All the features that this repo implemented! Logging The most important feature is to be able to log all data coming from sensors in the car. The raw format, saving every CANbus message as it is, prepending the timestamp. The parsed format, saving directly parsed messages to .CSV files (one for each sensor). Extra information, like date/time, pilot who drove the car, circuit on which was racing on, race type, a specific race configuration, etc... Lastly has been added the onboard video logging, saving a synced video with low resolution and framerate to reduce video size. This helps a lot to recognize which specific race was and mostly reconstruct how the race gone. CSV When the race session ends, from a raw file (only CANbus messages) is really important to be able to generate files containing usable data from the sensors. The most common and simple way to save this kind of data is with CSV files (comma separated values). CSV files are simple to use to be imported and to be procecced. To analyze car performances the team uses Matlab which is kinda slow loading CSV files, a better format for that specific application is .mat, in this repo under python folder there is a script wich converts CSV files to .mat files. Connection Telemetry can transmit data over wireless connection, it uses Websocket (most used) and MQTT, in the future it will also support radio transmission. The connection is used to send status messages to the clients and to receive configurations from the clients. The configurations are used to change the behavior of the telemetry, to enable or disable CSV parsing, enable GPSs, etc... Realtime Data The data is transmitted in realtime, so the user can see the data as it is being received. Sensor data are serialized using Google protobuffers, the serialization and deserialization is implemented in canlib. It can be configured the send rate and the downsample, so reducing the messages sent to the user. Report Really cool feature. Automatic report generator, from a race session generates a PDF file containing plots and basic information about that race, this is really usefull to have a quick analisys of the sensor data, easy to check if sensors were working properly.","title":"Features"},{"location":"telemetry/Overview/features/#features","text":"All the features that this repo implemented!","title":"Features"},{"location":"telemetry/Overview/features/#logging","text":"The most important feature is to be able to log all data coming from sensors in the car. The raw format, saving every CANbus message as it is, prepending the timestamp. The parsed format, saving directly parsed messages to .CSV files (one for each sensor). Extra information, like date/time, pilot who drove the car, circuit on which was racing on, race type, a specific race configuration, etc... Lastly has been added the onboard video logging, saving a synced video with low resolution and framerate to reduce video size. This helps a lot to recognize which specific race was and mostly reconstruct how the race gone.","title":"Logging"},{"location":"telemetry/Overview/features/#csv","text":"When the race session ends, from a raw file (only CANbus messages) is really important to be able to generate files containing usable data from the sensors. The most common and simple way to save this kind of data is with CSV files (comma separated values). CSV files are simple to use to be imported and to be procecced. To analyze car performances the team uses Matlab which is kinda slow loading CSV files, a better format for that specific application is .mat, in this repo under python folder there is a script wich converts CSV files to .mat files.","title":"CSV"},{"location":"telemetry/Overview/features/#connection","text":"Telemetry can transmit data over wireless connection, it uses Websocket (most used) and MQTT, in the future it will also support radio transmission. The connection is used to send status messages to the clients and to receive configurations from the clients. The configurations are used to change the behavior of the telemetry, to enable or disable CSV parsing, enable GPSs, etc...","title":"Connection"},{"location":"telemetry/Overview/features/#realtime-data","text":"The data is transmitted in realtime, so the user can see the data as it is being received. Sensor data are serialized using Google protobuffers, the serialization and deserialization is implemented in canlib. It can be configured the send rate and the downsample, so reducing the messages sent to the user.","title":"Realtime Data"},{"location":"telemetry/Overview/features/#report","text":"Really cool feature. Automatic report generator, from a race session generates a PDF file containing plots and basic information about that race, this is really usefull to have a quick analisys of the sensor data, easy to check if sensors were working properly.","title":"Report"},{"location":"telemetry/Overview/report/","text":"Report When a race finishes it is really important to have an analisys on how the car and the sensors behaved, if some sensors failed and if yes when and why. The best way to have a general view is via graphs. This telemetry feature generates a PDF report containing race informations and basic race stats (max speed etc...) and most importantly plots of every sensor, including GPS trajectories. Here is an example","title":"Report"},{"location":"telemetry/Overview/report/#report","text":"When a race finishes it is really important to have an analisys on how the car and the sensors behaved, if some sensors failed and if yes when and why. The best way to have a general view is via graphs. This telemetry feature generates a PDF report containing race informations and basic race stats (max speed etc...) and most importantly plots of every sensor, including GPS trajectories. Here is an example","title":"Report"},{"location":"telemetry/Setup%20and%20Installation/installation/","text":"Installation Is a large project so it needs some time to be installed properly. Documentation is always not exaustive enough but I'll try my best. This installation procedure is tested and written only for Linux, this is because is developed on Linux and the telemetry software is running on a RaspberryPi, sooo... Clone the repo with git clone --recursive https://github.com/eagletrt/telemetry.git Requirements Required cmake and other stuff to compile the project: sudo apt install build-essential cmake can-utils libboost-iostreams-dev libboost-system-dev libboost-filesystem-dev Required Google Protobuf sudo apt-get install libprotobuf-dev libprotoc-dev Websocketpp git clone git://github.com/zaphoyd/websocketpp.git cd websocketpp cmake . sudo make install GNU PLOT Sorry read the docs to install it git clone https://github.com/dstahlke/gnuplot-iostream.git Raspi Cam git clone https://github.com/rmsalinas/raspicam cd raspicam mkdir build cd build cmake .. make sudo make install sudo ldconfig LibHaru libharu is a submodule in this repo but needs a couple of commands to work properly. cd thirdparty/libharu buildconf.sh ./configure OpenCV This is the latest added so please wait for the installation, OpenCV is a HUGE library but for this project only a tiny part is required. This guide will avoid installing the whole library. Building cd Protobuffer mkdir cpp chmod +X compile ./compile Once all the requirements are installed: mkdir build cd build cmake .. make Most of the times running the cmake and make commands generates lots of errors, please contact the developer to be helped and to allow him to integrate this giude with possible solutions. All the generated binaries are located in bin folder.","title":"Installation"},{"location":"telemetry/Setup%20and%20Installation/installation/#installation","text":"Is a large project so it needs some time to be installed properly. Documentation is always not exaustive enough but I'll try my best. This installation procedure is tested and written only for Linux, this is because is developed on Linux and the telemetry software is running on a RaspberryPi, sooo... Clone the repo with git clone --recursive https://github.com/eagletrt/telemetry.git","title":"Installation"},{"location":"telemetry/Setup%20and%20Installation/installation/#requirements","text":"Required cmake and other stuff to compile the project: sudo apt install build-essential cmake can-utils libboost-iostreams-dev libboost-system-dev libboost-filesystem-dev Required Google Protobuf sudo apt-get install libprotobuf-dev libprotoc-dev Websocketpp git clone git://github.com/zaphoyd/websocketpp.git cd websocketpp cmake . sudo make install GNU PLOT Sorry read the docs to install it git clone https://github.com/dstahlke/gnuplot-iostream.git Raspi Cam git clone https://github.com/rmsalinas/raspicam cd raspicam mkdir build cd build cmake .. make sudo make install sudo ldconfig LibHaru libharu is a submodule in this repo but needs a couple of commands to work properly. cd thirdparty/libharu buildconf.sh ./configure OpenCV This is the latest added so please wait for the installation, OpenCV is a HUGE library but for this project only a tiny part is required. This guide will avoid installing the whole library.","title":"Requirements"},{"location":"telemetry/Setup%20and%20Installation/installation/#building","text":"cd Protobuffer mkdir cpp chmod +X compile ./compile Once all the requirements are installed: mkdir build cd build cmake .. make Most of the times running the cmake and make commands generates lots of errors, please contact the developer to be helped and to allow him to integrate this giude with possible solutions. All the generated binaries are located in bin folder.","title":"Building"},{"location":"telemetry/Setup%20and%20Installation/setup/","text":"Telemetry Usage Running To run check if the device you are using has a CAN interface: ifconfig In the infos displayed make sure can0 / can1 / vcan0 device is shown, if not: if you want to test on an actual CAN interface run bash canSetup.sh , if you want to use a symulated interface run bash vcanSetup.sh . Then to run the actual telemetry use: ./bin/telemetry The script will log lots of informations, check for eventual errors and contact the developer for help. Telemetry generates a debug file in which all the debug/warn/errors are logged. This file is in home folder: ~/telemetry_debug.log . Configurations At the first telemetry run, it generates some .json files that can be used to configure how the code acts. All configs are in home folder ( ~ ). The most important is fenice_telemetry_config.json . fenice_telemetry_config.json field type meaning can_devices vector of objects Each object must contain: - sock: name of the interface (can0 ...) - name: primary/secondary gps_devices vector of objects each entry corresponds to a gps device, objects must have these fields: - addr: port/file name - mode port/file - enabled boolean generate_csv bool enables generation of .csv files while telemetry logs camera_enable bool enables video logging from raspicam connection_enabled bool enables communication over internet (websockets) connection_send_rate int milliseconds between each sensor data ws message connection_send_sensor_data bool enables sending parsed sensor data over ws connection_downsample bool enables downsample of sensors to reduce packet size connection_downsample_mps int mps -> messages per second -> maximum number of messages added in each packet connection object fields: - ip - port - mode WEBSOCKET or ZEROMQ or MQTT to define wich protocol is used example { \"can_devices\" : [ { \"sock\" : \"vcan0\" , \"name\" : \"primary\" }, { \"sock\" : \"vcan1\" , \"name\" : \"secondary\" } ], \"gps_devices\" : [ { \"addr\" : \"/dev/ttyACM1\" , \"mode\" : \"port\" , \"enabled\" : true } ], \"generate_csv\" : true , \"camera_enable\" : true , \"connection_downsample\" : false , \"connection_downsample_mps\" : 40 , \"connection_enabled\" : true , \"connection_send_rate\" : 100 , \"connection_send_sensor_data\" : true , \"connection\" : { \"ip\" : \"telemetry-server.herokuapp.com\" , \"port\" : \"\" , \"mode\" : \"WEBSOCKET\" } } session_config.json Configures a race session. This informations are used to generate folder names for each log session. field type meaning Circuit string name of the race circuit Pilot string name of the pilot Race string type of race ( acceleration/skidpad/trakdrive etc) Configuration string current race configuration, for example test at 40 Km/h or car power map 40 % etc Date string date of the test gg_mm_yyyy Time string time of the test HH:MM:SS example { \"Circuit\" : \"Vadena\" , \"Pilot\" : \"Mirco\" , \"Race\" : \"Half Skidpad (velocit\u00e0 costante)\" , \"Configuration\" : \"Bassa - 40%\" , \"Date\" : \"21_03_2022\" , \"Time\" : \"00:12:49\" } When telemetry starts logging a folder is generated to contain all the current log infos/files. The folder name is constructed like: ~/logs/<date>/<race> [<configuration>] <incremental number>/ Example: ~/logs/14_03_2022/Straight line [40 km h] 7 Where Straight line is field Race , 40 km h is Configuration and 7 is the 7th logging session whith same configurations. Starting Using the telemetry application . Or can be started with a CAN message defined in canlib: SET_TLM_STATUS The can message can be sent from an onboard device, in our case the steering wheel has a button that sends start/stop messages to telemetry. Output The data that telemetry produces can be found in: ~/logs/<date>/<race> [<configuration>] Folder names are explained here . Files that telemetry produces: Raw : - candump.log: contains all raw CAN messages. - gps_n.log: n is the index of the device (index in the vector of gps devices defined in telemetry_config.json ), contains raw strings coming from GPS device. Stats : - CAN_Info.json: json formatted file containing the session infos like Race, Pilot, Configuration and some extra informations about CAN messages: number and frequency during the log session. - gps_n.json: contains date and time of the log and informations about gps messages: number and frequency. CSV : If generate_csv option is enabled, in a subfolder are located a bunch of .csv files, one for each sensor logged. The files are named as the sensor. The first line is a header, contains the column value name. Every other line is the actual sensor value. Example Pedals.csv contains the sensors values of the \"pedals\". Header timestamp,throttle1,throttle2,brake_front,brake_rear, Couple of lines 1637591203.904133,28.000000,68.000000,1.246000,1.112000, 1637591203.913102,30.000000,67.000000,1.246000,1.112000, 1637591203.914190,30.000000,67.000000,1.328000,1.084000, 1637591203.923164,29.000000,67.000000,1.328000,1.084000, 1637591203.924087,29.000000,67.000000,1.302000,1.084000, 1637591203.933217,29.000000,67.000000,1.302000,1.084000, 1637591203.934093,29.000000,67.000000,1.328000,1.112000, 1637591203.943089,30.000000,67.000000,1.328000,1.112000, 1637591203.944154,30.000000,67.000000,1.246000,1.138000, 1637591203.953122,31.000000,65.000000,1.246000,1.138000, 1637591203.954210,31.000000,65.000000,1.246000,1.138000, 1637591203.963181,33.000000,65.000000,1.246000,1.138000, 1637591203.964085,33.000000,65.000000,1.328000,1.138000, Split each line by comma and the result is a vector of values, each column value refers to the column name defined in the header.","title":"Telemetry Usage"},{"location":"telemetry/Setup%20and%20Installation/setup/#telemetry-usage","text":"","title":"Telemetry Usage"},{"location":"telemetry/Setup%20and%20Installation/setup/#running","text":"To run check if the device you are using has a CAN interface: ifconfig In the infos displayed make sure can0 / can1 / vcan0 device is shown, if not: if you want to test on an actual CAN interface run bash canSetup.sh , if you want to use a symulated interface run bash vcanSetup.sh . Then to run the actual telemetry use: ./bin/telemetry The script will log lots of informations, check for eventual errors and contact the developer for help. Telemetry generates a debug file in which all the debug/warn/errors are logged. This file is in home folder: ~/telemetry_debug.log .","title":"Running"},{"location":"telemetry/Setup%20and%20Installation/setup/#configurations","text":"At the first telemetry run, it generates some .json files that can be used to configure how the code acts. All configs are in home folder ( ~ ). The most important is fenice_telemetry_config.json .","title":"Configurations"},{"location":"telemetry/Setup%20and%20Installation/setup/#fenice_telemetry_configjson","text":"field type meaning can_devices vector of objects Each object must contain: - sock: name of the interface (can0 ...) - name: primary/secondary gps_devices vector of objects each entry corresponds to a gps device, objects must have these fields: - addr: port/file name - mode port/file - enabled boolean generate_csv bool enables generation of .csv files while telemetry logs camera_enable bool enables video logging from raspicam connection_enabled bool enables communication over internet (websockets) connection_send_rate int milliseconds between each sensor data ws message connection_send_sensor_data bool enables sending parsed sensor data over ws connection_downsample bool enables downsample of sensors to reduce packet size connection_downsample_mps int mps -> messages per second -> maximum number of messages added in each packet connection object fields: - ip - port - mode WEBSOCKET or ZEROMQ or MQTT to define wich protocol is used example { \"can_devices\" : [ { \"sock\" : \"vcan0\" , \"name\" : \"primary\" }, { \"sock\" : \"vcan1\" , \"name\" : \"secondary\" } ], \"gps_devices\" : [ { \"addr\" : \"/dev/ttyACM1\" , \"mode\" : \"port\" , \"enabled\" : true } ], \"generate_csv\" : true , \"camera_enable\" : true , \"connection_downsample\" : false , \"connection_downsample_mps\" : 40 , \"connection_enabled\" : true , \"connection_send_rate\" : 100 , \"connection_send_sensor_data\" : true , \"connection\" : { \"ip\" : \"telemetry-server.herokuapp.com\" , \"port\" : \"\" , \"mode\" : \"WEBSOCKET\" } }","title":"fenice_telemetry_config.json"},{"location":"telemetry/Setup%20and%20Installation/setup/#session_configjson","text":"Configures a race session. This informations are used to generate folder names for each log session. field type meaning Circuit string name of the race circuit Pilot string name of the pilot Race string type of race ( acceleration/skidpad/trakdrive etc) Configuration string current race configuration, for example test at 40 Km/h or car power map 40 % etc Date string date of the test gg_mm_yyyy Time string time of the test HH:MM:SS example { \"Circuit\" : \"Vadena\" , \"Pilot\" : \"Mirco\" , \"Race\" : \"Half Skidpad (velocit\u00e0 costante)\" , \"Configuration\" : \"Bassa - 40%\" , \"Date\" : \"21_03_2022\" , \"Time\" : \"00:12:49\" } When telemetry starts logging a folder is generated to contain all the current log infos/files. The folder name is constructed like: ~/logs/<date>/<race> [<configuration>] <incremental number>/ Example: ~/logs/14_03_2022/Straight line [40 km h] 7 Where Straight line is field Race , 40 km h is Configuration and 7 is the 7th logging session whith same configurations.","title":"session_config.json"},{"location":"telemetry/Setup%20and%20Installation/setup/#starting","text":"Using the telemetry application . Or can be started with a CAN message defined in canlib: SET_TLM_STATUS The can message can be sent from an onboard device, in our case the steering wheel has a button that sends start/stop messages to telemetry.","title":"Starting"},{"location":"telemetry/Setup%20and%20Installation/setup/#output","text":"The data that telemetry produces can be found in: ~/logs/<date>/<race> [<configuration>] Folder names are explained here . Files that telemetry produces: Raw : - candump.log: contains all raw CAN messages. - gps_n.log: n is the index of the device (index in the vector of gps devices defined in telemetry_config.json ), contains raw strings coming from GPS device. Stats : - CAN_Info.json: json formatted file containing the session infos like Race, Pilot, Configuration and some extra informations about CAN messages: number and frequency during the log session. - gps_n.json: contains date and time of the log and informations about gps messages: number and frequency. CSV : If generate_csv option is enabled, in a subfolder are located a bunch of .csv files, one for each sensor logged. The files are named as the sensor. The first line is a header, contains the column value name. Every other line is the actual sensor value. Example Pedals.csv contains the sensors values of the \"pedals\". Header timestamp,throttle1,throttle2,brake_front,brake_rear, Couple of lines 1637591203.904133,28.000000,68.000000,1.246000,1.112000, 1637591203.913102,30.000000,67.000000,1.246000,1.112000, 1637591203.914190,30.000000,67.000000,1.328000,1.084000, 1637591203.923164,29.000000,67.000000,1.328000,1.084000, 1637591203.924087,29.000000,67.000000,1.302000,1.084000, 1637591203.933217,29.000000,67.000000,1.302000,1.084000, 1637591203.934093,29.000000,67.000000,1.328000,1.112000, 1637591203.943089,30.000000,67.000000,1.328000,1.112000, 1637591203.944154,30.000000,67.000000,1.246000,1.138000, 1637591203.953122,31.000000,65.000000,1.246000,1.138000, 1637591203.954210,31.000000,65.000000,1.246000,1.138000, 1637591203.963181,33.000000,65.000000,1.246000,1.138000, 1637591203.964085,33.000000,65.000000,1.328000,1.138000, Split each line by comma and the result is a vector of values, each column value refers to the column name defined in the header.","title":"Output"},{"location":"telemetry-json-loader/","text":"JSON Loader This project allows generating c++ json loader classes from json files. Given json as input it detects all fields (structs, vectors ...) and generates c++ code for loading them. The json library used is rapidjson Usage Input files are located under json_input , each subfolder will later represent a .h file. Each .json file will be parsed and will be added to the corresponding .h file. These .json file are called Main Structs, and some functions generated supports only Main Structs. Nested structs are called Secondary structs, and cannot be loaded directly. The generated code is placed in out or in branch build. Functions generated // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T , class J > bool CheckJson ( const T & obj , const J & doc ); // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T , class J > void Deserialize ( T & obj , J & doc ); template < class T > void Serialize ( rapidjson :: Document & out , const T & obj ); template < class T > void Serialize ( rapidjson :: Value & out , const T & obj , rapidjson :: Document :: AllocatorType & alloc ); // If this is a main struct: // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T > bool LoadStruct ( T & out , const std :: string & path ); template < class T > void SaveStruct ( const T & obj , const std :: string & path ); // If main struct template < class T > std :: string StructToString ( const T & obj ); template < class T > std :: string StructToStringPretty ( const T & obj ); template < class T > bool StringToStruct ( const std :: string & obj_str , T & obj ); LoadStruct and SaveStruct are directly json to file or file to json. StructToString and StringToStruct are json to string or string to json (used in telemetry for exchanging messages). StructToStringPretty is json to string with pretty formatting. Serialize , Deserialize and CheckJson are internal functions.","title":"JSON Loader"},{"location":"telemetry-json-loader/#json-loader","text":"This project allows generating c++ json loader classes from json files. Given json as input it detects all fields (structs, vectors ...) and generates c++ code for loading them. The json library used is rapidjson","title":"JSON Loader"},{"location":"telemetry-json-loader/#usage","text":"Input files are located under json_input , each subfolder will later represent a .h file. Each .json file will be parsed and will be added to the corresponding .h file. These .json file are called Main Structs, and some functions generated supports only Main Structs. Nested structs are called Secondary structs, and cannot be loaded directly. The generated code is placed in out or in branch build.","title":"Usage"},{"location":"telemetry-json-loader/#functions-generated","text":"// T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T , class J > bool CheckJson ( const T & obj , const J & doc ); // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T , class J > void Deserialize ( T & obj , J & doc ); template < class T > void Serialize ( rapidjson :: Document & out , const T & obj ); template < class T > void Serialize ( rapidjson :: Value & out , const T & obj , rapidjson :: Document :: AllocatorType & alloc ); // If this is a main struct: // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T > bool LoadStruct ( T & out , const std :: string & path ); template < class T > void SaveStruct ( const T & obj , const std :: string & path ); // If main struct template < class T > std :: string StructToString ( const T & obj ); template < class T > std :: string StructToStringPretty ( const T & obj ); template < class T > bool StringToStruct ( const std :: string & obj_str , T & obj ); LoadStruct and SaveStruct are directly json to file or file to json. StructToString and StringToStruct are json to string or string to json (used in telemetry for exchanging messages). StructToStringPretty is json to string with pretty formatting. Serialize , Deserialize and CheckJson are internal functions.","title":"Functions generated"}]}